export module gui;

import std;
import toy;
import glm;
import "vulkan_config.h";
import "imgui_config.h";
import render.context;
import render.drawer;
import render.loop;
import vulkan.resource;
import vulkan.descriptor;
import vulkan.command;

export namespace gui {

void slider(const std::string& name, float& value, const float min = -50, const float max = 50) {
  ImGui::SliderFloat(name.c_str(), &value, min, max);
}

void slider(
  const std::string& name,
  glm::vec3&         value,
  const glm::vec3&   min = glm::vec3{ -5.0f },
  const glm::vec3&   max = glm::vec3{ 5.0f }
) {
  ImGui::SliderFloat(std::format("{}: x", name).c_str(), &value.x, min.x, max.x);
  ImGui::SliderFloat(std::format("{}: y", name).c_str(), &value.y, min.y, max.y);
  ImGui::SliderFloat(std::format("{}: z", name).c_str(), &value.z, min.z, max.z);
}

template <typename T>
void showPopup(T& t, std::map<T, std::string> elements) {
  if (ImGui::Button("Select..")) {
    ImGui::OpenPopup("my_select_popup");
  }
  ImGui::SameLine();
  ImGui::TextUnformatted(elements[t].c_str());
  if (ImGui::BeginPopup("my_select_popup")) {
    ImGui::SeparatorText("Aquarium");
    for (auto& element : elements) {
      if (ImGui::Selectable(element.second.c_str())) {
        t = element.first;
      }
    }
    ImGui::EndPopup();
  }
}

class Drawer {
public:
  virtual void draw() = 0;
};

/**
 * @brief must call after input processor
 *
 */
class Context : public toy::ProactiveSingleton<Context>,
                public toy::InterfaceLoader<Context, render::DrawRecorder, render::Drawer>,
                public toy::InterfaceLoader<Context, render::LoopAction, render::Loop> {
private:
  static constexpr auto _base_font_size = 13;
  static constexpr auto _default_scale = 2.0f;
  static constexpr auto _max_scale = 5.0f;
  static constexpr auto _min_scale = 0.5f;
  static constexpr auto _default_font_size = static_cast<int>(_base_font_size * _max_scale / 2);

  toy::RefContainer<Drawer>         _drawers;
  toy::RefContainer<toy::Generator> _co_drawers;

  float    _scale;
  ImGuiIO* _io;

  vk::DescriptorPool _dp_pool;

  bool _draw_called;

public:
  Context() {
    auto& ctx = render::Context::getInstance();
    // imgui 准备阶段 :
    // call ImGui::CreateContext()
    // call ImGui_ImplXXXX_Init() for each backend
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    // install_callbacks: 如果为true，则imgui会设置glfw的相关callback,
    // 原来的callback（如果有）的函数指针会保存，imgui的callback会先调用
    ImGui_ImplGlfw_InitForVulkan(ctx.window, true);
    ImGui_ImplVulkan_InitInfo init_info = {};
    init_info.Instance = ctx.instance.instance;
    init_info.PhysicalDevice = ctx.pdevice_info.device;
    init_info.Device = ctx.device;
    init_info.QueueFamily = ctx.graphic_ctx.family_index;
    init_info.Queue = ctx.graphic_ctx.queues[0];
    init_info.PipelineCache = VK_NULL_HANDLE;
    _dp_pool = vk::createDescriptorPool(
      ctx.device,
      1,
      std::array{
        VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1 },
      }
    );
    init_info.DescriptorPool = _dp_pool.get();
    init_info.RenderPass = ctx.render_pass;
    init_info.Subpass = 0;
    init_info.MinImageCount = 2;
    init_info.ImageCount = 2;
    init_info.MSAASamples = ctx.sample_count.value_or(VK_SAMPLE_COUNT_1_BIT);
    init_info.Allocator = nullptr;
    init_info.CheckVkResultFn = [](VkResult err) {
      if (err == 0)
        return;
      toy::debugf("[vulkan] Error: VkResult = {}", (int)err);
      if (err < 0)
        abort();
    };
    ImGui_ImplVulkan_Init(&init_info);

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    // ImGui::StyleColorsLight();
    _io = &ImGui::GetIO();
    _scale = _default_scale;
    _io->Fonts->AddFontFromFileTTF("TIMES.TTF", _default_font_size);
    _io->FontGlobalScale = _scale / (_default_font_size * 1.0f / _base_font_size);
    _draw_called = false;
  }
  ~Context() {
    // 销毁阶段:
    // call ImGui_ImplXXXX_Shutdown() for each backend
    // call ImGui::DestroyContext()
    ImGui_ImplVulkan_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
  }

  void draw() {
    // frame 创建阶段:
    // call ImGui_ImplXXXX_NewFrame() for each backend
    // call ImGui::NewFrame()
    ImGui_ImplVulkan_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();
    ImGui::ShowDemoWindow();
    ImGui::Begin("Gui Window");

    slider("scale ratio", _scale, _min_scale, _max_scale);
    _io->FontGlobalScale = _scale / (_default_font_size * 1.0f / _base_font_size);
    for (auto* drawer : _drawers) {
      drawer->draw();
    }
    for (auto* drawer : _co_drawers) {
      drawer->next();
    }
    ImGui::End();
    ImGui::Render();
    _draw_called = true;
  }
  void record(VkCommandBuffer cmdbuf, int in_flight_index) override {
    if (_draw_called) {
      ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), cmdbuf);
    }
  }

  void action() override { draw(); }

  operator toy::RefContainer<Drawer>&() { return _drawers; }
  operator toy::RefContainer<toy::Generator>&() { return _co_drawers; }
};

template <typename Derived>
class CoDrawer : public toy::Generator, public toy::AutoLoader<CoDrawer<Derived>, toy::Generator> {
public:
  template <typename _ = void>
    requires requires {
      { Derived::drawer() } -> std::convertible_to<toy::Generator>;
    }
  CoDrawer()
    : toy::Generator(Derived::drawer()),
      toy::AutoLoader<CoDrawer<Derived>, toy::Generator>(Context::getInstance()) {}
};

} // namespace gui