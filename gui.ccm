export module gui;

import std;
import toy;
import glm;
import "vulkan_config.h";
import "imgui_config.h";
import render.context;
import render.drawer;
import render.loop;
import vulkan.resource;
import vulkan.descriptor;
import vulkan.command;

export namespace gui {

void slider(const std::string& name, float& value, const float min = -50, const float max = 50) {
  ImGui::SliderFloat(name.c_str(), &value, min, max);
}

void slider(
  const std::string& name,
  glm::vec3&         value,
  const glm::vec3&   min = glm::vec3{ -5.0f },
  const glm::vec3&   max = glm::vec3{ 5.0f }
) {
  ImGui::SliderFloat(std::format("{}: x", name).c_str(), &value.x, min.x, max.x);
  ImGui::SliderFloat(std::format("{}: y", name).c_str(), &value.y, min.y, max.y);
  ImGui::SliderFloat(std::format("{}: z", name).c_str(), &value.z, min.z, max.z);
}

template <typename T>
void showPopup(T& t, std::map<T, const char*> elements) {
  if (ImGui::Button("Select..")) {
    ImGui::OpenPopup("my_select_popup");
  }
  ImGui::SameLine();
  ImGui::TextUnformatted(elements[t], elements[t]);
  if (ImGui::BeginPopup("my_select_popup")) {
    ImGui::SeparatorText("Aquarium");
    for (auto& element : elements) {
      if (ImGui::Selectable(element.second)) {
        t = element.first;
      }
    }
    ImGui::EndPopup();
  }
}

class TextInput {
private:
  static constexpr auto buf_size = 128;

  std::array<char, buf_size> _text_buf;

public:
  void draw(const std::string& label) {
    ImGui::InputText(label.data(), _text_buf.begin(), _text_buf.size());
  }
  auto getText() -> std::string { return { _text_buf.data() }; }
};

auto selectable_id = 0;

template <typename T>
class SelectableList {
private:
  const T* _selected = nullptr;
  int      _id = selectable_id++;

public:
  template <typename RangeT>
    requires std::same_as<ranges::range_value_t<RangeT>, T>
  void draw(const RangeT& range) {
    for (auto& item : range) {
      ImGui::PushID(_id);
      if (ImGui::Selectable(item.data(), _selected == &item)) {
        _selected = &item;
      }
      ImGui::PopID();
    }
  }
  auto getSelected() -> const T* { return _selected; }
};

/**
 * @brief the draw implement should only contain codes relevant to GUI draw
 */
class Drawer {
public:
  virtual void draw() = 0;
};

// todo: add depth test or something, make gui front regardless of the drawing order
/**
 * @brief must call after input processor
 *
 */
class Context : public toy::ProactiveSingleton<Context>,
                private rd::DrawerLoader<rd::DrawStage::GUI>,
                private rd::LoopActionLoader<rd::LoopOrder::GUI_RENDER> {
  friend class DrawerLoader;

private:
  static constexpr auto _base_font_size = 13;
  static constexpr auto _default_scale = 2.0f;
  static constexpr auto _max_scale = 5.0f;
  static constexpr auto _min_scale = 0.5f;
  static constexpr auto _default_font_size = static_cast<int>(_base_font_size * _max_scale / 2);

  toy::RefContainer<Drawer>         _drawers;
  toy::RefContainer<toy::Generator> _co_drawers;

  float    _scale;
  ImGuiIO* _io;

  vk::DescriptorPool _dp_pool;

public:
  Context() {
    auto& ctx = rd::Context::getInstance();
    // imgui 准备阶段 :
    // call ImGui::CreateContext()
    // call ImGui_ImplXXXX_Init() for each backend
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    // install_callbacks: 如果为true，则imgui会设置glfw的相关callback,
    // 原来的callback（如果有）的函数指针会保存，imgui的callback会先调用
    ImGui_ImplGlfw_InitForVulkan(ctx.window, true);
    ImGui_ImplVulkan_InitInfo init_info = {};
    init_info.Instance = ctx.instance.instance;
    init_info.PhysicalDevice = ctx.pdevice_info.device;
    init_info.Device = ctx.device;
    init_info.QueueFamily = ctx.graphic_ctx.family_index;
    init_info.Queue = ctx.graphic_ctx.queues[0];
    init_info.PipelineCache = VK_NULL_HANDLE;
    _dp_pool = vk::createDescriptorPool(
      ctx.device,
      1,
      std::array{
        VkDescriptorPoolSize{ VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1 },
      }
    );
    init_info.DescriptorPool = _dp_pool.get();
    init_info.RenderPass = ctx.render_pass;
    init_info.Subpass = 0;
    init_info.MinImageCount = 2;
    init_info.ImageCount = 2;
    init_info.MSAASamples = ctx.sample_count.value_or(VK_SAMPLE_COUNT_1_BIT);
    init_info.Allocator = nullptr;
    init_info.CheckVkResultFn = [](VkResult err) {
      if (err == 0)
        return;
      toy::debugf("[vulkan] Error: VkResult = {}", (int)err);
      if (err < 0)
        abort();
    };
    ImGui_ImplVulkan_Init(&init_info);

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    // ImGui::StyleColorsLight();
    _io = &ImGui::GetIO();
    _scale = _default_scale;
    _io->Fonts->AddFontFromFileTTF("TIMES.TTF", _default_font_size);
    _io->FontGlobalScale = _scale / (_default_font_size * 1.0f / _base_font_size);
  }
  ~Context() {
    // 销毁阶段:
    // call ImGui_ImplXXXX_Shutdown() for each backend
    // call ImGui::DestroyContext()
    ImGui_ImplVulkan_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
  }

  void draw() {
    // frame 创建阶段:
    // call ImGui_ImplXXXX_NewFrame() for each backend
    // call ImGui::NewFrame()
    ImGui_ImplVulkan_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();
    ImGui::ShowDemoWindow();
    ImGui::Begin("Gui Window");

    slider("scale ratio", _scale, _min_scale, _max_scale);
    _io->FontGlobalScale = _scale / (_default_font_size * 1.0f / _base_font_size);
    for (auto& drawer : _co_drawers) {
      drawer.next();
    }
    ImGui::End();
    for (auto& drawer : _drawers) {
      drawer.draw();
    }
    ImGui::Render();
  }
  void record(VkCommandBuffer cmdbuf, int in_flight_index) override {
    ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), cmdbuf);
  }

  void loopAction(uint32_t _) override { draw(); }

  operator toy::RefContainer<toy::Generator>&() { return _co_drawers; }
};

struct DrawerLoader : toy::InterfaceLoader<Drawer> {
  DrawerLoader() : toy::InterfaceLoader<Drawer>(Context::getInstance()._drawers) {}
};

class CoDrawer : public toy::Generator, public toy::AutoLoader<CoDrawer, toy::Generator> {
public:
  CoDrawer(toy::Generator generator)
    : toy::Generator(std::move(generator)),
      toy::AutoLoader<CoDrawer, toy::Generator>(Context::getInstance()) {}
};

} // namespace gui