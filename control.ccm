export module control;

import std;
import glm;
import gui;
import toy;
import render.context;
import render.input;
import render.command;
import transform;
import "glfw_config.h";
import "vulkan_config.h";
import "imgui_config.h";

export namespace control {

auto cmdExecutorMoniter() -> toy::Generator {
  auto  state = render::CommandExecutor::State{};
  auto& executor = render::CommandExecutor::getInstance();

  while (co_yield 0) {
    state = executor.getState();
    auto show_pool = [](render::PoolState state, const std::string& name) {
      ImGui::Text("%s", std::format("The {} pool:", name).c_str());
      ImGui::Text("%s", std::format("Total allocated resource: {}", state.allocate_n).c_str());
      ImGui::Text("%s", std::format("In use resource: {}", state.inuse_n).c_str());
    };
    show_pool(state.graphic_cmdbuf_state, "graphic cmdbuf");
    show_pool(state.transfer_cmdbuf_state, "transfer cmdbuf");
    show_pool(state.present_cmdbuf_state, "present cmdbuf");
    show_pool(state.fence_state, "fence");
    show_pool(state.sema_state, "sema");
  }
}

class ModelInput {
private:
  glm::mat4* _model;
  float      _speed;
  bool       _self;

  std::array<render::KeyHoldHandler, 4> _handlers;

  gui::CoDrawer _co_drawer;

  void setInput() {
    _handlers = {
      render::KeyHoldHandler{
        GLFW_KEY_A,
        [&](auto _) {
          *_model = *_model * trans::translate(glm::vec3{ +_speed, .0f, .0f });
        } },
      render::KeyHoldHandler{
        GLFW_KEY_D,
        [&](auto _) {
          *_model = *_model * trans::translate(glm::vec3{ -_speed, .0f, .0f });
        } },
      render::KeyHoldHandler{
        GLFW_KEY_W,
        [&](auto _) {
          *_model = *_model * trans::translate(glm::vec3{ .0f, +_speed, .0f });
        } },
      render::KeyHoldHandler{
        GLFW_KEY_S,
        [&](auto _) {
          *_model = *_model * trans::translate(glm::vec3{ .0f, -_speed, .0f });
        } },
    };
  }
  void clearInput() { _handlers = {}; }

public:
  ModelInput(glm::mat4& model, const std::string& label = "default")
    : _model(&model), _speed(0.1f), _self(false), _co_drawer(draw()) {}

  auto draw() -> toy::Generator {
    auto  last_input = false;
    auto  input = false;
    auto  gui_set = false;
    auto  axis = glm::vec3{ 1.0f, 0.0f, 0.0f };
    auto  degree = float{};
    auto& model = *_model;
    while (co_yield 0) {
      ImGui::Checkbox("Enable input control ?", &input);
      if (last_input != input) {
        if (input) {
          setInput();
        } else {
          clearInput();
        }
      }
      last_input = input;
      ImGui::Checkbox("Move model self ?", &_self);
      ImGui::Checkbox("Enable Gui Set Model", &gui_set);
      if (gui_set) {
        // gui::slider("location", _location);
        // gui::slider("scale", _scale);
        gui::slider("rotate axis", axis);
        gui::slider("rotate degree", degree, 0.0f, 360.0f);
        model = trans::rotate(axis, degree);
      }
    }
  }
  // todo: how to move coroutine?
  ModelInput(const ModelInput&) noexcept = delete;
  ModelInput(ModelInput&&) noexcept = delete;
  auto operator=(const ModelInput&) noexcept -> ModelInput& = delete;
  auto operator=(ModelInput&&) noexcept -> ModelInput& = delete;
};

auto cameraController(glm::mat4& view, glm::vec3 location = glm::vec3{ -1.0f, 0.0f, 0.0f })
  -> toy::Generator {
  auto move_speed = 1.0f;
  auto rotate_speed = 1.0f;
  auto delta = 1.0f / 60.0f;
  auto rotate_z = 0.0f;
  auto rotate_y = 0.0f;
  auto translate = trans::translate(-location);
  auto compute_view = [&]() {
    view =
      trans::rotate<trans::Axis::Y>(rotate_y) * trans::rotate<trans::Axis::Z>(rotate_z) * translate;
  };
  auto move = [&](glm::vec3 moved) {
    translate = trans::rotate<trans::Axis::Z>(-rotate_z) * trans::translate(moved) *
                trans::rotate<trans::Axis::Z>(rotate_z) * translate;
  };
  auto hold_handlers = std::array{
    render::KeyHoldHandler{
      GLFW_KEY_S,
      [&](auto _) {
        move(glm::vec3{ move_speed * delta, 0.0f, 0.0f });
      },
    },
    render::KeyHoldHandler{
      GLFW_KEY_W,
      [&](auto _) {
        move(glm::vec3{ -move_speed * delta, 0.0f, 0.0f });
      },
    },
    render::KeyHoldHandler{
      GLFW_KEY_A,
      [&](auto _) {
        move(glm::vec3{ 0.0f, -move_speed * delta, 0.0f });
      },
    },
    render::KeyHoldHandler{
      GLFW_KEY_D,
      [&](auto _) {
        move(glm::vec3{ 0.0f, move_speed * delta, 0.0f });
      },
    },
    render::KeyHoldHandler{
      GLFW_KEY_Z,
      [&](auto _) {
        move(glm::vec3{ 0.0f, 0.0f, -move_speed * delta });
      },
    },
    render::KeyHoldHandler{
      GLFW_KEY_X,
      [&](auto _) {
        move(glm::vec3{ 0.0f, 0.0f, move_speed * delta });
      },
    },
  };
  auto cursor_handlers = std::array{
    render::CursorMoveHandler([&](double x, double y) {
      // x: left, y: down
      if (render::InputProcessor::getInstance().isCursorVisible()) {
        return;
      }
      // x为正 -> 鼠标右移 -> 所有坐标沿z轴正旋转
      rotate_z += x / 1920 * 360;
      // y为正 -> 鼠标下移 -> 所有坐标沿y轴负旋转
      rotate_y -= y / 1080 * 360;
      rotate_y = std::clamp(rotate_y, -90.0f, 90.0f);
    }),
  };
  while (co_yield 0) {
    compute_view();
  }
}

} // namespace control