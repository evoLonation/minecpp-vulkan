export module control;

import std;
import glm;
import gui;
import toy;
import render.context;
import render.command;
import action;
import transform;
import "glfw_config.h";
import "vulkan_config.h";
import "imgui_config.h";

export namespace control {

auto cmdExecutorMoniter() -> toy::Generator {
  auto  state = render::CommandExecutor::State{};
  auto& executor = render::CommandExecutor::getInstance();

  while (co_yield 0) {
    state = executor.getState();
    auto show_pool = [](render::PoolState state, const std::string& name) {
      ImGui::Text("%s", std::format("The {} pool:", name).c_str());
      ImGui::Text("%s", std::format("Total allocated resource: {}", state.allocate_n).c_str());
      ImGui::Text("%s", std::format("In use resource: {}", state.inuse_n).c_str());
    };
    show_pool(state.graphic_cmdbuf_state, "graphic cmdbuf");
    show_pool(state.transfer_cmdbuf_state, "transfer cmdbuf");
    show_pool(state.present_cmdbuf_state, "present cmdbuf");
    show_pool(state.fence_state, "fence");
    show_pool(state.sema_state, "sema");
  }
}

class ModelInput : public action::KeyboardLoader {
private:
  glm::mat4* _model;
  float      _speed;
  bool       _self;

  // action::KeyboardAction _action;

  gui::CoDrawer _co_drawer;

  void run(const action::KeyboardContext& ctx) override {
    using action::Keyboard;
    switch (ctx.event.key) {
    case Keyboard::KEY_A:
      *_model = *_model * trans::translate(glm::vec3{ +_speed, .0f, .0f });
      break;
    case Keyboard::KEY_D:
      *_model = *_model * trans::translate(glm::vec3{ -_speed, .0f, .0f });
      break;
    case Keyboard::KEY_W:
      *_model = *_model * trans::translate(glm::vec3{ .0f, +_speed, .0f });
      break;
    case Keyboard::KEY_S:
      *_model = *_model * trans::translate(glm::vec3{ .0f, -_speed, .0f });
    default:
      toy::throwf("wrong keyboard event");
    }
  }
  void setInput() {
    using action::Keyboard;
    action::KeyboardLoader::load(
      { Keyboard::KEY_A, Keyboard::KEY_D, Keyboard::KEY_W, Keyboard::KEY_S }
    );
  }
  void clearInput() { action::KeyboardLoader::unRegist(); }

public:
  ModelInput(glm::mat4& model, const std::string& label = "default")
    : _model(&model), _speed(0.1f), _self(false), _co_drawer(draw()) {}

  auto draw() -> toy::Generator {
    auto  last_input = false;
    auto  input = false;
    auto  gui_set = false;
    auto  axis = glm::vec3{ 1.0f, 0.0f, 0.0f };
    auto  degree = float{};
    auto& model = *_model;
    while (co_yield 0) {
      ImGui::Checkbox("Enable input control ?", &input);
      if (last_input != input) {
        if (input) {
          setInput();
        } else {
          clearInput();
        }
      }
      last_input = input;
      ImGui::Checkbox("Move model self ?", &_self);
      ImGui::Checkbox("Enable Gui Set Model", &gui_set);
      if (gui_set) {
        // gui::slider("location", _location);
        // gui::slider("scale", _scale);
        gui::slider("rotate axis", axis);
        gui::slider("rotate degree", degree, 0.0f, 360.0f);
        model = trans::rotate(axis, degree);
      }
    }
  }
  // todo: how to move coroutine?
  ModelInput(const ModelInput&) noexcept = delete;
  ModelInput(ModelInput&&) noexcept = delete;
  auto operator=(const ModelInput&) noexcept -> ModelInput& = delete;
  auto operator=(ModelInput&&) noexcept -> ModelInput& = delete;
};

auto cameraController(glm::mat4& view, glm::vec3 location = glm::vec3{ -1.0f, 0.0f, 0.0f })
  -> toy::Generator {
  auto move_speed = 1.0f;
  auto rotate_speed = 1.0f;
  auto delta = 1.0f / 60.0f;
  auto rotate_z = 0.0f;
  auto rotate_y = 0.0f;
  auto translate = trans::translate(-location);
  auto compute_view = [&]() {
    view =
      trans::rotate<trans::Axis::Y>(rotate_y) * trans::rotate<trans::Axis::Z>(rotate_z) * translate;
  };
  auto move = [&](glm::vec3 moved) {
    translate = trans::rotate<trans::Axis::Z>(-rotate_z) * trans::translate(moved) *
                trans::rotate<trans::Axis::Z>(rotate_z) * translate;
  };
  using action::Keyboard;

  auto action_handler = action::KeyboardAction{
    {
      Keyboard::KEY_S,
      Keyboard::KEY_W,
      Keyboard::KEY_A,
      Keyboard::KEY_D,
      Keyboard::KEY_Z,
      Keyboard::KEY_X,
    },
    [&](const action::KeyboardContext& ctx) {
      switch (ctx.event.key) {
      case Keyboard::KEY_S:
        move(glm::vec3{ move_speed * delta, 0.0f, 0.0f });
        break;
      case Keyboard::KEY_W:
        move(glm::vec3{ -move_speed * delta, 0.0f, 0.0f });
        break;
      case Keyboard::KEY_A:
        move(glm::vec3{ 0.0f, -move_speed * delta, 0.0f });
        break;
      case Keyboard::KEY_D:
        move(glm::vec3{ 0.0f, move_speed * delta, 0.0f });
        break;
      case Keyboard::KEY_Z:
        move(glm::vec3{ 0.0f, 0.0f, -move_speed * delta });
        break;
      case Keyboard::KEY_X:
        move(glm::vec3{ 0.0f, 0.0f, move_speed * delta });
        break;
      default:
        toy::throwf("camera input handler event error");
      }
    },
  };
  auto cursor_handler = action::CursorAction{ [&](const action::ActionContext& ctx) {
    // x: left, y: down
    auto x = ctx.cursor.x_move;
    auto y = ctx.cursor.y_move;
    if (ctx.cursor.visible) {
      return;
    }
    // x为正 -> 鼠标右移 -> 所有坐标沿z轴正旋转
    rotate_z += x / 1920.0f * 360;
    // y为正 -> 鼠标下移 -> 所有坐标沿y轴负旋转
    rotate_y -= y / 1080.0f * 360;
    rotate_y = std::clamp(rotate_y, -90.0f, 90.0f);
  } };
  while (co_yield 0) {
    compute_view();
  }
}

void cursor2Plane(
  float            pos_x,
  float            pos_y,
  const glm::mat4& perspective,
  const glm::mat4& perspective_iv,
  const glm::mat4& view,
  glm::mat4&       model
) {
  auto& ctx = render::Context::getInstance().extent;
  auto  ndc_x = pos_x / ctx.width * 2 - 1;
  auto  ndc_y = pos_y / ctx.height * 2 - 1;
  auto  start = glm::vec3{ ndc_x, ndc_y, -1.0f };
  auto  end = glm::vec3{ ndc_x, ndc_y, 1.0f };
  auto  start_2 =
    trans::inverse(model) * trans::inverse(view) * perspective_iv * glm::vec4{ start, 1.0f };
  start = start_2 / start_2.w;
  auto end_2 =
    trans::inverse(model) * trans::inverse(view) * perspective_iv * glm::vec4{ end, 1.0f };
  end = end_2 / end_2.w;
  auto inter = trans::intersection(
    trans::Line{
      .direction = end - start,
      .point = start,
    },
    trans::Surface{
      .normal = glm::vec3{ 1.0f, 0.0f, 0.0f },
      .dot = 0.0f,
    }
  );
  if (inter.index() == 0) {
    auto inter_point = std::get<0>(inter);
    if (glm::dot(inter_point - start, inter_point - end) < 0) {
      toy::debug(std::tuple{ inter_point.x, inter_point.y, inter_point.z });
      model = model * trans::translate(inter_point);
    }
  }
}

class CursorDragger : private action::ActionLoader {
private:
  const glm::mat4* _perspective;
  const glm::mat4* _perspective_iv;
  const glm::mat4* _view;
  glm::mat4*       _model;

public:
  CursorDragger(
    const glm::mat4& perspective,
    const glm::mat4& perspective_iv,
    const glm::mat4& view,
    glm::mat4&       model
  )
    : _perspective(&perspective), _perspective_iv(&perspective_iv), _view(&view), _model(&model) {}
  void run(const action::ActionContext& ctx) override {
    auto& cursor = ctx.cursor;
    cursor2Plane(cursor.x, cursor.y, *_perspective, *_perspective_iv, *_view, *_model);
  }
};

} // namespace control