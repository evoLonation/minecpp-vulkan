module;
#include "enum.h"

export module manager;

import "vulkan_config.h";
import "imgui_config.h";

import std;
import toy;
import render;
import model;
import vulkan;
import gui;
import action;

export namespace mng {

TOY_ENUM(PipelineType, DEFAULT, OUTLINE_1, OUTLINE_2);

class PipelineResource {
private:
  rd::Pipeline pipeline;
};

auto create(PipelineType type) -> rd::Pipeline {
  auto stencil_options = vk::getOutliningStencil();
  stencil_options.first.dynamic_reference = false;
  stencil_options.second.dynamic_reference = true;
  switch (type.value()) {
  case PipelineType::DEFAULT:
    return rd::Pipeline{ "hello.vert",
                             "hello.frag",
                             VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
                             model::Vertex::getVertexInfo(),
                             std::array{ rd::ResourceType::UNIFORM,
                                         rd::ResourceType::UNIFORM,
                                         rd::ResourceType::UNIFORM,
                                         rd::ResourceType::SAMPLER },
                             std::nullopt };
  case PipelineType::OUTLINE_1:
    return rd::Pipeline{ "hello.vert",
                             "hello.frag",
                             VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
                             model::Vertex::getVertexInfo(),
                             std::array{ rd::ResourceType::UNIFORM,
                                         rd::ResourceType::UNIFORM,
                                         rd::ResourceType::UNIFORM,
                                         rd::ResourceType::SAMPLER },
                             stencil_options.first };
  case PipelineType::OUTLINE_2:
    return rd::Pipeline{ "outline.vert",
                             "outline.frag",
                             VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
                             model::Vertex::getVertexInfo(),
                             std::array{ rd::ResourceType::UNIFORM,
                                         rd::ResourceType::UNIFORM,
                                         rd::ResourceType::UNIFORM },
                             stencil_options.second };
  }
}

class Manager : private gui::DrawerLoader, private action::ActionLoader {
private:
  std::map<std::string, rd::Pipeline> _resources;

  std::array<char, 128> _resource_name_buf;
  PipelineType          _pipeline_type;

  std::array<const char*, 3> _pipeline_type_items;
  int                        _pipeline_type_item;

  const std::string* _selected_item;

  std::queue<std::function<void()>> _events;

public:
  Manager() {
    _resource_name_buf = {};
    ranges::copy(
      views::iota(0u, toy::enumCount<PipelineType>()) |
        views::transform([](auto i) { return toy::enum2String(PipelineType{ i }); }),
      _pipeline_type_items.begin()
    );
    _selected_item = nullptr;
  }

  void draw() override {
    ImGui::Begin("Resource manager");
    ImGui::SeparatorText("Pipeline create");
    ImGui::InputText("Resource name", _resource_name_buf.begin(), _resource_name_buf.size());
    ImGui::Combo(
      "Pipeline type",
      &_pipeline_type_item,
      _pipeline_type_items.data(),
      _pipeline_type_items.size()
    );
    if (ImGui::Button("Create pipeline")) {
      _events.emplace([&]() {
        _resources.emplace(
          std::string{ _resource_name_buf.data() },
          create(static_cast<PipelineType>(_pipeline_type_item))
        );
      });
    }
    ImGui::SeparatorText("Pipeline list");
    for (auto& name : _resources | views::keys) {
      if (ImGui::Selectable(name.data(), _selected_item == &name)) {
        _selected_item = &name;
      }
    }
    ImGui::SeparatorText("Pipeline info");
    if (_selected_item == nullptr) {
      ImGui::Text("No select any pipeline");
    } else {
      ImGui::Text("%s", std::format("Selected pipeline: {}", *_selected_item).data());
      // ImGui::Text("%s", std::format("Pipeline type: {}", _resources[*_selected_item]).data());
    }
    ImGui::End();
  }

  void run(const action::ActionContext& ctx) override {
    while (!_events.empty()) {
      _events.back()();
      _events.pop();
    }
  }
};

} // namespace mng