export module toy.helper;

import std;
import toy.log;
import toy.concepts;

export namespace toy {

template <typename... Lambdas>
struct OverloadLambda : public Lambdas... {
  using Lambdas::operator()...;
};

/**
 * @brief 需要主动构造，可含有参数，若在构造前调用getInstance()会抛异常
 * @tparam T
 */
template <typename Derived>
class ProactiveSingleton {
private:
  static inline Derived* _instance_ptr = nullptr;

  auto self() -> Derived& { return static_cast<Derived&>(*this); }

public:
  ProactiveSingleton() {
    if (_instance_ptr != nullptr) {
      toy::throwf("construct multi time!");
    }
    _instance_ptr = &self();
  }
  ~ProactiveSingleton() {
    if (_instance_ptr == this) {
      _instance_ptr = nullptr;
    }
  }

  static auto getInstance() -> Derived& {
    if (_instance_ptr == nullptr) {
      toy::throwf("need proactively construct first!");
    }
    return *_instance_ptr;
  }

  // deleted copy semantic
  ProactiveSingleton& operator=(const ProactiveSingleton&) = delete;
  ProactiveSingleton(const ProactiveSingleton&) = delete;
  // move semantic
  ProactiveSingleton& operator=(ProactiveSingleton&&) { _instance_ptr = &self(); }
  ProactiveSingleton(ProactiveSingleton&&) { _instance_ptr = &self(); }
};

template <typename Derived, typename T = Derived>
class AutoLoader;

/**
 * @brief 保证RefContainer在所有还没有unregist的AutoLoader之后析构
 *
 * @tparam T
 */
template <typename T>
class RefContainer {
  template <typename, typename>
  friend class AutoLoader;
  template <typename, typename>
  friend class MultiLoader;

private:
  std::map<size_t, T*>           _id2pointer;
  std::unordered_map<T*, size_t> _pointer2id;

  size_t _max_id;

  void add(T* e) {
    _id2pointer.emplace(_max_id + 1, e);
    _pointer2id.emplace(e, _max_id + 1);
    _max_id++;
  }
  void remove(T* e) {
    auto id = _pointer2id.at(e);
    _pointer2id.erase(e);
    _id2pointer.erase(id);
  }

public:
  class Iterator {
  private:
    ranges::iterator_t<std::map<size_t, T*>> _base;

  public:
    using difference_type = std::ptrdiff_t;
    using value_type = T;
    Iterator() = default;
    Iterator(ranges::iterator_t<std::map<size_t, T*>> base) : _base(base) {}
    auto operator*() -> value_type& { return *_base->second; }
    auto operator*() const -> value_type& { return *_base->second; }
    auto operator++(int) -> Iterator { return _base++; }
    auto operator++() -> Iterator& {
      _base++;
      return *this;
    }
    auto operator--(int) -> Iterator { return _base--; }
    auto operator--() -> Iterator& {
      _base--;
      return *this;
    }
    friend auto operator==(Iterator a, Iterator b) -> bool { return a._base == b._base; }
  };

  RefContainer() : _max_id(0) {}
  Iterator       begin() { return _id2pointer.begin(); }
  Iterator       end() { return _id2pointer.end(); }
  decltype(auto) size() { return _id2pointer.size(); }
};

/**
 * @brief 自动装载到RefContainer<T>中
 *
 * @tparam Derived CRTP中的子类
 * @tparam T 默认为Derived，可以设置为Derived的父类
 */
template <typename Derived, typename T = Derived>
class AutoLoader {
private:
  RefContainer<T>* _container;

private:
  template <typename _ = void>
    requires std::derived_from<Derived, T>
  auto self() -> T& {
    return static_cast<T&>(static_cast<Derived&>(*this));
  }
  void init(RefContainer<T>& container) {
    _container = &container;
    if (_container != nullptr) {
      _container->add(&self());
    }
  }
  void remove() {
    if (_container != nullptr) {
      _container->remove(&self());
    }
  }
  void setMoved() { _container = nullptr; }

public:
  AutoLoader() : _container(nullptr) {}
  AutoLoader(RefContainer<T>& container) { init(container); }

  ~AutoLoader() { remove(); }

  AutoLoader(const AutoLoader& e) : AutoLoader{ *e._container } {}
  AutoLoader(AutoLoader&& e) : AutoLoader{ *e._container } {
    e.remove();
    e.setMoved();
  }
  auto operator=(const AutoLoader& e) -> AutoLoader& {
    remove();
    init(*e._container);
    return *this;
  }
  auto operator=(AutoLoader&& e) -> AutoLoader& {
    remove();
    init(*e._container);
    e.remove();
    e.setMoved();
    return *this;
  }
  void regist(RefContainer<T>& container) {
    remove();
    init(container);
  }
  void unRegist() {
    remove();
    setMoved();
  }
};

template <typename Derived, typename T = Derived>
class MultiLoader {
  friend RefContainer<T>;

private:
  std::unordered_set<RefContainer<T>*> _containers;

private:
  template <typename _ = void>
    requires std::derived_from<Derived, T>
  auto self() -> T& {
    return static_cast<T&>(static_cast<Derived&>(*this));
  }
  template <typename RangeT>
    requires std::convertible_to<ranges::range_reference_t<RangeT>, RefContainer<T>&>
  void load(RangeT&& containers) {
    for (RefContainer<T>& container : containers) {
      toy::checkThrowf(
        !_containers.contains(&container), "init with container which already in _containers"
      );
      _containers.insert(&container);
      container.add(&self());
    }
  }
  void unload() {
    for (auto* container : _containers) {
      container->remove(&self());
    }
    _containers.clear();
  }
  void unload(RefContainer<T>& container) {
    toy::checkThrowf(
      _containers.contains(&container), "unload error: _containers does not contain container"
    );
    _containers.erase(&container);
    container.remove(&self());
  }

public:
  MultiLoader() = default;
  MultiLoader(auto&& containers) { load(std::forward<decltype(containers)>(containers)); }
  ~MultiLoader() { unload(); }

  MultiLoader(const MultiLoader& e) : MultiLoader{ e._containers } {}
  MultiLoader(MultiLoader&& e) : MultiLoader{ e._containers } { e.unload(); }
  auto operator=(const MultiLoader& e) -> MultiLoader& {
    unload();
    load(e._containers);
    return *this;
  }
  auto operator=(MultiLoader&& e) -> MultiLoader& {
    unload();
    load(e._containers);
    e.unload();
    return *this;
  }
  void regist(RefContainer<T>& container) {
    load(std::array<std::reference_wrapper<RefContainer<T>>, 1>{ container });
  }
  void unRegist() { unload(); }
  void unRegist(RefContainer<T>& container) { unload(container); }
};

template <typename Interface, typename Container = RefContainer<Interface>>
class InterfaceLoader : public Interface,
                        private toy::AutoLoader<InterfaceLoader<Interface, Container>, Interface> {
private:
  using AutoLoader = toy::AutoLoader<InterfaceLoader<Interface, Container>, Interface>;
  friend AutoLoader;

  template <typename _ = void>
    requires std::convertible_to<Container, RefContainer<Interface>>
  auto conceptCheck() {}

public:
  template <typename _ = void>
    requires(!std::derived_from<Container, ProactiveSingleton<Container>>)
  InterfaceLoader() {
    conceptCheck();
  }
  template <typename _ = void>
    requires std::derived_from<Container, ProactiveSingleton<Container>>
  InterfaceLoader() : AutoLoader(Container::getInstance()) {
    conceptCheck();
  }
  template <typename _ = void>
    requires(!std::derived_from<Container, ProactiveSingleton<Container>>)
  InterfaceLoader(Container& container) : AutoLoader(container) {
    conceptCheck();
  }
};

// for macro generate to enum
template <typename EnumT>
constexpr auto enum2String(EnumT t) -> const char* {
  return &EnumT::pair.first[EnumT::pair.second[t._value]];
}
template <typename EnumT>
constexpr auto enumCount() -> std::size_t {
  return EnumT::count;
}

template <int... Values, std::size_t N>
consteval auto __splitString(const char (&buf)[N])
  -> std::pair<std::array<char, N>, std::array<std::size_t, sizeof...(Values)>> {
  auto writable = std::array<char, N>{};
  auto indices = std::array<std::size_t, sizeof...(Values)>{};
  std::copy(buf, buf + N, writable.begin());
  auto i_indices = 0;
  indices[i_indices] = 0;
  i_indices++;
  for (auto iter = writable.begin(); iter != writable.end(); iter++) {
    auto& c = *iter;
    if (c == ',') {
      c = '\0';
      indices[i_indices] = iter - writable.begin() + 2;
      i_indices++;
    }
  }
  return { writable, indices };
}

template <typename EnumT>
struct EnumSet {
  std::bitset<(size_t)EnumT::MAX_ENUM_VALUE> _bitset;
  EnumSet(std::initializer_list<EnumT> values) {
    for (auto value : values) {
      _bitset.set((size_t)value);
    }
  }
  EnumSet(EnumT value) { _bitset.set((size_t)value); }
  EnumSet() = default;
  friend auto operator|(EnumSet set, EnumT key) -> EnumSet {
    set._bitset.set((size_t)key);
    return set;
  }
  friend auto operator|(EnumSet a, EnumSet b) -> EnumSet { return a._bitset | b._bitset; }
  class Iterator {
  private:
    size_t         _index;
    const EnumSet* _set;

  public:
    Iterator() = default;
    Iterator(const EnumSet& set, size_t index) : _index(index), _set(&set) {
      while (_index < _set->_bitset.size() && !_set->_bitset[_index]) {
        _index++;
      }
    }
    using difference_type = std::ptrdiff_t;
    auto operator*() -> EnumT { return (EnumT)_index; }
    auto operator++() -> Iterator& {
      _index++;
      while (_index < _set->_bitset.size() && !_set->_bitset[_index]) {
        _index++;
      }
      return *this;
    }
    auto operator++(int) -> Iterator {
      auto iter = *this;
      ++*this;
      return iter;
    }
    friend auto operator==(const Iterator& a, const Iterator& b) -> bool = default;
  };

  auto begin() const { return Iterator(*this, 0); }
  auto end() const { return Iterator(*this, _bitset.size()); }
};

namespace test_refContainer {
class B : public AutoLoader<B> {
public:
  int num;
  B(RefContainer<B>& container, int num) : AutoLoader<B>(container), num(num) {}
};
class A : public RefContainer<B> {};

void test_base() {
  toy::debug("start test refcontainer");
  static_assert(ranges::sized_range<A>, "");
  static_assert(ranges::bidirectional_range<A>, "");
  static_assert(ranges::output_range<A, B>, "");
  auto a = A{};
  auto b1 = B{ a, 1 };
  {
    auto b2 = B{ a, 2 };
    auto b3 = B{ a, 3 };
    toy::debug(a | views::transform([](auto e) { return e.num; }));
  }
  toy::debug(a | views::transform([](auto e) { return e.num; }));
  {
    auto b2 = b1;
    toy::debug(a | views::transform([](auto e) { return e.num; }));
    auto b3 = std::move(b2);
    toy::debug(a | views::transform([](auto e) { return e.num; }));
  }
  toy::debug(a | views::transform([](auto e) { return e.num; }));
}

class M : public MultiLoader<M> {
public:
  using MultiLoader<M>::MultiLoader;
};
class C1 : public RefContainer<M> {};

void test_MultiLoader() {
  auto containers = std::array{ C1{}, C1{}, C1{} };
  {
    auto m1 = M{ containers | views::take(2) };
    // m1.regist(containers[0]);
    toy::checkThrowf(&*containers[0].begin() == &m1, "test multiloader error");
    toy::checkThrowf(&*containers[1].begin() == &m1, "test multiloader error");
    toy::checkThrowf(containers[2].begin() == containers[2].end(), "test multiloader error");
    m1.regist(containers[2]);
    toy::checkThrowf(&*containers[2].begin() == &m1, "test multiloader error");
    m1.unRegist(containers[1]);
    toy::checkThrowf(containers[1].begin() == containers[1].end(), "test multiloader error");
  }
  toy::checkThrowf(containers[0].begin() == containers[0].end(), "test multiloader error");
}

class Interface {
  virtual void foo() = 0;
};
class Container {
  RefContainer<Interface> interfaces;

public:
  operator RefContainer<Interface>&() { return interfaces; }
};
class Impl : public InterfaceLoader<Interface, Container> {
  void foo() override {}

public:
  Impl(Container& container) : InterfaceLoader<Interface, Container>(container) {}
};
class ContainerSingleton : public RefContainer<Interface>,
                           public ProactiveSingleton<ContainerSingleton> {};
class ImplForSingleton : public InterfaceLoader<Interface, ContainerSingleton> {
  void foo() override {}
};

void test_interfaceLoader() {
  auto container = Container{};
  auto impl = Impl{ container };
  auto singleton = ContainerSingleton{};
  auto impl2 = ImplForSingleton{};
  // impl2.regist(); private member
}

} // namespace test_refContainer

namespace test_EnumSet {

enum class A { A, B, C, MAX_ENUM_VALUE };

void test() {
  auto set = EnumSet<A>{};
  for (A a : set) {
    toy::checkThrowf(a != A::B && a != A::MAX_ENUM_VALUE, "enumset test wrong");
  }
  set = EnumSet<A>{ A::A, A::C };
}

} // namespace test_EnumSet

} // namespace toy