export module toy.helper;

import std;
import toy.log;

export namespace toy {

template <typename... Lambdas>
struct OverloadLambda : public Lambdas... {
  using Lambdas::operator()...;
};

/**
 * @brief 需要主动构造，可含有参数，若在构造前调用getInstance()会抛异常
 * @tparam T
 */
template <typename Derived>
class ProactiveSingleton {
private:
  static inline Derived* _instance_ptr = nullptr;

  auto self() -> Derived& { return static_cast<Derived&>(*this); }

public:
  ProactiveSingleton() {
    if (_instance_ptr != nullptr) {
      toy::throwf("construct multi time!");
    }
    _instance_ptr = &self();
  }
  ~ProactiveSingleton() {
    if (_instance_ptr == this) {
      _instance_ptr = nullptr;
    }
  }

  static auto getInstance() -> Derived& {
    if (_instance_ptr == nullptr) {
      toy::throwf("need proactively construct first!");
    }
    return *_instance_ptr;
  }

  // deleted copy semantic
  ProactiveSingleton& operator=(const ProactiveSingleton&) = delete;
  ProactiveSingleton(const ProactiveSingleton&) = delete;
  // move semantic
  ProactiveSingleton& operator=(ProactiveSingleton&&) { _instance_ptr = &self(); }
  ProactiveSingleton(ProactiveSingleton&&) { _instance_ptr = &self(); }
};

template <typename Derived, typename T = Derived>
class AutoLoader;

/**
 * @brief 保证RefContainer在所有还没有unregist的AutoLoader之后析构
 *
 * @tparam T
 */
template <typename T>
class RefContainer {
  template <typename, typename>
  friend class AutoLoader;

private:
  std::unordered_set<T*> _base;

  decltype(auto) add(T* e) noexcept(noexcept(_base.insert(e))) { return _base.insert(e); }
  decltype(auto) remove(T* e) noexcept(noexcept(_base.erase(e))) { return _base.erase(e); }

public:
  RefContainer() = default;
  decltype(auto) begin() noexcept(noexcept(_base.begin())) { return _base.begin(); }
  decltype(auto) end() noexcept(noexcept(_base.end())) { return _base.end(); }
  decltype(auto) size() noexcept(noexcept(_base.size())) { return _base.size(); }
};

/**
 * @brief 自动装载到RefContainer<T>中
 *
 * @tparam Derived CRTP中的子类
 * @tparam T 默认为Derived，可以设置为Derived的父类
 */
template <typename Derived, typename T = Derived>
class AutoLoader {
  friend RefContainer<T>;

private:
  RefContainer<T>* _container;

private:
  template <typename _ = void>
    requires std::derived_from<Derived, T>
  auto self() -> T& {
    return static_cast<T&>(static_cast<Derived&>(*this));
  }
  void init(RefContainer<T>& container) {
    _container = &container;
    if (_container != nullptr) {
      _container->add(&self());
    }
  }
  void remove() {
    if (_container != nullptr) {
      _container->remove(&self());
    }
  }
  void setMoved() { _container = nullptr; }

protected:
  AutoLoader() : _container(nullptr) {}
  AutoLoader(RefContainer<T>& container) { init(container); }

public:
  ~AutoLoader() { remove(); }

  AutoLoader(const AutoLoader& e) : AutoLoader{ *e._container } {}
  AutoLoader(AutoLoader&& e) : AutoLoader{ *e._container } {
    e.remove();
    e.setMoved();
  }
  auto operator=(const AutoLoader& e) -> AutoLoader& {
    remove();
    init(*e._container);
    return *this;
  }
  auto operator=(AutoLoader&& e) -> AutoLoader& {
    remove();
    init(*e._container);
    e.remove();
    e.setMoved();
    return *this;
  }
  void regist(RefContainer<T>& container) {
    remove();
    init(container);
  }
  void unRegist() {
    remove();
    setMoved();
  }
};

template <typename Interface, typename Container = RefContainer<Interface>>
class InterfaceLoader : public Interface,
                        private toy::AutoLoader<InterfaceLoader<Interface, Container>, Interface> {
private:
  using AutoLoader = toy::AutoLoader<InterfaceLoader<Interface, Container>, Interface>;
  friend AutoLoader;

  template <typename _ = void>
    requires std::convertible_to<Container, RefContainer<Interface>>
  auto conceptCheck() {}

public:
  template <typename _ = void>
    requires std::derived_from<Container, ProactiveSingleton<Container>>
  InterfaceLoader() : AutoLoader(Container::getInstance()) {
    conceptCheck();
  }
  template <typename _ = void>
    requires(!std::derived_from<Container, ProactiveSingleton<Container>>)
  InterfaceLoader(Container& container) : AutoLoader(container) {
    conceptCheck();
  }
};

namespace test_refContainer {
class B : public AutoLoader<B> {
public:
  int num;
  B(RefContainer<B>& container, int num) : AutoLoader<B>(container), num(num) {}
};
class A : public RefContainer<B> {};

void test_base() {
  toy::debug("start test refcontainer");
  auto a = A{};
  auto b1 = B{ a, 1 };
  {
    auto b2 = B{ a, 2 };
    auto b3 = B{ a, 3 };
    toy::debug(a | views::transform([](auto e) { return e->num; }));
  }
  toy::debug(a | views::transform([](auto e) { return e->num; }));
  {
    auto b2 = b1;
    toy::debug(a | views::transform([](auto e) { return e->num; }));
    auto b3 = std::move(b2);
    toy::debug(a | views::transform([](auto e) { return e->num; }));
  }
  toy::debug(a | views::transform([](auto e) { return e->num; }));
}

class Interface {
  virtual void foo() = 0;
};
class Container {
  RefContainer<Interface> interfaces;

public:
  operator RefContainer<Interface>&() { return interfaces; }
};
class Impl : public InterfaceLoader<Interface, Container> {
  void foo() override {}

public:
  Impl(Container& container) : InterfaceLoader<Interface, Container>(container) {}
};
class ContainerSingleton : public RefContainer<Interface>,
                           public ProactiveSingleton<ContainerSingleton> {};
class ImplForSingleton : public InterfaceLoader<Interface, ContainerSingleton> {
  void foo() override {}
};

void test_interfaceLoader() {
  auto container = Container{};
  auto impl = Impl{ container };
  auto singleton = ContainerSingleton{};
  auto impl2 = ImplForSingleton{};
  // impl2.regist(); private member
}

} // namespace test_refContainer

} // namespace toy