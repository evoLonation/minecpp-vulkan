export module toy.helper;

import std;
import toy.log;
import toy.concepts;

export namespace toy {

template <typename... Lambdas>
struct OverloadLambda : public Lambdas... {
  using Lambdas::operator()...;
};

/**
 * @brief 需要主动构造，可含有参数，若在构造前调用getInstance()会抛异常
 * @tparam T
 */
template <typename Derived>
class ProactiveSingleton {
private:
  static inline Derived* _instance_ptr = nullptr;

  auto self() -> Derived& { return static_cast<Derived&>(*this); }

public:
  ProactiveSingleton() {
    if (_instance_ptr != nullptr) {
      toy::throwf("construct multi time!");
    }
    _instance_ptr = &self();
  }
  ~ProactiveSingleton() {
    if (_instance_ptr == this) {
      _instance_ptr = nullptr;
    }
  }

  static auto getInstance() -> Derived& {
    if (_instance_ptr == nullptr) {
      toy::throwf("need proactively construct first!");
    }
    return *_instance_ptr;
  }

  // deleted copy semantic
  ProactiveSingleton& operator=(const ProactiveSingleton&) = delete;
  ProactiveSingleton(const ProactiveSingleton&) = delete;
  // move semantic
  ProactiveSingleton& operator=(ProactiveSingleton&&) { _instance_ptr = &self(); }
  ProactiveSingleton(ProactiveSingleton&&) { _instance_ptr = &self(); }
};

template <typename T>
using RefContainer = std::unordered_set<T*>;

/**
 * @brief 自动装载到RefContainer<Derived>中
 *
 * @tparam Derived CRTP中的子类
 */
template <typename Derived, typename T = Derived>
class RefLoader {
private:
  RefContainer<T>* _container;

  auto self() -> T& { return static_cast<T&>(static_cast<Derived&>(*this)); }
  void init(RefContainer<T>& container) {
    _container = &container;
    _container->emplace(&self());
  }
  void remove() {
    if (_container != nullptr) {
      _container->erase(&self());
    }
  }

public:
  RefLoader() : _container(nullptr) {}
  RefLoader(RefContainer<Derived>& container) { init(container); }
  ~RefLoader() { remove(); }

  RefLoader(const RefLoader&) noexcept = delete;
  RefLoader(RefLoader&&) noexcept = delete;
  auto operator=(const RefLoader&) noexcept -> RefLoader& = delete;
  auto operator=(RefLoader&&) noexcept -> RefLoader& = delete;
};

template <typename R, typename T>
concept RefContainers_1 =
  ranges::range<R> && std::same_as<RefContainer<T>&, ranges::range_reference_t<R>>;
template <typename R, typename T>
concept RefContainers_2 =
  ranges::range<R> && std::same_as<RefContainer<T>*, ranges::range_value_t<R>>;
template <typename R, typename T>
concept RefContainers_3 = std::same_as<RefContainer<T>&, R>;
template <typename R, typename T>
concept RefContainers_4 = std::same_as<RefContainer<T>*, R>;
template <typename R, typename T>
concept RefContainers =
  RefContainers_1<R, T> || RefContainers_2<R, T> || RefContainers_3<R, T> || RefContainers_4<R, T>;

/**
 * @brief ref loader by "hook" to get container provided by derived
 *
 * @tparam Derived. This class must not have any members or parent class which related to function
 * getContainer() and the construction order is after HookLoader
 */
template <typename Derived, typename T = Derived>
class HookLoader {
private:
  template <typename _ = void>
    requires requires(Derived& e) {
      { e.getContainer() } -> RefContainers<T>;
    }
  auto self() -> Derived& {
    return static_cast<Derived&>(*this);
  }
  auto target() -> T& { return static_cast<T&>(self()); }

  decltype(auto) getContainer() { return self().getContainer(); }

  void init() {
    decltype(auto) containers = getContainer();
    if constexpr (RefContainers_1<decltype(containers), T>) {
      for (auto& container : containers) {
        container.emplace(&target());
      }
    } else if constexpr (RefContainers_2<decltype(containers), T>) {
      for (auto* container : containers) {
        container->emplace(&target());
      }
    } else if constexpr (RefContainers_3<decltype(containers), T>) {
      containers.emplace(&target());
    } else if constexpr (RefContainers_4<decltype(containers), T>) {
      containers->emplace(&target());
    } else {
      static_assert(false);
    }
  }
  void remove() {
    decltype(auto) containers = getContainer();
    if constexpr (RefContainers_1<decltype(containers), T>) {
      for (auto& container : containers) {
        container.erase(&target());
      }
    } else if constexpr (RefContainers_2<decltype(containers), T>) {
      for (auto* container : containers) {
        container->erase(&target());
      }
    } else if constexpr (RefContainers_3<decltype(containers), T>) {
      containers.erase(&target());
    } else if constexpr (RefContainers_4<decltype(containers), T>) {
      containers->erase(&target());
    } else {
      static_assert(false);
    }
  }

public:
  HookLoader() { init(); }
  ~HookLoader() { remove(); }

  HookLoader(const HookLoader&) noexcept = delete;
  HookLoader(HookLoader&&) noexcept = delete;
  auto operator=(const HookLoader&) noexcept -> HookLoader& = delete;
  auto operator=(HookLoader&&) noexcept -> HookLoader& = delete;
};

// helper for string literal as non-type template parameter
template <size_t N>
struct StringLiteral {
  constexpr StringLiteral(const char (&str)[N]) { std::copy_n(str, N, value); }
  char value[N];
};

template <size_t size, typename Func>
decltype(auto) applyIndexSequence(Func&& func) {
  return [&]<size_t... indices>(std::index_sequence<indices...> _) {
    return func.template operator()<indices...>();
  }(std::make_index_sequence<size>{});
}

template <size_t size, typename Func>
  requires(size == 0) || requires(Func&& func) { func.template operator()<0>(); }
void templateForEach(Func&& func) {
  if constexpr (size != 0) {
    applyIndexSequence<size>([&]<size_t... indices>() {
      (func.template operator()<indices>(), ...);
    });
  }
}

namespace test_refContainer {
class B : public RefLoader<B> {
public:
  int num;
  B(RefContainer<B>& container, int num) : RefLoader<B>(container), num(num) {}
};
class A : public RefContainer<B> {};

void test_base() {
  toy::debug("start test refcontainer");
  auto a = A{};
  auto b1 = B{ a, 1 };
  {
    auto b2 = B{ a, 2 };
    auto b3 = B{ a, 3 };
    toy::debug(a | views::transform([](auto& e) { return e->num; }));
  }
  toy::debug(a | views::transform([](auto& e) { return e->num; }));
}

class M : public HookLoader<M> {
public:
  M() = default;
  auto getContainer() -> RefContainer<M>&;
  M(const M&) noexcept = delete;
  M(M&&) noexcept = delete;
  auto operator=(const M&) noexcept -> M& = delete;
  auto operator=(M&&) noexcept -> M& = delete;
};
class C1 : public RefContainer<M>, public ProactiveSingleton<C1> {};
auto M::getContainer() -> RefContainer<M>& { return C1::getInstance(); }

void test_MultiLoader() {
  auto c = C1{};
  {
    auto m = M{};
    toy::throwf(c.size() == 1, "error");
  }
  toy::throwf(c.size() == 0, "error");
}

} // namespace test_refContainer

namespace test_StringLiteral {

template <StringLiteral a>
void func() {}

void test() { func<"abcd">(); }

} // namespace test_StringLiteral

void test_templateForEach() {
  templateForEach<10>([]<size_t indice>() {
    if constexpr (indice == 0) {
    }
  });
}

} // namespace toy