export module toy.helper;

import std;
import toy.log;

export namespace toy {

template <typename... Lambdas>
struct OverloadLambda : public Lambdas... {
  using Lambdas::operator()...;
};

template <typename Derived, typename T = Derived>
class AutoLoader;

/**
 * @brief 保证RefContainer在所有还没有unregist的AutoLoader之后析构
 *
 * @tparam T
 */
template <typename T>
class RefContainer {
  template <typename, typename>
  friend class AutoLoader;

private:
  std::unordered_set<T*> _base;

  decltype(auto) add(T* e) noexcept(noexcept(_base.insert(e))) { return _base.insert(e); }
  decltype(auto) remove(T* e) noexcept(noexcept(_base.erase(e))) { return _base.erase(e); }

public:
  RefContainer() = default;
  decltype(auto) begin() noexcept(noexcept(_base.begin())) { return _base.begin(); }
  decltype(auto) end() noexcept(noexcept(_base.end())) { return _base.end(); }
  decltype(auto) size() noexcept(noexcept(_base.size())) { return _base.size(); }
};

/**
 * @brief 自动装载到RefContainer<T>中
 *
 * @tparam Derived CRTP中的子类
 * @tparam T 默认为Derived，可以设置为Derived的父类
 */
template <typename Derived, typename T = Derived>
class AutoLoader {
  friend RefContainer<T>;

private:
  RefContainer<T>* _container;

private:
  template <typename _ = void>
    requires std::derived_from<Derived, T>
  auto self() -> T& {
    return static_cast<T&>(static_cast<Derived&>(*this));
  }
  void init(RefContainer<T>& container) {
    _container = &container;
    _container->add(&self());
  }
  void remove() {
    if (_container != nullptr) {
      _container->remove(&self());
    }
  }
  void setMoved() { _container = nullptr; }

protected:
  AutoLoader() : _container(nullptr) {}
  AutoLoader(RefContainer<T>& container) { init(container); }

public:
  ~AutoLoader() { remove(); }

  AutoLoader(const AutoLoader& e) : AutoLoader{ *e._container } {}
  AutoLoader(AutoLoader&& e) : AutoLoader{ *e._container } {
    e.remove();
    e.setMoved();
  }
  auto operator=(const AutoLoader& e) -> AutoLoader& {
    remove();
    init(e._container);
  }
  auto operator=(AutoLoader&& e) -> AutoLoader& {
    remove();
    init(e._container);
    e.remove();
    e.setMoved();
  }
  void regist(RefContainer<T>& container) {
    remove();
    init(container);
  }
  void unRegist() {
    remove();
    setMoved();
  }
};

namespace test_refContainer {
class B : public AutoLoader<B> {
public:
  int num;
  B(RefContainer<B>& container, int num) : AutoLoader<B>(container), num(num) {}
};
class A : public RefContainer<B> {};

void test() {
  toy::debug("start test refcontainer");
  auto a = A{};
  auto b1 = B{ a, 1 };
  {
    auto b2 = B{ a, 2 };
    auto b3 = B{ a, 3 };
    toy::debug(a | views::transform([](auto e) { return e->num; }));
  }
  toy::debug(a | views::transform([](auto e) { return e->num; }));
  {
    auto b2 = b1;
    toy::debug(a | views::transform([](auto e) { return e->num; }));
    auto b3 = std::move(b2);
    toy::debug(a | views::transform([](auto e) { return e->num; }));
  }
  toy::debug(a | views::transform([](auto e) { return e->num; }));
}

} // namespace test_refContainer

/**
 * @brief 需要主动构造，可含有参数，若在构造前调用getInstance()会抛异常
 * @tparam T
 */
template <typename Derived>
class ProactiveSingleton {
private:
  static inline Derived* _instance_ptr = nullptr;

protected:
  auto self() -> Derived& { return static_cast<Derived&>(*this); }
  ProactiveSingleton() {
    if (_instance_ptr != nullptr) {
      toy::throwf("construct multi time!");
    }
    _instance_ptr = &self();
  }
  ~ProactiveSingleton() {
    if (_instance_ptr == this) {
      _instance_ptr = nullptr;
    }
  }

public:
  static auto getInstance() -> Derived& {
    if (_instance_ptr == nullptr) {
      toy::throwf("need proactively construct first!");
    }
    return *_instance_ptr;
  }

  // deleted copy semantic
  ProactiveSingleton& operator=(const ProactiveSingleton&) = delete;
  ProactiveSingleton(const ProactiveSingleton&) = delete;
  // move semantic
  ProactiveSingleton& operator=(ProactiveSingleton&&) { _instance_ptr = &self(); }
  ProactiveSingleton(ProactiveSingleton&&) { _instance_ptr = &self(); }
};

} // namespace toy