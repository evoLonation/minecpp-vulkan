export module toy.trait;

import std;

export namespace toy {

template <typename... P>
struct TypePack {
  // 这种模板嵌套说明 T 可以是一个模板
  template <template <typename...> typename T>
  using apply = T<P...>;

  static constexpr size_t size = sizeof...(P);

  template <int Index>
  static constexpr size_t RealIndex = Index >= 0 ? Index : TypePack::size + Index;

  template <int N>
  using at = std::tuple_element_t<RealIndex<N>, typename TypePack::template apply<std::tuple>>;

  static constexpr auto applyFunc(auto lambda) { return lambda.template operator()<P...>(); }

  template <typename T>
  static consteval auto search() -> size_t {
    auto array = std::array{ std::same_as<T, P>... };
    return ranges::find(array, true) - array.begin();
  }
};

template <typename T, typename Seq>
struct RepeatS;
template <typename T, size_t N>
using Repeat = RepeatS<T, std::make_index_sequence<N>>::type;

template <typename T, size_t... Is>
struct RepeatS<T, std::index_sequence<Is...>> {
  template <size_t N>
  using element = T;
  using type = TypePack<element<Is>...>;
};

template <typename T>
struct ToTypePackS;
template <typename T>
using ToTypePack = ToTypePackS<T>::type;
template <template <typename...> typename T, typename... Args>
struct ToTypePackS<T<Args...>> {
  using type = TypePack<Args...>;
};

template <typename... TypePacks>
struct MergeS;
template <typename... TypePacks>
using Merge = ToTypePack<
  decltype(std::tuple_cat(std::declval<typename TypePacks::template apply<std::tuple>>()...))>;

template <typename TypePack, typename Seq, size_t I>
struct TakeS;
template <typename TypePack, int I>
using Take =
  TakeS<TypePack, std::make_index_sequence<TypePack::size>, TypePack::template RealIndex<I>>::type;
template <typename... Args, size_t... Is, size_t I>
struct TakeS<TypePack<Args...>, std::index_sequence<Is...>, I> {
  using type = Merge < std::conditional_t<Is<I, TypePack<Args>, TypePack<>>...>;
};

template <typename TypePack, typename Seq, size_t I>
struct DropS;
template <typename TypePack, int I>
using Drop =
  DropS<TypePack, std::make_index_sequence<TypePack::size>, TypePack::template RealIndex<I>>::type;
template <typename... Args, size_t... Is, size_t I>
struct DropS<TypePack<Args...>, std::index_sequence<Is...>, I> {
  using type = Merge<std::conditional_t<I <= Is, TypePack<Args>, TypePack<>>...>;
};

template <typename TypePackT, typename T, size_t I>
struct InsertS {
  using type = Merge<Take<TypePackT, I>, TypePack<T>, Drop<TypePackT, I>>;
};
template <typename TypePack, typename T, int I = TypePack::size>
using Insert = InsertS<TypePack, T, TypePack::template RealIndex<I>>::type;

template <typename TypePackT, size_t I>
struct RemoveS {
  using type = Merge<Take<TypePackT, I>, Drop<TypePackT, I + 1>>;
};
template <typename TypePack, int I = -1>
using Remove = RemoveS<TypePack, TypePack::template RealIndex<I>>::type;

template <typename TypePack, template <typename...> typename Mapper>
struct MapToS;

template <typename TypePack, template <typename...> typename Mapper>
using MapTo = MapToS<TypePack, Mapper>::type;

template <typename... TypeList, template <typename...> typename Mapper>
struct MapToS<TypePack<TypeList...>, Mapper> {
  using type = TypePack<typename Mapper<TypeList>::type...>;
};

template <typename TypePack, template <typename...> typename Target>
struct ApplyToS;

template <typename TypePack, template <typename...> typename Target>
using ApplyTo = ApplyToS<TypePack, Target>::type;

template <typename... TypeList, template <typename...> typename Target>
struct ApplyToS<TypePack<TypeList...>, Target> {
  using type = TypePack<Target<TypeList>...>;
};

template <typename TypePack, template <typename> typename Condition, bool inverse>
struct FilterS;
template <typename TypePack, template <typename> typename Condition, bool inverse = false>
using Filter = FilterS<TypePack, Condition, inverse>::type;
template <typename... Args, template <typename> typename Condition, bool inverse>
struct FilterS<TypePack<Args...>, Condition, inverse> {
  using type = Merge<std::conditional_t<
    inverse ? !Condition<Args>::value : Condition<Args>::value,
    TypePack<Args>,
    TypePack<>>...>;
};

template <typename TypePack, typename Seq, template <typename> typename Condition>
struct FilterIndicesS;
template <typename TypePack, template <typename> typename Condition>
constexpr auto FilterIndices =
  FilterIndicesS<TypePack, std::make_index_sequence<TypePack::size>, Condition>::value;
template <typename... Args, size_t... Is, template <typename> typename Condition>
struct FilterIndicesS<TypePack<Args...>, std::index_sequence<Is...>, Condition> {
  static constexpr auto all_indices = std::array{ (Condition<Args>::value ? int(Is) : -1)... };
  static consteval auto getIndicesNumber() -> size_t {
    auto target = std::array<size_t, sizeof...(Args)>{};
    return ranges::remove_copy(all_indices, target.begin(), -1).out - target.begin();
  }
  template <size_t N>
  static consteval auto getIndices() {
    auto indices = std::array<size_t, N>{};
    ranges::remove_copy(all_indices, indices.begin(), -1);
    return indices;
  }
  static constexpr auto value = getIndices<getIndicesNumber()>();
};

/**
 * @brief get type information of a function
 * is a TypePack contains Return Type and Parameter Types
 * can not use for a overload function!
 * the type is decay
 */
template <typename Callable>
struct FuncInfoT;
template <typename Func>
using FuncInfo = typename FuncInfoT<std::decay_t<Func>>::type;

// 用于成员函数类型 (需要考虑 const 和非 const)
template <typename C, typename R, typename... Args>
struct FuncInfoT<R (C::*)(Args...) const> {
  using type = TypePack<R, Args...>;
};
template <typename C, typename R, typename... Args>
struct FuncInfoT<R (C::*)(Args...)> {
  using type = TypePack<R, Args...>;
};
// 用于函数指针和函数
template <typename R, typename... Args>
struct FuncInfoT<R (*)(Args...)> {
  using type = TypePack<R, Args...>;
};
// 用于持有 operator() 的类
template <typename Callable>
struct FuncInfoT {
  using type = FuncInfoT<decltype(&Callable::operator())>::type;
};

/**
 * @brief get parameter types of a function
 * can not use for a overload function!
 */
template <typename Func>
using FuncArgs = Remove<FuncInfo<Func>, 0>;

/**
 * @brief get the parameter type of a function with index
 * can not use for a overload function!
 */
// template <uint32_t index, typename Func>
// using FuncArg = FuncInfo<Func>::template at<index + 1>;

/**
 * @brief get the parameter type count of a function
 * can not use for a overload function!
 */
template <typename Func>
constexpr int FuncArgCount = FuncInfo<Func>::size - 1;

/**
 * @brief get the return type of a function with index
 * can not use for a overload function!
 */
template <typename Func>
using FuncRet = FuncInfo<Func>::template at<0>;

} // namespace toy

namespace test_TypePack {
using namespace toy;

template <typename T>
struct Condition {
  static constexpr bool value = std::same_as<T, char>;
};
template <typename T>
struct Mapper {
  using type = std::vector<T>;
};

void test() {
  using type_pack_1 = TypePack<int, float, double, char>;
  // Repeat
  static_assert(std::same_as<TypePack<int, int, int>, Repeat<int, 3>>);
  // ToTypePack
  static_assert(std::same_as<TypePack<int, float>, ToTypePack<std::pair<int, float>>>);
  // Merge
  static_assert(std::same_as<
                type_pack_1,
                Merge<TypePack<int>, TypePack<float, double>, TypePack<char>>>);
  // At
  static_assert(std::same_as<char, type_pack_1::at<3>>);
  static_assert(std::same_as<char, type_pack_1::at<-1>>);
  static_assert(std::same_as<double, type_pack_1::at<-2>>);
  // Take, Drop
  static_assert(std::same_as<TypePack<int, float, double>, Take<type_pack_1, -1>>);
  static_assert(std::same_as<TypePack<float, double, char>, Drop<type_pack_1, 1>>);
  // Insert
  static_assert(std::same_as<TypePack<int, float, double>, Insert<TypePack<int, float>, double>>);
  static_assert(std::
                  same_as<TypePack<int, float, double>, Insert<TypePack<int, double>, float, -1>>);
  // Remove
  static_assert(std::same_as<TypePack<float, double, char>, Remove<type_pack_1, 0>>);
  static_assert(std::same_as<TypePack<int, float, double>, Remove<type_pack_1>>);
  // MapTo
  static_assert(std::same_as<
                TypePack<std::vector<int>, std::vector<float>>,
                MapTo<TypePack<int, float>, Mapper>>);
  // ApplyTo
  static_assert(std::same_as<
                TypePack<std::vector<int>, std::vector<float>>,
                ApplyTo<TypePack<int, float>, std::vector>>);
  // Filter
  static_assert(std::same_as<TypePack<char>, Filter<type_pack_1, Condition>>);
  static_assert(std::same_as<TypePack<int, float, double>, Filter<type_pack_1, Condition, true>>);
  static_assert(std::array<size_t, 1>{ 3 } == FilterIndices<type_pack_1, Condition>);
  constexpr auto abc = [](auto a) {};
  // search
  static_assert(type_pack_1::search<float>() == 1);
  static_assert(type_pack_1::applyFunc([]<typename... Args>() {
    return requires() { (abc(std::declval<Args>()), ...); };
  }));
  static_assert(!type_pack_1::applyFunc([]<typename... Args>() {
    return requires() { (def(std::declval<Args>()), ...); };
  }));
}

} // namespace test_TypePack

namespace test_FuncArgRet {
using namespace toy;
void foo(int, float) {}
// function foo can not overload
// void foo(int a);
void (*const bar)(int, float) = foo;
struct A {
  auto operator()(char, int, float) const -> std::string_view;

  auto foo(int, char, float) -> int;

  static auto bar(int, char, float, char[5]) -> float;
};
void test() {
  static_assert(std::same_as<TypePack<void, int, float>, FuncInfo<decltype(foo)>>);
  static_assert(std::same_as<TypePack<void, int, float>, FuncInfo<decltype(bar)>>);
  static_assert(std::same_as<TypePack<void, int, float>, FuncInfo<std::decay_t<decltype(foo)>>>);
  static_assert(std::same_as<TypePack<int, int, char, float>, FuncInfo<decltype(&A::foo)>>);
  static_assert(std::same_as<TypePack<std::string_view, char, int, float>, FuncInfo<A>>);
  // the type is decay
  static_assert(std::
                  same_as<TypePack<float, int, char, float, char*>, FuncInfo<decltype(&A::bar)>>);

  static_assert(2 == FuncArgCount<decltype(foo)>);
  static_assert(2 == FuncArgCount<std::decay_t<decltype(foo)>>);
  static_assert(3 == FuncArgCount<decltype(&A::foo)>);
  static_assert(3 == FuncArgCount<A>);
  static_assert(4 == FuncArgCount<decltype(&A::bar)>);

  static_assert(std::same_as<void, FuncRet<decltype(foo)>>);
  static_assert(std::same_as<void, FuncRet<std::decay_t<decltype(foo)>>>);
  static_assert(std::same_as<int, FuncRet<decltype(&A::foo)>>);
  static_assert(std::same_as<std::string_view, FuncRet<A>>);
  static_assert(std::same_as<float, FuncRet<decltype(&A::bar)>>);
}

} // namespace test_FuncArgRet
