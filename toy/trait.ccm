export module toy.trait;

import std;

export namespace toy {

template <size_t size, typename Func>
decltype(auto) constexpr applyIndexSequence(Func&& func) {
  return [&]<size_t... indices>(std::index_sequence<indices...> _) {
    return func.template operator()<indices...>();
  }(std::make_index_sequence<size>{});
}

template <size_t size, typename Func>
  requires(size == 0) || requires(Func&& func) { func.template operator()<0>(); }
void templateForEach(Func&& func) {
  if constexpr (size != 0) {
    applyIndexSequence<size>([&]<size_t... indices>() {
      (func.template operator()<indices>(), ...);
    });
  }
}

void test_templateForEachAndapplyIndexSequence() {
  templateForEach<10>([]<size_t indice>() {
    if constexpr (indice == 0) {
    }
  });
  auto test = [](int, int, int) { return 1; };
  toy::applyIndexSequence<3>([&]<size_t... index>() { test(index...); });
  // error
  // toy::applyIndexSequence<1>([&]<size_t... index>() { test(index...); });
}

template <typename T, typename Seq>
struct RepeatS;
template <typename T, size_t N>
using Repeat = RepeatS<T, std::make_index_sequence<N>>::type;

template <typename T>
struct ToTypePackS;
template <typename T>
using ToTypePack = ToTypePackS<T>::type;

template <typename... TypePacks>
struct MergeS;
template <typename... TypePacks>
using Merge = MergeS<TypePacks...>::type;

template <typename... P>
struct TypePack {
  // 这种模板嵌套说明 T 可以是一个模板
  template <template <typename...> typename T>
  using apply = T<P...>;

  static constexpr size_t size = sizeof...(P);

  template <int Index>
  static constexpr size_t realIndex = Index >= 0 ? Index : TypePack::size + Index;

  template <int N>
  using at = std::tuple_element_t<realIndex<N>, typename TypePack::template apply<std::tuple>>;

  static constexpr auto applyFunc(auto lambda) { return lambda.template operator()<P...>(); }

  template <typename T>
  static consteval auto search() -> size_t {
    auto array = std::array{ std::same_as<T, P>... };
    return ranges::find(array, true) - array.begin();
  }

  // take the types before I'th
  template <int I, size_t size_ = size>
  using take = decltype(applyIndexSequence<size_>(
    []<size_t... Is> -> Merge <
                          std::conditional_t<Is<realIndex<I>, TypePack<P>, TypePack<>>...> {
                            return {};
                          }
  ));

  // drop the types before I'th
  template <int I, size_t size_ = size>
  using drop = decltype(applyIndexSequence<size_>(
    []<size_t... Is> -> Merge <
                          std::conditional_t<Is<realIndex<I>, TypePack<>, TypePack<P>>...> {
                            return {};
                          }
  ));

  template <typename T, int I = size, typename TypePack_ = TypePack>
  using insert =
    Merge<typename TypePack_::template take<I>, TypePack<T>, typename TypePack_::template drop<I>>;

  template <int I = -1, typename TypePack_ = TypePack>
  using remove = Merge<
    typename TypePack_::template take<I>,
    typename TypePack_::template drop<I == -1 ? size : I + 1>>;

  template <template <typename...> typename Mapper>
  using mapTo = TypePack<typename Mapper<P>::type...>;

  template <auto lambda>
  using lambdaMapTo = TypePack<decltype(lambda.template operator()<P>())...>;

  template <template <typename...> typename Mapper>
  using applyTo = TypePack<Mapper<P>...>;

  template <auto Condition>
  using filter =
    Merge<std::conditional_t<Condition.template operator()<P>(), TypePack<P>, TypePack<>>...>;

  template <auto Condition>
  static consteval auto filterIndice() {
    return applyIndexSequence<size>([&]<size_t... Is>() {
      auto all_indices = std::array {(Condition.template operator()<P>() ? int(Is) : -1)... };
      auto indices = std::array<size_t, ((Condition.template operator()<P>() ? 1 : 0) + ...)> {};
      ranges::remove_copy(all_indices, indices.begin(), -1);
      return indices;
    });
  }
};

template <typename T, size_t... Is>
struct RepeatS<T, std::index_sequence<Is...>> {
  template <size_t N>
  using element = T;
  using type = TypePack<element<Is>...>;
};

template <template <typename...> typename T, typename... Args>
struct ToTypePackS<T<Args...>> {
  using type = TypePack<Args...>;
};

template <typename... TypePacks>
struct MergeS {
  using type = ToTypePack<
    decltype(std::tuple_cat(std::declval<typename TypePacks::template apply<std::tuple>>()...))>;
};

/**
 * @brief get type information of a function
 * is a TypePack contains Return Type and Parameter Types
 * can not use for a overload function!
 * the type is decay
 */
template <typename Callable>
struct FuncInfoT;
template <typename Func>
using FuncInfo = typename FuncInfoT<std::decay_t<Func>>::type;

// 用于成员函数类型 (需要考虑 const 和非 const)
template <typename C, typename R, typename... Args>
struct FuncInfoT<R (C::*)(Args...) const> {
  using type = TypePack<R, Args...>;
};
template <typename C, typename R, typename... Args>
struct FuncInfoT<R (C::*)(Args...)> {
  using type = TypePack<R, Args...>;
};
// 用于函数指针和函数
template <typename R, typename... Args>
struct FuncInfoT<R (*)(Args...)> {
  using type = TypePack<R, Args...>;
};
// 用于持有 operator() 的类
template <typename Callable>
struct FuncInfoT {
  using type = FuncInfoT<decltype(&Callable::operator())>::type;
};

/**
 * @brief get parameter types of a function
 * can not use for a overload function!
 */
template <typename Func>
using FuncArgs = FuncInfo<Func>::template remove<0>;

/**
 * @brief get the parameter type of a function with index
 * can not use for a overload function!
 */
// template <uint32 index, typename Func>
// using FuncArg = FuncInfo<Func>::template at<index + 1>;

/**
 * @brief get the parameter type count of a function
 * can not use for a overload function!
 */
template <typename Func>
constexpr int FuncArgCount = FuncInfo<Func>::size - 1;

/**
 * @brief get the return type of a function with index
 * can not use for a overload function!
 */
template <typename Func>
using FuncRet = FuncInfo<Func>::template at<0>;

} // namespace toy

namespace test_TypePack {
using namespace toy;

template <typename T>
struct Condition {
  static constexpr bool value = std::same_as<T, char>;
};
template <typename T>
struct Mapper {
  using type = std::vector<T>;
};

void test() {
  using type_pack_1 = TypePack<int, float, double, char>;
  // Repeat
  static_assert(std::same_as<TypePack<int, int, int>, Repeat<int, 3>>);
  // ToTypePack
  static_assert(std::same_as<TypePack<int, float>, ToTypePack<std::pair<int, float>>>);
  // Merge
  static_assert(std::same_as<
                type_pack_1,
                Merge<TypePack<int>, TypePack<float, double>, TypePack<char>>>);
  // At
  static_assert(std::same_as<char, type_pack_1::at<3>>);
  static_assert(std::same_as<char, type_pack_1::at<-1>>);
  static_assert(std::same_as<double, type_pack_1::at<-2>>);
  // Take, Drop
  static_assert(std::same_as<TypePack<int, float, double>, type_pack_1::take<-1>>);
  static_assert(std::same_as<TypePack<float, double, char>, type_pack_1::drop<1>>);
  // Insert
  static_assert(std::same_as<TypePack<int, float, double>, TypePack<int, float>::insert<double>>);
  static_assert(std::
                  same_as<TypePack<int, float, double>, TypePack<int, double>::insert<float, -1>>);
  // Remove
  static_assert(std::same_as<TypePack<float, double, char>, type_pack_1::remove<0>>);
  static_assert(std::same_as<TypePack<int, float, double>, type_pack_1::remove<>>);
  // MapTo
  static_assert(std::same_as<
                TypePack<std::vector<int>, std::vector<float>>,
                TypePack<int, float>::mapTo<Mapper>>);
  static_assert(std::same_as<
                TypePack<std::vector<int>, std::vector<float>>,
                TypePack<int, float>::lambdaMapTo<[]<typename T>() -> std::vector<T> {}>>);
  // ApplyTo
  static_assert(std::same_as<
                TypePack<std::vector<int>, std::vector<float>>,
                TypePack<int, float>::applyTo<std::vector>>);
  // Filter
  static_assert(std::same_as<TypePack<char>, type_pack_1::filter<[]<typename T> {
                               return std::same_as<T, char>;
                             }>>);
  static_assert(std::same_as<TypePack<int, float, double>, type_pack_1::filter<[]<typename T> {
                               return !std::same_as<T, char>;
                             }>>);
  static_assert(
    std::array<size_t, 1>{ 3 } ==
    type_pack_1::filterIndice<[]<typename T> { return std::same_as<T, char>; }>()
  );
  constexpr auto abc = [](auto a) {};
  // search
  static_assert(type_pack_1::search<float>() == 1);
  static_assert(type_pack_1::applyFunc([]<typename... Args>() {
    return requires() { (abc(std::declval<Args>()), ...); };
  }));
  static_assert(!type_pack_1::applyFunc([]<typename... Args>() {
    return requires() { (def(std::declval<Args>()), ...); };
  }));
}

} // namespace test_TypePack

namespace test_FuncArgRet {
using namespace toy;
void foo(int, float) {}
// function foo can not overload
// void foo(int a);
void (*const bar)(int, float) = foo;
struct A {
  auto operator()(char, int, float) const -> std::string_view;

  auto foo(int, char, float) -> int;

  static auto bar(int, char, float, char[5]) -> float;
};
void test() {
  static_assert(std::same_as<TypePack<void, int, float>, FuncInfo<decltype(foo)>>);
  static_assert(std::same_as<TypePack<void, int, float>, FuncInfo<decltype(bar)>>);
  static_assert(std::same_as<TypePack<void, int, float>, FuncInfo<std::decay_t<decltype(foo)>>>);
  static_assert(std::same_as<TypePack<int, int, char, float>, FuncInfo<decltype(&A::foo)>>);
  static_assert(std::same_as<TypePack<std::string_view, char, int, float>, FuncInfo<A>>);
  // the type is decay
  static_assert(std::
                  same_as<TypePack<float, int, char, float, char*>, FuncInfo<decltype(&A::bar)>>);

  static_assert(2 == FuncArgCount<decltype(foo)>);
  static_assert(2 == FuncArgCount<std::decay_t<decltype(foo)>>);
  static_assert(3 == FuncArgCount<decltype(&A::foo)>);
  static_assert(3 == FuncArgCount<A>);
  static_assert(4 == FuncArgCount<decltype(&A::bar)>);

  static_assert(std::same_as<void, FuncRet<decltype(foo)>>);
  static_assert(std::same_as<void, FuncRet<std::decay_t<decltype(foo)>>>);
  static_assert(std::same_as<int, FuncRet<decltype(&A::foo)>>);
  static_assert(std::same_as<std::string_view, FuncRet<A>>);
  static_assert(std::same_as<float, FuncRet<decltype(&A::bar)>>);
}

} // namespace test_FuncArgRet
