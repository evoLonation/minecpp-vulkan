export module toy.ranges;

import toy.log;
import std;

export namespace toy {

template <typename T>
concept SelfIncrement = requires(T iter) {
  { iter.selfIncrement() } -> std::same_as<void>;
};
template <typename T>
concept SelfDecrement = requires(T iter) {
  { iter.selfDecrement() } -> std::same_as<void>;
};
template <typename Derived>
class SelfOperatorHelper {
public:
  auto self() -> Derived& { return static_cast<Derived&>(*this); }

  template <SelfIncrement Derived_ = Derived>
  auto operator++() -> Derived& {
    self().selfIncrement();
    return self();
  }
  template <SelfIncrement Derived_ = Derived>
  auto operator++(int) -> Derived {
    auto old = self();
    self().selfIncrement();
    return old;
  }

  template <SelfDecrement Derived_ = Derived>
  auto operator--() -> Derived& {
    self().selfDecrement();
    return self();
  }
  template <SelfDecrement Derived_ = Derived>
  auto operator--(int) -> Derived {
    auto old = self();
    self().selfDecrement();
    return old;
  }
};
template <typename T>
concept RandomAccess = requires(T iter) {
  requires std::random_access_iterator<
    std::remove_reference_t<decltype(iter.*T::randomAccessMember())>>;
};
template <typename Derived, typename DifferenceType = std::ptrdiff_t>
class RandomAccessIteratorHelper : public SelfOperatorHelper<Derived> {
private:
  using difference_type = DifferenceType;

  RandomAccess auto& self() { return static_cast<Derived&>(*this); }
  RandomAccess auto  self() const { return static_cast<const Derived&>(*this); }

  auto  base() const { return self().*Derived::randomAccessMember(); }
  auto& base() { return self().*Derived::randomAccessMember(); }

private:
  friend SelfOperatorHelper<Derived>;
  void selfIncrement() { ++base(); }
  void selfDecrement() { --base(); }

public:
  auto operator+=(difference_type n) -> Derived& {
    base() += n;
    return self();
  }
  friend auto operator+(Derived a, difference_type n) -> Derived {
    return a.RandomAccessIteratorHelper::base() + n;
  }
  friend auto operator+(difference_type n, Derived a) -> Derived {
    return a.RandomAccessIteratorHelper::base() + n;
  }
  auto operator-=(difference_type n) -> Derived& {
    base() -= n;
    return self();
  }
  friend auto operator-(Derived a, difference_type n) -> Derived {
    return a.RandomAccessIteratorHelper::base() - n;
  }

  decltype(auto) operator[](difference_type n) const { return *(self() + n); }

  friend auto operator-(Derived a, Derived b) -> difference_type {
    return a.RandomAccessIteratorHelper::base() - b.RandomAccessIteratorHelper::base();
  }

  // 飞船运算符 = default， 编译器会自动生成所有比较运算符
  // 如果飞船运算符是用户自定义的，则编译器不会自动生成相等比较运算符
  // 考虑到容器类进行相等比较时，如果size不等则可以直接false，而进行三相比较则永远是O(n)的
  friend auto operator<=>(Derived a, Derived b) -> std::strong_ordering {
    return a.RandomAccessIteratorHelper::base() <=> b.RandomAccessIteratorHelper::base();
  }
  friend auto operator==(Derived a, Derived b) -> bool {
    return a.RandomAccessIteratorHelper::base() == b.RandomAccessIteratorHelper::base();
  }
};

template <typename Adaptor, typename... Args>
struct AdaptorClosure {
  Adaptor             adaptor_;
  std::tuple<Args...> args_;
  decltype(auto)      operator()(auto&& range) {
    return std::apply(
      [this, &range](auto&&... args) -> decltype(auto) {
        return adaptor_(
          std::forward<decltype(range)>(range), std::forward<decltype(args)>(args)...
        );
      },
      args_
    );
  }

  AdaptorClosure(Adaptor adaptor, auto&&... args)
    : adaptor_(adaptor), args_(std::forward<decltype(args)>(args)...) {}
};

// 构造函数的参数用万能引用，并推导得到Args为去掉引用的类型
template <typename Adaptor, typename... Args>
AdaptorClosure(Adaptor adaptor, Args&&... args)
  -> AdaptorClosure<Adaptor, std::remove_reference_t<Args>...>;

template <typename... Args>
auto operator|(auto&& range, AdaptorClosure<Args...> closure) {
  return closure(std::forward<decltype(range)>(range));
}

// example
struct MyTake {
  auto operator()(auto&& range, int n) {
    return views::take(views::all(std::forward<decltype(range)>(range)), n);
  }
  auto operator()(int n) { return AdaptorClosure{ *this, n }; }
};

void test_AdaptorClosure() {
  std::array arr = { 1, 2, 3 };
  auto       view = arr | MyTake{}(2);
  auto       view2 = MyTake{}(view, 2);
}

// CRTP 模式，辅助无参数adaptor
template <typename Derived>
struct AdaptorClosureHelper {};

template <typename Adaptor>
  requires std::is_base_of_v<AdaptorClosureHelper<Adaptor>, Adaptor>
auto operator|(auto&& range, Adaptor closure) {
  return closure(std::forward<decltype(range)>(range));
}

struct EnumerateAdaptor : AdaptorClosureHelper<EnumerateAdaptor> {
  template <ranges::sized_range Range>
  auto operator()(Range&& range) {
    return views::zip(views::iota(0u, range.size()), range);
  }
};

template <
  ranges::forward_range                                                              View,
  std::indirect_binary_predicate<ranges::iterator_t<View>, ranges::iterator_t<View>> Pred>
  requires ranges::view<View> && std::is_object_v<Pred>
class ChunkByView : public ranges::view_interface<ChunkByView<View, Pred>> {
private:
  using Element = ranges::range_value_t<View>;
  using BaseIterator = ranges::iterator_t<View>;
  using SubRange = ranges::subrange<BaseIterator>;

  View base_;
  Pred pred_;

public:
  class Sentinel {};
  class Iterator : public SelfOperatorHelper<Iterator> {
    // 指向一个子范围（惰性的），当解引用时需要得到一个子范围（除非是end），自增操作需要寻找下一个子范围
  private:
    View*        base_;
    BaseIterator left_;
    BaseIterator right_;
    Pred*        pred_;

  public:
    Iterator(View& base, Pred& pred)
      : base_(&base), left_(base.begin()), right_(left_), pred_(&pred) {
      selfIncrement();
    }
    Iterator() = default;

    using difference_type = std::ptrdiff_t;
    using value_type = SubRange;
    using reference_type = value_type;

  private:
    friend SelfOperatorHelper<Iterator>;
    auto selfIncrement() {
      left_ = right_;
      right_ =
        ranges::adjacent_find(ranges::subrange(left_, base_->end()), [this](auto&& a, auto&& b) {
          return !std::invoke(*pred_, std::forward<decltype(a)>(a), std::forward<decltype(b)>(b));
        });
      if (right_ != base_->end()) {
        ++right_;
      }
    }
    auto selfDecrement() {
      right_ = left_;
      left_ =
        ranges::adjacent_find(
          ranges::subrange(base_->begin(), left_) | views::reverse,
          [this](auto&& a, auto&& b) {
            return std::invoke(*pred_, std::forward<decltype(a)>(a), std::forward<decltype(b)>(b));
          }
        ).base();
      if (left_ != base_->begin()) {
        --left_;
      }
    }

  public:
    friend auto operator==(const Iterator& a, const Iterator& b) -> bool {
      return a.left_ == b.left_;
    }
    friend auto operator==(const Iterator& a, Sentinel) -> bool {
      return a.left_ == a.base_->end();
    }

    auto operator*() const -> reference_type { return value_type{ left_, right_ }; }
  };
  auto begin() { return Iterator{ base_, pred_ }; }
  auto end() { return Sentinel{}; }

  ChunkByView(View view, Pred pred) : base_(std::move(view)), pred_(std::move(pred)) {}
};

struct ChunkByAdaptor {
  auto operator()(auto&& range, auto pred) const {
    return ChunkByView(views::all(std::forward<decltype(range)>(range)), pred);
  }
  auto operator()(auto pred) const { return AdaptorClosure{ *this, pred }; }
};

inline constexpr EnumerateAdaptor enumerate = EnumerateAdaptor{};
inline constexpr ChunkByAdaptor   chunkBy = ChunkByAdaptor{};

// 给一个range，返回一个排序后的新range，该range为了省空间只会存储排序后的迭代器
template <typename Range, class Comp = ranges::less, class Proj = std::identity>
  requires ranges::random_access_range<Range> && ranges::viewable_range<Range>
class SortedView : public ranges::view_interface<SortedView<Range, Comp, Proj>> {
private:
  using BaseView = views::all_t<Range>;
  using BaseIterator = ranges::iterator_t<Range>;
  using IndexRange = std::vector<BaseIterator>;
  using IndexIterator = ranges::iterator_t<IndexRange>;

  BaseView   view_;
  IndexRange index_;

public:
  SortedView(const SortedView&) = delete;
  SortedView(SortedView&&) = default;
  SortedView& operator=(const SortedView&) = delete;
  SortedView& operator=(SortedView&&) = default;

  class Iterator : public RandomAccessIteratorHelper<Iterator> {
  private:
    IndexIterator index_iter;

  public:
    using reference_type = std::iter_reference_t<BaseIterator>;
    using value_type = std::iter_value_t<BaseIterator>;

    Iterator(IndexIterator index_it) : index_iter(index_it) {}
    Iterator() = default;

  private:
    friend RandomAccessIteratorHelper<Iterator>;
    constexpr static IndexIterator Iterator::*randomAccessMember() { return &Iterator::index_iter; }

  public:
    auto operator*() const -> reference_type { return **index_iter; }
  };
  auto begin() { return Iterator{ index_.begin() }; }
  auto end() { return Iterator{ index_.end() }; }

  SortedView(Range&& range, Comp comp = {}, Proj proj = {})
    : view_(views::all(range)), index_(view_.size()) {
    int j = 0;
    for (auto i = view_.begin(); i != view_.end(); i++, j++) {
      index_[j] = std::move(i);
    }
    ranges::sort(index_, std::move(comp), [this, proj](auto iter) { return proj(*iter); });
  }
};
template <typename Range, class Comp = ranges::less, class Proj = std::identity>
SortedView(Range&& range, Comp comp = {}, Proj proj = {}) -> SortedView<Range, Comp, Proj>;

template <typename T>
class CommonView {
private:
  struct ErasedContent;

  class IteratorInterface {
  public:
    virtual auto operator*() const -> T = 0;
    virtual auto operator++() -> IteratorInterface& = 0;
    virtual auto operator==(IteratorInterface& a) -> bool = 0;
    virtual auto getErasedContent() -> ErasedContent = 0;
    virtual ~IteratorInterface() = default;
  };
  class LocalContent {
  private:
    auto moveResource(LocalContent&& obj) {
      content = obj.content;
      interface = reinterpret_cast<IteratorInterface*>(
        (char*)obj.interface + (content.data() - obj.content.data())
      );
    }

  public:
    static constexpr auto _content_size = sizeof(int) * 10;

    std::array<char, _content_size> content;
    IteratorInterface*              interface;

    LocalContent() : interface(nullptr) {}
    template <std::derived_from<IteratorInterface> ImplementT>
    LocalContent(ImplementT implement) {
      auto* p = new (content.data()) ImplementT{ std::move(implement) };
      interface = p;
    }
    LocalContent(const LocalContent&) = delete;
    LocalContent(LocalContent&& obj) { moveResource(std::move(obj)); }
    auto operator=(const LocalContent&) -> LocalContent& = delete;
    auto operator=(LocalContent&& obj) -> LocalContent& {
      if (interface != nullptr) {
        interface->~IteratorInterface();
      }
      moveResource(std::move(obj));
      return *this;
    }
  };
  using DynamicContent = std::unique_ptr<IteratorInterface>;
  // variant的默认构造会填充第一个类型的默认值
  class ErasedContent : private std::variant<LocalContent, DynamicContent> {
  private:
    using Base = std::variant<LocalContent, DynamicContent>;
    template <std::derived_from<IteratorInterface> ImplementT>
    static auto getVariant(ImplementT implement) -> std::variant<LocalContent, DynamicContent> {
      if constexpr (sizeof(implement) > LocalContent::_content_size) {
        return std::make_unique<ImplementT>(std::move(implement));
      } else {
        return LocalContent{ std::move(implement) };
      }
    }

  public:
    ErasedContent() = default;
    template <std::derived_from<IteratorInterface> ImplementT>
    ErasedContent(ImplementT implement) {
      if constexpr (sizeof(implement) > LocalContent::_content_size) {
        Base::template emplace<1>(std::make_unique<ImplementT>(std::move(implement)));
      } else {
        Base::operator=(LocalContent{ std::move(implement) });
      }
    }
    ErasedContent(const ErasedContent& content)
      : ErasedContent{ std::move(content.get().getErasedContent()) } {}
    ErasedContent(ErasedContent&&) = default;
    auto operator=(const ErasedContent& content) -> ErasedContent& {
      *this = std::move(content.get().getErasedContent());
      return *this;
    }
    auto operator=(ErasedContent&&) -> ErasedContent& = default;

  protected:
    auto has_value() const -> bool {
      return !(Base::index() == 0 && std::get<0>(*this).interface == nullptr);
    }
    auto get() const -> IteratorInterface& {
      if (Base::index() == 0) {
        return *std::get<0>(*this).interface;
      } else {
        return *std::get<1>(*this).get();
      }
    }
  };

public:
  class Iterator : public ErasedContent {
  public:
    using difference_type = std::ptrdiff_t;
    using value_type = T;

    Iterator() = default;
    Iterator(ErasedContent content) : ErasedContent{ std::move(content) } {}
    auto operator*() const -> value_type { return *this->get(); }
    auto operator++() -> Iterator& {
      ++this->get();
      return *this;
    }
    auto operator++(int) -> Iterator {
      ++this->get();
      return std::move(this->get().getErasedContent());
    }
    friend auto operator==(const Iterator& a, const Iterator& b) -> bool {
      if (!a.has_value() || !b.has_value()) {
        return false;
      }
      return a.get() == b.get();
    }
    class Sentinel : public ErasedContent {
    public:
      Sentinel() = default;
      Sentinel(ErasedContent content) : ErasedContent{ std::move(content) } {}
      friend auto operator==(const Iterator& a, const Sentinel& b) -> bool {
        if (!a.has_value() || !b.has_value()) {
          return false;
        }
        return a.get() == b.get();
      }
      friend auto operator==(const Sentinel& a, const Iterator& b) -> bool {
        if (!a.has_value() || !b.has_value()) {
          return false;
        }
        return a.get() == b.get();
      }
    };
  };
  using Sentinel = Iterator::Sentinel;

private:
  template <std::forward_iterator IteratorT, typename SentinelT>
    requires std::sentinel_for<SentinelT, IteratorT>
  class IteratorWrapper : public IteratorInterface {
  private:
    IteratorT _iter;

  public:
    IteratorWrapper(IteratorT iter) { _iter = std::move(iter); }

    virtual auto operator*() const -> T override { return *_iter; }
    virtual auto operator++() -> IteratorInterface& override {
      ++_iter;
      return *this;
    }
    virtual auto getErasedContent() -> ErasedContent override { return ErasedContent{ *this }; }

    class SentinelWrapper : public IteratorInterface {
      friend class IteratorWrapper;

    private:
      SentinelT _sentinel;

    public:
      SentinelWrapper(SentinelT sentinel) { _sentinel = std::move(sentinel); }
      virtual auto operator*() const -> T override { std::unreachable(); }
      virtual auto operator++() -> IteratorInterface& override { std::unreachable(); }
      virtual auto operator==(IteratorInterface& a) -> bool override {
        if (auto* sub_iter = dynamic_cast<IteratorWrapper*>(&a); sub_iter != nullptr) {
          return _sentinel == sub_iter->_iter;
        } else {
          toy::throwf("The iterator interface's implement is not by myself");
          std::unreachable();
        }
      }
      virtual auto getErasedContent() -> ErasedContent override { return ErasedContent{ *this }; }
    };
    virtual auto operator==(IteratorInterface& a) -> bool override {
      if (auto* sub_iter = dynamic_cast<IteratorWrapper*>(&a); sub_iter != nullptr) {
        return _iter == sub_iter->_iter;
      } else if (auto* sub_iter = dynamic_cast<SentinelWrapper*>(&a); sub_iter != nullptr) {
        return _iter == sub_iter->_sentinel;
      } else {
        toy::throwf("The iterator interface's implement is not by myself");
        std::unreachable();
      }
    }
  };

public:
  Iterator _begin;
  Sentinel _end;

  template <typename RangeT>
    requires ranges::forward_range<RangeT> && std::same_as<ranges::range_value_t<RangeT>, T>
  CommonView(const RangeT& range) {
    // const_iterator_t and const_sentinel_t
    using OriginIterator = decltype(ranges::cbegin(std::declval<RangeT&>()));
    using OriginSentinel = decltype(ranges::cend(std::declval<RangeT&>()));
    using IteratorWrapper = IteratorWrapper<OriginIterator, OriginSentinel>;
    using SentinelWrapper = IteratorWrapper::SentinelWrapper;
    _begin = { IteratorWrapper{ range.begin() } };
    _end = { SentinelWrapper{ range.end() } };
  }

  auto begin() const -> Iterator { return _begin; }
  auto end() const -> Sentinel { return _end; }
  CommonView(const CommonView&) = default;
  CommonView(CommonView&&) = default;
  auto operator=(const CommonView&) -> CommonView& = default;
  auto operator=(CommonView&&) -> CommonView& = default;
};

void test_CommonView() {
  auto transform_view = std::array{ 1, 2, 3 } | views::transform([](auto a) { return a + 1; });
  static_assert(ranges::forward_range<CommonView<int>>, "");
  auto view_a = CommonView<int>{ transform_view };
  toy::debug(view_a);
  auto view_b = CommonView<int>{ views::repeat(10) } | views::take(10);
  toy::debug(view_b);
}

void test_EnumerateAdaptor() {
  std::array     arr{ "abc", "eddd" };
  auto           brr = arr | EnumerateAdaptor{};
  decltype(auto) c = *brr.begin();
  int            j = 0;
  for (auto [i, e] : arr | EnumerateAdaptor{}) {
    j++;
  }
  checkThrowf(j == 2, "");
}

void test_SortedRange() {
  static_assert(ranges::view<SortedView<std::vector<int>>>);
  static_assert(ranges::random_access_range<SortedView<std::vector<int>>>);
  static_assert(std::random_access_iterator<SortedView<std::vector<int>>::Iterator>);
  static_assert(!std::copyable<SortedView<std::vector<int>>>);
  auto view = views::iota(0, 10);
  auto view2 = view | views::reverse;
  auto view3 =
    SortedView{ view, [](auto a, auto b) { return a > b; }, [](auto a) { return a + 10; } };
  auto view4 = SortedView{ view, {}, [](auto a) { return 10 - a; } };
  debug(view2);
  checkThrowf(
    ranges::all_of(views::zip(view2, std::move(view3)), [](auto a) { return a.first == a.second; }),
    "test_SortedRange"
  );
  checkThrowf(
    ranges::all_of(views::zip(view2, std::move(view4)), [](auto a) { return a.first == a.second; }),
    "test_SortedRange"
  );
}

void test_ChunkBy() {
  static_assert(ranges::forward_range<
                ChunkByView<views::all_t<std::vector<int>>, std::ranges::not_equal_to>>);
  static_assert(ranges::bidirectional_range<
                ChunkByView<views::all_t<std::vector<int>>, std::ranges::not_equal_to>>);
  // todo
  // static_assert(ranges::common_range<ChunkByView<views::all_t<std::vector<int>>,
  // std::ranges::not_equal_to>>);
  std::array arr{ 1, 2, 3, 2, 3, 1, 5, 10, 9, 8 };
  auto       view = toy::chunkBy(arr, std::less{});
  auto       i = view.begin();
  for (auto _ : views::iota(0, 5)) {
    debug(*i);
    i++;
  }
  checkThrowf(i == view.end(), "i == view.end()");
  i--;
  for (auto _ : views::iota(0, 4)) {
    debug(*i);
    i--;
  }
  debug(*i);
  checkThrowf(i == view.begin(), "i == view.begin()");
}

struct FindIf {
  template <
    ranges::input_range Rp,
    class Proj = std::identity,
    std::indirect_unary_predicate<std::projected<ranges::iterator_t<Rp>, Proj>> Pred>
  auto operator()(Rp&& range, Pred pred, Proj proj = {}) const
    -> std::optional<ranges::range_value_t<Rp>> {
    auto iter = ranges::find_if(std::forward<Rp>(range), std::move(pred), std::move(proj));
    if (iter == ranges::end(range)) {
      return std::nullopt;
    } else {
      return *iter;
    }
  }
};

inline constexpr auto findIf = FindIf{};

} // namespace toy