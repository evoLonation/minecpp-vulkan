module;
#include "enum.h"
export module toy.enums;

import std;

import toy.log;

export namespace toy {

struct EnumBase {
  constexpr EnumBase() = default;
};

} // namespace toy

export template <std::derived_from<toy::EnumBase> T>
class std::formatter<T> : public std::formatter<std::string> {
public:
  template <typename FormatContext, typename... Args>
  auto format(const T& e, FormatContext& ctx) const {
    return std::formatter<std::string>::format(formatString(e), ctx);
  }

private:
  auto formatString(const T& e) const -> std::string { return e.str(); }
};

export namespace toy {

// for macro generate to enum
template <typename EnumT>
constexpr auto enum2String(EnumT t) -> const char* {
  return &EnumT::pair.first[EnumT::pair.second[t._value]];
}
template <typename EnumT>
constexpr auto enumCount() -> std::size_t {
  return EnumT::count;
}

template <int... Values, std::size_t N>
consteval auto __splitString(const char (&buf)[N])
  -> std::pair<std::array<char, N>, std::array<std::size_t, sizeof...(Values)>> {
  auto writable = std::array<char, N>{};
  auto indices = std::array<std::size_t, sizeof...(Values)>{};
  std::copy(buf, buf + N, writable.begin());
  auto i_indices = 0;
  indices[i_indices] = 0;
  i_indices++;
  for (auto iter = writable.begin(); iter != writable.end(); iter++) {
    auto& c = *iter;
    if (c == ',') {
      c = '\0';
      indices[i_indices] = iter - writable.begin() + 2;
      i_indices++;
    }
  }
  return { writable, indices };
}

template <typename EnumT, EnumT max_enum_value = EnumT::MAX_ENUM_VALUE>
  requires((size_t)max_enum_value < 0xff)
struct EnumSet {
  std::bitset<(size_t)max_enum_value> _bitset;
  EnumSet(std::initializer_list<EnumT> values) {
    for (auto value : values) {
      _bitset.set((size_t)value);
    }
  }
  EnumSet(EnumT value) { _bitset.set((size_t)value); }
  EnumSet() = default;
  friend auto operator|(EnumSet set, EnumT key) -> EnumSet {
    set._bitset.set((size_t)key);
    return set;
  }
  friend auto operator|(EnumSet a, EnumSet b) -> EnumSet { return a._bitset | b._bitset; }
  class Iterator {
  private:
    size_t         _index;
    const EnumSet* _set;

  public:
    Iterator() = default;
    Iterator(const EnumSet& set, size_t index) : _index(index), _set(&set) {
      while (_index < _set->_bitset.size() && !_set->_bitset[_index]) {
        _index++;
      }
    }
    using difference_type = std::ptrdiff_t;
    using value_type = EnumT;
    auto operator*() const -> EnumT { return (EnumT)_index; }
    auto operator++() -> Iterator& {
      _index++;
      while (_index < _set->_bitset.size() && !_set->_bitset[_index]) {
        _index++;
      }
      return *this;
    }
    auto operator++(int) -> Iterator {
      auto iter = *this;
      ++*this;
      return iter;
    }
    friend auto operator==(const Iterator& a, const Iterator& b) -> bool = default;
  };

  auto begin() const { return Iterator(*this, 0); }
  auto end() const { return Iterator(*this, _bitset.size()); }
};

namespace test_Enum {

TOY_ENUM(Giao, YUANSHEN, QIDONG, YIGEIWOLI);

void test() {
  static_assert(Giao::count == 3);

  Giao       a = Giao::YIGEIWOLI;
  Giao::Enum b = a;
  int        c = a;
  a = b;
  a = c;
  a = Giao::YUANSHEN;
  toy::throwf(std::string("YUANSHEN") == a.str(), "error test enum");
  auto format = std::format("{}", a);
}

} // namespace test_Enum

namespace test_EnumSet {

enum class A { A, B, C, MAX_ENUM_VALUE };

void test() {
  static_assert(ranges::input_range<EnumSet<A>>);
  auto set = EnumSet<A>{};
  for (A a : set) {
    toy::throwf(a != A::B && a != A::MAX_ENUM_VALUE, "enumset test wrong");
  }
  set = EnumSet<A>{ A::A, A::C };
}

} // namespace test_EnumSet

} // namespace toy
