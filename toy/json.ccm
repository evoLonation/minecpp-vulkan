module;
#include "enum.h"
export module toy.json;

import std;

import toy.log;
import toy.trait;
import toy.ranges;
import toy.enums;

using namespace toy;

export namespace json {

class Json;

class Null {
  friend auto operator==(Null a, Null b) -> bool { return true; }
};
constexpr auto null = Null{};
using Bool = bool;
using Number = double;
using String = std::string;
using Object = std::map<String, Json>;
using List = std::vector<Json>;

TOY_ENUM(Type, NULL, BOOL, NUMBER, STRING, OBJECT, LIST);

class Json {
public:
private:
  using Types = TypePack<Null, Bool, Number, String, Object, List>;
  Types::apply<std::variant> _value;

public:
  Json() : _value(Object{}) {}
  template <typename T>
    requires std::same_as<std::decay_t<T>, Null> || std::same_as<std::decay_t<T>, Bool> ||
             std::same_as<std::decay_t<T>, String>
  Json(T&& value) : _value(std::forward<decltype(value)>(value)) {}
  template <typename T>
    requires(
      std::convertible_to<std::decay_t<T>, Number> &&
      !(std::same_as<std::decay_t<T>, Null> || std::same_as<std::decay_t<T>, Bool> ||
        std::same_as<std::decay_t<T>, String>)
    )
  Json(T value) : _value(static_cast<Number>(value)) {}
  Json(const char* content) : _value(std::string(content)) {}
  Json(Object object) : _value(std::move(object)) {}
  Json(List list) : _value(std::move(list)) {}
  Json(std::initializer_list<std::pair<std::string, Json>> map) {
    auto object = Object{};
    for (auto [key, value] : map) {
      object.emplace(std::move(key), std::move(value));
    }
    _value = std::move(object);
  }
  static auto array(std::initializer_list<Json> elements) -> Json {
    auto json = Json{};
    json._value = List{ std::move(elements) };
    return json;
  }

  auto type() const -> Type { return _value.index(); }
  template <typename T>
  auto is() const -> bool {
    return std::holds_alternative<T>(_value);
  }
  template <typename T>
  auto to() const -> const T& {
    return std::get<T>(_value);
  }
  template <typename T>
  auto to() -> T& {
    return std::get<T>(_value);
  }
  auto toInteger() -> int64_t {
    auto value = to<Number>();
    toy::throwf(value == std::ceil(value), "the number can not convert to integer");
    return static_cast<int64_t>(value);
  }

public:
  template <Type::Enum T>
  decltype(auto) to() const {
    return std::get<T>(_value);
  }
  template <Type::Enum T>
  decltype(auto) to() {
    return std::get<T>(_value);
  }
  auto operator[](const std::string& key) const -> json::Json { return to<Object>().at(key); }
  auto operator[](const std::string& key) -> json::Json& { return to<Object>()[key]; }
  auto operator[](size_t index) const -> json::Json { return to<List>().at(index); }
  auto operator[](size_t index) -> json::Json& { return to<List>()[index]; }

  auto dump() const -> std::string {
    if (is<Null>()) {
      return "null";
    } else if (is<Bool>()) {
      return std::format("{}", to<Bool>());
    } else if (is<Number>()) {
      return std::format("{}", to<Number>());
    } else if (is<String>()) {
      auto str = to<String>();
      auto escaped = std::string{};
      escaped.push_back('"');
      for (auto c : str) {
        if (c == '"' || c == '\\' || c == '/') {
          escaped.push_back('\\');
          escaped.push_back(c);
        } else if (c == '\b') {
          escaped += "\\b";
        } else if (c == '\f') {
          escaped += "\\f";
        } else if (c == '\n') {
          escaped += "\\n";
        } else if (c == '\r') {
          escaped += "\\r";
        } else if (c == '\t') {
          escaped += "\\t";
        } else {
          escaped.push_back(c);
        }
      }
      escaped.push_back('"');
      return escaped;
    } else if (is<Object>()) {
      auto ss = std::stringstream{};
      ss << '{';
      auto& object = to<Object>();
      for (auto [index, pair] : object | enumerate) {
        auto& [key, value] = pair;
        ss << '"' << key << '"' << " : " << value.dump() << (index == object.size() - 1 ? "" : ",")
           << "\n";
      }
      ss << "}";
      return ss.str();
    } else if (is<List>()) {
      auto ss = std::stringstream{};
      ss << '[';
      auto& list = to<List>();
      for (auto [index, value] : list | enumerate) {
        ss << value.dump() << (index == list.size() - 1 ? "" : ",");
      }
      ss << "]";
      return ss.str();
    } else {
      toy::throwf("");
    }
  }
  auto dump(size_t indent) const -> std::string { toy::throwf("unimplemented"); }

  static auto parse(const std::string& str) -> Json;
  static auto parse(std::ifstream fs) -> Json {
    std::string str;
    std::copy(
      std::istreambuf_iterator<char>{ fs },
      std::istreambuf_iterator<char>{},
      std::back_inserter(str)
    );
    return parse(str);
  }

  friend auto operator==(const Json& a, const Json& b) -> bool {
    if (a.type() != b.type()) {
      return false;
    }
    auto type = a.type();
    switch (type.value()) {
    case Type::NULL:
      return a.to<Null>() == b.to<Null>();
    case Type::BOOL:
      return a.to<Bool>() == b.to<Bool>();
    case Type::NUMBER:
      return a.to<Number>() == b.to<Number>();
    case Type::STRING:
      return a.to<String>() == b.to<String>();
    case Type::OBJECT:
      return ranges::all_of(views::zip(a.to<Object>(), b.to<Object>()), [](auto pair) {
        return pair.first == pair.second;
      });
    case Type::LIST:
      return ranges::all_of(views::zip(a.to<List>(), b.to<List>()), [](auto pair) {
        return pair.first == pair.second;
      });
    }
  }
};

class Parser {
public:
  Parser(const std::string& str) {
    _iter = str.begin();
    _end = str.end();
    _str = &str;
  }
  auto parse() -> Json { return parseJson(); }

private:
  decltype(std::declval<const std::string>().end())   _end;
  decltype(std::declval<const std::string>().begin()) _iter;
  std::string const*                                  _str;

  auto skipSpace() -> char {
    while (std::isspace(*_iter)) {
      _iter++;
    }
    return *_iter;
  }

  auto parseJson() -> Json {
    auto c = skipSpace();
    if (auto res = parseFloat(); res.has_value()) {
      return res.value();
    } else if (c == '{') {
      return parseObject();
    } else if (c == '[') {
      return parseList();
    } else if (c == 't' || c == 'f') {
      return parseBool();
    } else if (c == '\"') {
      return parseString();
    } else if (c == 'n') {
      return parseNull();
    } else {
      toy::throwf("error");
    }
  }

  auto parseObject() -> Object {
    // skip {
    _iter++;
    auto map = std::map<std::string, Json>{};
    while (true) {
      auto c = skipSpace();
      auto key = parseString();
      if (map.contains(key)) {
        toy::throwf("key repeat: {}", key);
      }
      c = skipSpace();
      toy::throwf(c == ':', "error");
      _iter++;
      c = skipSpace();
      auto value = parseJson();
      map.emplace(std::move(key), std::move(value));
      c = skipSpace();
      if (c == ',') {
        _iter++;
        continue;
      } else if (c == '}') {
        _iter++;
        break;
      }
    }
    return map;
  }
  auto parseList() -> List {
    // skip [
    _iter++;
    auto list = std::vector<Json>{};
    auto c = skipSpace();
    if (c == ']') {
      _iter++;
      return list;
    }
    while (true) {
      auto c = skipSpace();
      auto element = parseJson();
      list.push_back(std::move(element));
      c = skipSpace();
      if (c == ',') {
        _iter++;
        continue;
      } else if (c == ']') {
        _iter++;
        break;
      }
    }
    return list;
  }
  auto parseString() -> String {
    // skip "
    _iter++;
    std::vector<char> string_builder;
    while (true) {
      auto c = *_iter;
      if (c == '"') {
        _iter++;
        return { string_builder.begin(), string_builder.end() };
      } else if (c == '\\') {
        _iter++;
        c = *_iter;
        if (c == '"' || c == '\\' || c == '/') {
          string_builder.push_back(c);
        } else if (c == 'b') {
          string_builder.push_back('\b');
        } else if (c == 'f') {
          string_builder.push_back('\f');
        } else if (c == 'n') {
          string_builder.push_back('\n');
        } else if (c == 'r') {
          string_builder.push_back('\r');
        } else if (c == 't') {
          string_builder.push_back('\t');
        } else if (c == 'u') {
          toy::throwf("\\u unimplement");
        } else {
          toy::throwf("error escape");
        }
        _iter++;
      } else {
        string_builder.push_back(c);
        _iter++;
      }
    }
  }

  auto parseFloat() -> std::optional<Number> {
    auto end = (char*)nullptr;
    auto ss = std::stringstream{ *_str };
    ss.seekg(_iter - _str->begin());
    float result;
    ss >> result;
    if (ss.fail()) {
      return std::nullopt;
    } else {
      _iter = _str->begin() + ss.tellg();
      return result;
    }
  }
  auto parseNull() -> Null {
    toy::throwf(std::string{ _iter, _iter + 4 } == "null", "error");
    return {};
  }
  auto parseBool() -> Bool {
    if (std::string{ _iter, _iter + 4 } == "true") {
      return true;
    } else if (std::string{ _iter, _iter + 5 } == "false") {
      return false;
    } else {
      toy::throwf("failed to parse bool");
    }
  }
};

auto Json::parse(const std::string& str) -> Json {
  auto parser = Parser{ str };
  return parser.parse();
}

} // namespace json

template <>
class std::formatter<json::Json> : public std::formatter<std::string> {
public:
  template <typename FormatContext, typename... Args>
  auto format(const json::Json& e, FormatContext& ctx) const {
    return std::formatter<std::string>::format(formatString(e), ctx);
  }

private:
  auto formatString(const json::Json& e) const -> std::string { return e.dump(); }
};

export namespace json {

void test_json() {
  auto j0 = Json{};
  toy::throwf(j0.is<Object>(), "error");
  toy::throwf(j0.type() == Type::OBJECT, "error");
  auto j1 = Json{ null };
  toy::throwf(j1.is<Null>(), "error");
  toy::throwf(j1.type() == Type::NULL, "error");
  auto j2 = Json{ 1 };
  auto j4 = Json{ true };
  toy::throwf(j4.is<Bool>(), "error");
  toy::throwf(j4.type() == Type::BOOL, "error");
  auto j5 = Json{ 1.0f };
  toy::throwf(j5.is<Number>(), "error");
  toy::throwf(j5.type() == Type::NUMBER, "error");
  auto j6 = Json{ 1.0 };
  toy::throwf(j6.is<Number>(), "error");
  toy::throwf(j6.type() == Type::NUMBER, "error");
  auto j7 = Json{ std::string{ "123" } };
  toy::throwf(j7.is<String>(), "error");
  toy::throwf(j7.type() == Type::STRING, "error");
  auto j8 = Json{ "123" };
  toy::throwf(j8.is<String>(), "error");
  toy::throwf(j8.type() == Type::STRING, "error");
  auto j9 = Json{ { std::string("Xiaoming"), std::string("Genshin") } };
  toy::throwf(j9.is<Object>(), "error");
  toy::throwf(j9.type() == Type::OBJECT, "error");
  auto j10 = Json::array({ { { "Xiaoming", j9 } }, std::string("Genshin") });
  toy::throwf(j10.is<List>(), "error");
  toy::throwf(j10.type() == Type::LIST, "error");
  j0["123"] = 456;
  toy::throwf(j0["123"].to<Number>() == 456, "error");
  toy::throwf(j0["123"] == 456, "error");
  auto  json = Json::parse(std::ifstream("test.json", std::ios_base::in));
  auto& object = json.to<Object>();
  toy::throwf(object.at("a").toInteger() == 1, "error test json");
  toy::throwf(object.at("b").to<List>()[0].toInteger() == 1, "error test json");
  toy::debug(json.to<Object>() | views::keys);
  toy::debug(json.dump());
  toy::debug(json);
}

} // namespace json