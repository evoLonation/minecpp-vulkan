export module vulkan.image;

import "vulkan_config.h";
import "stb_image.h";
import std;
import toy;
import vulkan.resource;
import vulkan.buffer;
import vulkan.command;
import vulkan.sync;
import vulkan.descriptor;

export namespace vk {

auto _tiling = VK_IMAGE_TILING_OPTIMAL;

enum class ImageType {
  SAMPLED_IMAGE,
  DEPTH_STENCIL,
  COLOR_ATTACHMENT,
};

auto findSupportedFormat(
  VkPhysicalDevice pdevice, std::span<const VkFormat> candidates, ImageType type
) -> VkFormat {
  auto get_feature = [](ImageType type) {
    switch (type) {
    case ImageType::SAMPLED_IMAGE:
      return VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT;
    case ImageType::DEPTH_STENCIL:
      return VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT;
    default:
      std::unreachable();
    }
  };
  auto feature = get_feature(type);
  auto condition = [&](VkFormat format) {
    VkFormatProperties properties;
    vkGetPhysicalDeviceFormatProperties(pdevice, format, &properties);
    return _tiling == VK_IMAGE_TILING_OPTIMAL &&
             (properties.optimalTilingFeatures & feature) == feature ||
           _tiling == VK_IMAGE_TILING_LINEAR &&
             (properties.linearTilingFeatures & feature) == feature;
  };
  if (auto it = ranges::find_if(candidates, condition); it != candidates.end()) {
    return *it;
  } else {
    toy::throwf("can not found support format");
  }
  std::unreachable();
}
auto getUsage(ImageType type) -> VkImageUsageFlags {
  VkImageUsageFlagBits usage;
  switch (type) {
  case ImageType::SAMPLED_IMAGE:
    usage = VK_IMAGE_USAGE_SAMPLED_BIT;
    break;
  case ImageType::COLOR_ATTACHMENT:
    usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    break;
  case ImageType::DEPTH_STENCIL:
    usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;
    break;
  }
  return usage | VK_IMAGE_USAGE_TRANSFER_DST_BIT;
}
auto getAspect(ImageType type) -> VkImageAspectFlagBits {
  switch (type) {
  case ImageType::COLOR_ATTACHMENT:
  case ImageType::SAMPLED_IMAGE:
    return VK_IMAGE_ASPECT_COLOR_BIT;
  case ImageType::DEPTH_STENCIL:
    return VK_IMAGE_ASPECT_DEPTH_BIT;
  default:
    std::unreachable();
  }
};
auto getSubResourceRange(ImageType type) -> VkImageSubresourceRange {
  return {
    .aspectMask = getAspect(type),
    .baseMipLevel = 0,
    .levelCount = 1,
    .baseArrayLayer = 0,
    .layerCount = 1,
  };
}

auto createImageView(VkDevice device, VkImage image, VkFormat format, ImageType type) -> ImageView {
  auto create_info = VkImageViewCreateInfo{
    .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    .pNext = nullptr,
    .flags = 0,
    .image = image,
    .viewType = VK_IMAGE_VIEW_TYPE_2D,
    .format = format,
    // 颜色通道映射
    .components = {
      .r = VK_COMPONENT_SWIZZLE_IDENTITY,
      .g = VK_COMPONENT_SWIZZLE_IDENTITY,
      .b = VK_COMPONENT_SWIZZLE_IDENTITY,
      .a = VK_COMPONENT_SWIZZLE_IDENTITY,
    },
    // view 访问 image 资源的范围
    .subresourceRange = getSubResourceRange(type),
  };
  return ImageView{ device, create_info };
}

struct ImageResource {
  Image     image;
  Memory    memory;
  ImageView image_view;
};

auto createImage(
  VkPhysicalDevice pdevice,
  VkDevice         device,
  VkFormat         format,
  uint32_t         width,
  uint32_t         height,
  ImageType        type
) -> ImageResource {

  // if use for staging image, combine use:
  // VK_IMAGE_TILING_LINEAR, VK_IMAGE_LAYOUT_PREINITIALIZED,
  // VK_IMAGE_USAGE_TRANSFER_SRC_BIT
  auto image_info = VkImageCreateInfo{
    .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    .pNext = nullptr,
    .flags = 0,
    .imageType = VK_IMAGE_TYPE_2D,
    .format = format,
    .extent =
      VkExtent3D{
        .width = width,
        .height = height,
        .depth = 1,
      },
    .mipLevels = 1,
    .arrayLayers = 1,
    .samples = VK_SAMPLE_COUNT_1_BIT,
    // VK_IMAGE_TILING_LINEAR: Texels are laid out in row-major
    // order like our pixels array
    // 想要直接访问 image 中的像素的话就用 VK_IMAGE_TILING_LINEAR
    // VK_IMAGE_TILING_OPTIMAL: Texels are laid out in an implementation
    // defined order for optimal access
    .tiling = _tiling,
    .usage = getUsage(type),
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    // 仅当VK_SHARING_MODE_CONCURRENT时设置
    .queueFamilyIndexCount = 0,
    .pQueueFamilyIndices = nullptr,
    // VK_IMAGE_LAYOUT_UNDEFINED: Not usable by the GPU
    // and the very first transition will discard the texels
    // VK_IMAGE_LAYOUT_PREINITIALIZED: Not usable by the GPU
    // but the first transition will preserve the texels
    .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
  };
  auto image = Image{ device, image_info };
  auto memory = createMemory(pdevice, device, image.get(), VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
  vkBindImageMemory(device, image, memory, 0);
  auto image_view = createImageView(device, image, format, type);
  return { std::move(image), std::move(memory), std::move(image_view) };
}

void recordImageBarrier(
  VkCommandBuffer                                    cmdbuf,
  VkImage                                            image,
  std::pair<ImageUse, ImageUse>                      use,
  std::optional<std::pair<FamilyTransferInfo, bool>> family_transfer,
  ImageType                                          type
) {
  auto [src_scope, src_layout] = getImageSyncInfo(false, use.first);
  auto [dst_scope, dst_layout] = getImageSyncInfo(true, use.second);
  auto common_info = getBarrierCommonInfo({ src_scope, dst_scope }, family_transfer);

  auto image_barrier = VkImageMemoryBarrier{
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    .pNext = nullptr,
    .srcAccessMask = common_info.src_scope.access_mask,
    .dstAccessMask = common_info.dst_scope.access_mask,
    .oldLayout = src_layout,
    .newLayout = dst_layout,
    .srcQueueFamilyIndex = common_info.family_transfer.src_family,
    .dstQueueFamilyIndex = common_info.family_transfer.dst_family,
    .image = image,
    .subresourceRange = getSubResourceRange(type),
  };
  recordPipelineBarrier(
    cmdbuf,
    { common_info.src_scope.stage_mask, common_info.dst_scope.stage_mask },
    {},
    {},
    { &image_barrier, 1 }
  );
}

auto createSampler(VkDevice device, float max_anisotropy) -> Sampler {
  toy::debugf("max_anisotropy: {}", max_anisotropy);
  auto sampler_info = VkSamplerCreateInfo{
    .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    .pNext = nullptr,
    .flags = 0,
    // VK_FILTER_NEAREST and VK_FILTER_LINEAR, 插值模式
    .magFilter = VK_FILTER_LINEAR,
    .minFilter = VK_FILTER_LINEAR,
    .mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    // VK_SAMPLER_ADDRESS_MODE_REPEAT：超出图像尺寸时重复纹理。
    // VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT：同上，但是镜像图像。
    // VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE：使最接近坐标的边缘的颜色超出图像尺寸。
    // VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE：同上，但使用对面的边
    // VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER：采样超出尺寸时返回纯色
    .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    .mipLodBias = 0.0f,
    // 各向异性过滤
    .anisotropyEnable = VK_TRUE,
    .maxAnisotropy = max_anisotropy,
    .compareEnable = VK_FALSE,
    .compareOp = VK_COMPARE_OP_ALWAYS,
    .minLod = 0.0f,
    .maxLod = 0.0f,
    .borderColor = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    // VK_FALSE: (0, 1)寻址， 反之 (0, width), (0, height)寻址
    .unnormalizedCoordinates = VK_FALSE,
  };
  return Sampler{ device, sampler_info };
}

class SampledTexture {
private:
  Buffer _staging_buffer;
  Memory _staging_memory;

  ImageResource _image_resource;
  Sampler       _sampler;

  std::optional<FamilyTransferInfo> _family_transfer;

  Semaphore _release_sema;

  static constexpr auto _image_type = ImageType::SAMPLED_IMAGE;
  static constexpr auto _src_use = ImageUse::COPY_DST;
  static constexpr auto _dst_use = ImageUse::FRAGMENT_SAMPLER;
  static constexpr auto _use_pair = std::pair{ _src_use, _dst_use };

public:
  SampledTexture() = default;
  SampledTexture(
    VkPhysicalDevice                  pdevice,
    VkDevice                          device,
    const std::string&                path,
    VkQueue                           transfer_queue,
    VkCommandBuffer                   transfer_cmdbuf,
    VkDescriptorSet                   descrip_set,
    float                             max_anisotropy,
    std::optional<FamilyTransferInfo> family_transfer
  ) {
    int   width, height, channels;
    auto* pixels = stbi_load(path.data(), &width, &height, &channels, STBI_rgb_alpha);
    auto  image_size = static_cast<VkDeviceSize>(width * height * 4);
    if (pixels == nullptr) {
      toy::throwf("failed to load image {}", path.data());
    }
    auto image_data = std::as_bytes(std::span{ pixels, image_size });
    toy::debugf("image {} info: width {}, height {}", path.data(), width, height);

    std::tie(_staging_buffer, _staging_memory) = createStagingBuffer(pdevice, device, image_data);

    stbi_image_free(pixels);

    auto format = findSupportedFormat(pdevice, std::array{ VK_FORMAT_R8G8B8A8_SRGB }, _image_type);

    _image_resource = createImage(pdevice, device, format, width, height, _image_type);

    _sampler = createSampler(device, max_anisotropy);
    updateDescriptorSet(
      device, descrip_set, std::pair{ _image_resource.image_view.get(), _sampler.get() }
    );

    _family_transfer = family_transfer;

    auto recorder = [&](VkCommandBuffer cmdbuf) {
      recordImageBarrier(
        cmdbuf,
        _image_resource.image.get(),
        { ImageUse::UNDEFINED, _src_use },
        std::nullopt,
        _image_type
      );

      auto image_copy = VkBufferImageCopy{
        .bufferOffset = 0,
        // bufferRowLength and bufferImageHeight
        // 用于更详细的定义buffer的内存如何映射到image
        .bufferRowLength = 0,
        .bufferImageHeight = 0,
        .imageSubresource =
          VkImageSubresourceLayers{
            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
            .mipLevel = 0,
            .baseArrayLayer = 0,
            .layerCount = 1,
          },
        .imageOffset =
          VkOffset3D{
            .x = 0,
            .y = 0,
            .z = 0,
          },
        .imageExtent =
          VkExtent3D{
            .width = (uint32_t)width,
            .height = (uint32_t)height,
            .depth = 1,
          },
      };
      vkCmdCopyBufferToImage(
        cmdbuf,
        _staging_buffer,
        _image_resource.image,
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        1,
        &image_copy
      );

      recordImageBarrier(
        cmdbuf,
        _image_resource.image.get(),
        _use_pair,
        family_transfer.transform([](auto transfer) {
          return std::pair{ transfer, false };
        }),
        _image_type
      );
    };
    _release_sema = createSemaphore(device);
    recordAndSubmit(
      transfer_cmdbuf, transfer_queue, recorder, {}, { &_release_sema.get(), 1 }, VK_NULL_HANDLE
    );
  }

  auto getNeedWaitInfo() -> std::pair<VkSemaphore, VkPipelineStageFlags> {
    return { _release_sema, getImageSyncInfo(false, _dst_use).first.stage_mask };
  }

  void recordDstFamilyTransfer(VkCommandBuffer cmdbuf) {
    if (_family_transfer.has_value()) {
      recordImageBarrier(
        cmdbuf,
        _image_resource.image.get(),
        _use_pair,
        std::pair{ _family_transfer.value(), true },
        _image_type
      );
    }
  }
};

auto findDepthFormat(VkPhysicalDevice pdevice) -> VkFormat {
  return findSupportedFormat(
    pdevice,
    std::array{ VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT },
    ImageType::DEPTH_STENCIL
  );
}

auto createDepthImage(VkPhysicalDevice pdevice, VkDevice device, VkFormat format, VkExtent2D extent)
  -> ImageResource {
  return createImage(
    pdevice, device, format, extent.width, extent.height, ImageType::DEPTH_STENCIL
  );
}

} // namespace vk