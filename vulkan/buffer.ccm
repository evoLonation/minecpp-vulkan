export module vulkan.buffer;

import "vulkan_config.h";
import vulkan.tool;
import std;
import glm;
import toy;

namespace ranges = std::ranges;
namespace views = std::views;

export {

template <int AttributeCount>
struct VertexInfo {
  VkVertexInputBindingDescription binding_description;
  std::array<VkVertexInputAttributeDescription, AttributeCount>
    attribute_descriptions;
};

template <typename Type>
consteval auto formatMapper() -> VkFormat {
  if constexpr (std::same_as<Type, glm::vec2>) {
    return VK_FORMAT_R32G32_SFLOAT;
  } else if constexpr (std::same_as<Type, glm::vec3>) {
    return VK_FORMAT_R32G32B32_SFLOAT;
  } else if constexpr (std::same_as<Type, glm::vec4>) {
    return VK_FORMAT_R32G32B32A32_SFLOAT;
  } else if constexpr (std::same_as<Type, float>) {
    return VK_FORMAT_R32_SFLOAT;
  }
}

template <typename... DataTypes>
  requires(std::is_trivially_copyable_v<DataTypes> && ...)
struct VertexData {
  struct Vertex : public std::array<char, (sizeof(DataTypes) + ...)> {
    using Base = std::array<char, (sizeof(DataTypes) + ...)>;
    Vertex(DataTypes&&... data) {
      int offset = 0;
      ((*reinterpret_cast<DataTypes*>(Base::data() + offset) = data,
        offset += sizeof(DataTypes)),
       ...);
    }
  };

  constexpr static int AttributeCount = sizeof...(DataTypes);

  std::vector<Vertex> vertices;

  static consteval auto getVertexInfo() -> VertexInfo<AttributeCount>;
};

using VertexData2D = VertexData<glm::vec2, glm::vec3>;

auto createVertexBuffer(VertexData2D     vertex_data,
                        VkDevice         device,
                        VkPhysicalDevice physical_device) {
  auto buffer_info = VkBufferCreateInfo{
    .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    .size = vertex_data.vertices.size() * sizeof(VertexData2D::Vertex),
    .usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
  };
  auto buffer =
    createVkResource(vkCreateBuffer, "vertex buffer", device, &buffer_info);
  /* alignment: The offset in bytes where the buffer begins in the allocated
   *  region of memory, depends on bufferInfo.usage and bufferInfo.flags.
   * memoryTypeBits: Bit field of the memory types that are suitable for the
   *  buffer.
   */
  VkMemoryRequirements memory_requirements;
  vkGetBufferMemoryRequirements(device, buffer, &memory_requirements);

  VkPhysicalDeviceMemoryProperties memory_properties;

  uint32_t memory_type_index;

  auto arr = std::span(memory_properties.memoryTypes,
                       memory_properties.memoryTypeCount) |
             toy::enumerate;
  auto iter = *arr.begin();
  auto arr2 = views::zip(views::iota(0, 3), std::array{1, 2, 3});
  arr2.begin();
  if (auto iter =
        ranges::find_if(arr,
                        [memory_requirements](auto pair) {
                          auto [i, memory_type] = pair;
                          return (memory_requirements.memoryTypeBits & i) &&
                                 memory_type.propertyFlags &
                                   (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                                    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
                        });
      iter != arr.end()) {
    
    // memory_type_index = std::move(iter)->first;
  }
}

void destroyVertexBuffer(VkBuffer buffer, VkDevice device) noexcept {
  vkDestroyBuffer(device, buffer, nullptr);
}

}

template <typename... DataTypes>
  requires(std::is_trivially_copyable_v<DataTypes> && ...)
consteval auto VertexData<DataTypes...>::getVertexInfo()
  -> VertexInfo<AttributeCount> {
  auto binding_description = VkVertexInputBindingDescription{
    .binding = 0,
    .stride = sizeof(VertexData<DataTypes...>::Vertex),
    // VK_VERTEX_INPUT_RATE_{VERTEX|INSTANCE}:
    // 是在每个vertex或者instance后移动到下一个data entry
    .inputRate = VK_VERTEX_INPUT_RATE_VERTEX,
  };
  auto attribute_descriptions =
    std::array<VkVertexInputAttributeDescription,
               VertexData<DataTypes...>::AttributeCount>{};

  uint32_t i = 0;
  uint32_t offset = 0;
  ((attribute_descriptions[i] =
      VkVertexInputAttributeDescription{
        .location = i,
        .binding = 0,
        .format = formatMapper<DataTypes>(),
        .offset = offset,
      },
    i++,
    offset += sizeof(DataTypes)),
   ...);
  return { binding_description, attribute_descriptions };
}
