export module vulkan.buffer;

import "vulkan_config.h";
import vulkan.tool;
import std;
import glm;
import toy;

export {

template <int AttributeCount>
struct VertexInfo {
  VkVertexInputBindingDescription binding_description;
  std::array<VkVertexInputAttributeDescription, AttributeCount>
    attribute_descriptions;
};

template <typename Type>
consteval auto formatMapper() -> VkFormat {
  if constexpr (std::same_as<Type, glm::vec2>) {
    return VK_FORMAT_R32G32_SFLOAT;
  } else if constexpr (std::same_as<Type, glm::vec3>) {
    return VK_FORMAT_R32G32B32_SFLOAT;
  } else if constexpr (std::same_as<Type, glm::vec4>) {
    return VK_FORMAT_R32G32B32A32_SFLOAT;
  } else if constexpr (std::same_as<Type, float>) {
    return VK_FORMAT_R32_SFLOAT;
  }
}

template <typename... DataTypes>
  requires(std::is_trivially_copyable_v<DataTypes> && ...)
struct VertexData {
  struct Vertex : public std::array<char, (sizeof(DataTypes) + ...)> {
    using Base = std::array<char, (sizeof(DataTypes) + ...)>;
    Vertex(DataTypes&&... data) {
      int offset = 0;
      ((*reinterpret_cast<DataTypes*>(Base::data() + offset) = data,
        offset += sizeof(DataTypes)),
       ...);
    }
  };

  constexpr static int AttributeCount = sizeof...(DataTypes);

  std::vector<Vertex> vertices;

  static consteval auto getVertexInfo() -> VertexInfo<AttributeCount>;
};

using VertexData2D = VertexData<glm::vec2, glm::vec3>;

auto createVertexBuffer(VertexData2D     vertex_data,
                        VkDevice         device,
                        VkPhysicalDevice physical_device)
  -> std::pair<VkBuffer, VkDeviceMemory> {
  auto buffer_info = VkBufferCreateInfo{
    .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    .size = vertex_data.vertices.size() * sizeof(VertexData2D::Vertex),
    .usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
  };
  auto vertex_buffer =
    createVkResource(vkCreateBuffer, "vertex buffer", device, &buffer_info);
  /* alignment: The offset in bytes where the buffer begins in the allocated
   *  region of memory, depends on bufferInfo.usage and bufferInfo.flags.
   * memoryTypeBits: Bit field of the memory types that are suitable for the
   *  buffer.
   */
  VkMemoryRequirements memory_requirements;
  vkGetBufferMemoryRequirements(device, vertex_buffer, &memory_requirements);

  VkPhysicalDeviceMemoryProperties memory_properties;
  vkGetPhysicalDeviceMemoryProperties(physical_device, &memory_properties);
  uint32_t memory_type_index;
  auto     property_flags =
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
  if (auto optional = toy::findIf(
        std::span(memory_properties.memoryTypes,
                  memory_properties.memoryTypeCount) |
          toy::enumerate,
        [memory_requirements, property_flags](auto pair) {
          auto [i, memory_type] = pair;
          toy::debug(i);
          return (memory_requirements.memoryTypeBits & (1 << i)) &&
                 (memory_type.propertyFlags & property_flags) == property_flags;
        });
      optional.has_value()) {
    memory_type_index = optional->first;
  } else {
    toy::throwf("can not find suitable memory type");
  }
  auto allocate_info = VkMemoryAllocateInfo{
    .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
    .allocationSize = memory_requirements.size,
    .memoryTypeIndex = memory_type_index,
  };
  auto vertex_buffer_memory =
    createVkResource(vkAllocateMemory,
                     "vertex buffer memory allocation",
                     device,
                     &allocate_info);
  // offset 是在一个内存给多个缓冲区用的时候设置的，要除的尽
  // memRequirements.alignment
  vkBindBufferMemory(device, vertex_buffer, vertex_buffer_memory, 0);

  void* data;
  checkVkResult(
    vkMapMemory(device, vertex_buffer_memory, 0, buffer_info.size, 0, &data),
    "map memory");
  std::memcpy(data, vertex_data.vertices.data(), buffer_info.size);
  vkUnmapMemory(device, vertex_buffer_memory);
  return { vertex_buffer, vertex_buffer_memory };
}

void destroyVertexBuffer(VkBuffer       buffer,
                         VkDeviceMemory memory,
                         VkDevice       device) noexcept {
  vkFreeMemory(device, memory, nullptr);
  vkDestroyBuffer(device, buffer, nullptr);
}

}

template <typename... DataTypes>
  requires(std::is_trivially_copyable_v<DataTypes> && ...)
consteval auto VertexData<DataTypes...>::getVertexInfo()
  -> VertexInfo<AttributeCount> {
  auto binding_description = VkVertexInputBindingDescription{
    .binding = 0,
    .stride = sizeof(VertexData<DataTypes...>::Vertex),
    // VK_VERTEX_INPUT_RATE_{VERTEX|INSTANCE}:
    // 是在每个vertex或者instance后移动到下一个data entry
    .inputRate = VK_VERTEX_INPUT_RATE_VERTEX,
  };
  auto attribute_descriptions =
    std::array<VkVertexInputAttributeDescription,
               VertexData<DataTypes...>::AttributeCount>{};

  uint32_t i = 0;
  uint32_t offset = 0;
  ((attribute_descriptions[i] =
      VkVertexInputAttributeDescription{
        .location = i,
        .binding = 0,
        .format = formatMapper<DataTypes>(),
        .offset = offset,
      },
    i++,
    offset += sizeof(DataTypes)),
   ...);
  return { binding_description, attribute_descriptions };
}
