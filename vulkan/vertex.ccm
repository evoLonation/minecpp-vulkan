export module vulkan.vertex;

import <vulkan_config.h>;
import vulkan.resource;
import vulkan.buffer;
import vulkan.sync;
import vulkan.command;
import toy;
import glm;
import std;

export namespace vk {

template <int AttributeCount>
struct VertexInfo {
  VkVertexInputBindingDescription                               binding_description;
  std::array<VkVertexInputAttributeDescription, AttributeCount> attribute_descriptions;
};

template <typename... DataTypes>
  requires(std::is_trivially_copyable_v<DataTypes> && ...)
struct Vertex : public std::array<char, (sizeof(DataTypes) + ...)> {
  using Base = std::array<char, (sizeof(DataTypes) + ...)>;
  Vertex(DataTypes&&... data) {
    int offset = 0;
    ((*reinterpret_cast<DataTypes*>(Base::data() + offset) = data, offset += sizeof(DataTypes)),
     ...);
  }
  static consteval auto getVertexInfo() -> VertexInfo<sizeof...(DataTypes)>;
};

template <typename Type>
consteval auto formatMapper() -> VkFormat {
  if constexpr (std::same_as<Type, glm::vec2>) {
    return VK_FORMAT_R32G32_SFLOAT;
  } else if constexpr (std::same_as<Type, glm::vec3>) {
    return VK_FORMAT_R32G32B32_SFLOAT;
  } else if constexpr (std::same_as<Type, glm::vec4>) {
    return VK_FORMAT_R32G32B32A32_SFLOAT;
  } else if constexpr (std::same_as<Type, float>) {
    return VK_FORMAT_R32_SFLOAT;
  }
}

template <typename... DataTypes>
  requires(std::is_trivially_copyable_v<DataTypes> && ...)
consteval auto Vertex<DataTypes...>::getVertexInfo() -> VertexInfo<sizeof...(DataTypes)> {
  auto binding_description = VkVertexInputBindingDescription{
    .binding = 0,
    .stride = sizeof(Vertex),
    // VK_VERTEX_INPUT_RATE_{VERTEX|INSTANCE}:
    // 是在每个vertex或者instance后移动到下一个data entry
    .inputRate = VK_VERTEX_INPUT_RATE_VERTEX,
  };
  auto attribute_descriptions =
    std::array<VkVertexInputAttributeDescription, sizeof...(DataTypes)>{};

  uint32_t i = 0;
  uint32_t offset = 0;
  ((attribute_descriptions[i] =
      VkVertexInputAttributeDescription{
        .location = i,
        .binding = 0,
        .format = formatMapper<DataTypes>(),
        .offset = offset,
      },
    i++,
    offset += sizeof(DataTypes)),
   ...);
  return { binding_description, attribute_descriptions };
}

template <bool is_index>
class VertexIndexBuffer {
private:
  Buffer _staging_buffer;
  Memory _staging_memory;

  Buffer _buffer;
  Memory _memory;

  std::optional<FamilyTransferInfo> _family_transfer;

  Semaphore _release_sema;

  static constexpr auto _src_use = BufferUse::COPY_DST;
  static constexpr auto _dst_use =
    is_index ? BufferUse::INDEX_BUFFER_DRAW : BufferUse::VERTEX_BUFFER_DRAW;
  static constexpr auto _use_pair = std::pair{ _src_use, _dst_use };

public:
  VertexIndexBuffer() = default;
  template <ranges::contiguous_range Range, bool is_index_ = is_index>
    requires(!is_index_ && toy::InstantiationOf<ranges::range_value_t<Range>, Vertex>)
  VertexIndexBuffer(
    VkPhysicalDevice                  physical_device,
    VkDevice                          device,
    VkQueue                           transfer_queue,
    VkCommandBuffer                   transfer_cmdbuf,
    Range&&                           vertex_data,
    std::optional<FamilyTransferInfo> family_transfer
  )
    : VertexIndexBuffer{ physical_device,
                         device,
                         transfer_queue,
                         transfer_cmdbuf,
                         std::as_bytes(std::span{ vertex_data }),
                         family_transfer } {}

  template <bool is_index_ = is_index>
    requires is_index_
  VertexIndexBuffer(
    VkPhysicalDevice                  physical_device,
    VkDevice                          device,
    VkQueue                           transfer_queue,
    VkCommandBuffer                   transfer_cmdbuf,
    std::span<uint16_t>               vertex_indices,
    std::optional<FamilyTransferInfo> family_transfer
  )
    : VertexIndexBuffer{
        physical_device, device, transfer_queue, transfer_cmdbuf, std::as_bytes(vertex_indices),
        family_transfer
      } {}

  VertexIndexBuffer(
    VkPhysicalDevice                  physical_device,
    VkDevice                          device,
    VkQueue                           transfer_queue,
    VkCommandBuffer                   transfer_cmdbuf,
    std::span<const std::byte>        buffer_data,
    std::optional<FamilyTransferInfo> family_transfer
  ) {
    auto buffer_size = (uint32_t)buffer_data.size();
    std::tie(_staging_buffer, _staging_memory) =
      createStagingBuffer(physical_device, device, buffer_data);
    std::tie(_buffer, _memory) = createBuffer(
      physical_device,
      device,
      buffer_size,
      VK_BUFFER_USAGE_TRANSFER_DST_BIT |
        (is_index ? VK_BUFFER_USAGE_INDEX_BUFFER_BIT : VK_BUFFER_USAGE_VERTEX_BUFFER_BIT),
      VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
    );
    _family_transfer = family_transfer;

    auto recorder = [&](VkCommandBuffer cmdbuf) {
      recordCopyBuffer(transfer_cmdbuf, _staging_buffer, _buffer, buffer_size);
      recordBarrier(cmdbuf, _buffer.get(), _use_pair, family_transfer.transform([](auto transfer) {
        return std::pair{ transfer, false };
      }));
    };

    _release_sema = createSemaphore(device);
    recordAndSubmit(
      transfer_cmdbuf, transfer_queue, recorder, {}, { &_release_sema.get(), 1 }, VK_NULL_HANDLE
    );
  }
  void recordDstFamilyTransfer(VkCommandBuffer cmdbuf) {
    if (_family_transfer.has_value()) {
      recordBarrier(cmdbuf, _buffer.get(), _use_pair, std::pair{ _family_transfer.value(), true });
    }
  }
  auto getNeedWaitInfo() -> std::pair<VkSemaphore, VkPipelineStageFlags> {
    return { _release_sema, getBufferSyncInfo(_dst_use).stage_mask };
  }
  void recordBind(VkCommandBuffer cmdbuf) {
    if constexpr (is_index) {
      vkCmdBindIndexBuffer(cmdbuf, _buffer, 0, VK_INDEX_TYPE_UINT16);
    } else {
      auto offset = (VkDeviceSize)0;
      vkCmdBindVertexBuffers(cmdbuf, 0, 1, &_buffer.get(), &offset);
    }
  }
};

using IndexBuffer = VertexIndexBuffer<true>;
using VertexBuffer = VertexIndexBuffer<false>;

} // namespace vk
