export module vulkan.resource2;

import "vulkan_config.h";
import std;
import toy;

export namespace vk2 {

enum class FactoryIdentity {
  DEFAULT,
  GRAPHIC,
};

template <typename VkHandle>
struct RegisterMeta;

template <typename VkHandle>
constexpr auto creator = RegisterMeta<VkHandle>::creator;
template <typename VkHandle>
constexpr bool create_multi = RegisterMeta<VkHandle>::create_multi;
template <typename VkHandle>
constexpr auto destroyer = RegisterMeta<VkHandle>::destroyer;
template <typename VkHandle>
constexpr bool destroy_multi = RegisterMeta<VkHandle>::destroy_multi;
template <typename VkHandle>
constexpr auto destroy_ctx_mapper = RegisterMeta<VkHandle>::destroy_ctx_mapper;
template <typename VkHandle>
  requires requires() { RegisterMeta<VkHandle>::constructor_mapper; }
constexpr auto constructor_mapper = RegisterMeta<VkHandle>::constructor_mapper;

template <typename VkHandle, FactoryIdentity identity>
struct FactoryMeta;

template <typename VkHandle, FactoryIdentity identity>
constexpr auto creator_factory = FactoryMeta<VkHandle, identity>::creator;
template <typename VkHandle, FactoryIdentity identity>
constexpr auto destroy_ctx_mapper_factory =
  FactoryMeta<VkHandle, identity>::destroy_ctx_mapper;

template <typename Arg>
concept AllocatorArg = std::same_as<Arg, const VkAllocationCallbacks*>;

template <typename VkHandle>
class DestroyManager {
private:
  static constexpr auto destroyer_ = destroyer<VkHandle>;
  static constexpr auto destroy_multi_ = destroy_multi<VkHandle>;
  template <typename Arg>
  struct Condition {
    static constexpr bool value =
      !AllocatorArg<Arg> &&
      (destroy_multi_
         ? !std::same_as<Arg, const VkHandle*> && !std::same_as<Arg, uint32_t>
         : !std::same_as<Arg, VkHandle>);
  };
  using HandleContainer =
    std::conditional_t<destroy_multi_, std::vector<VkHandle>, VkHandle>;

public:
  using Context = toy::MapTo<
    typename toy::Filter<toy::FuncArgs<decltype(destroyer_)>, Condition>,
    std::decay>::template apply<std::tuple>;

protected:
  HandleContainer handle_;
  Context         context_;

private:
  static constexpr bool has_allocator_ =
    AllocatorArg<typename toy::FuncArgs<decltype(destroyer_)>::template at<-1>>;

  void destroyResource() {
    if constexpr (!destroy_multi_) {
      if (handle_ != VK_NULL_HANDLE) {
        std::apply(
          [&handle = handle_](auto... args) {
            if constexpr (has_allocator_) {
              destroyer_(args..., handle, nullptr);
            } else {
              destroyer_(args..., handle);
            }
          },
          context_);
      }
    } else {
      if (!handle_.empty()) {
        std::apply(
          [&handles = handle_](auto... args) {
            if constexpr (has_allocator_) {
              destroyer_(args..., handles.size(), handles.data(), nullptr);
            } else {
              destroyer_(args..., handles.size(), handles.data());
            }
          },
          context_);
      }
    }
  }

public:
  DestroyManager() {
    if constexpr (!destroy_multi_) {
      handle_ = VK_NULL_HANDLE;
    }
  }
  DestroyManager(const DestroyManager&) = delete;
  DestroyManager(DestroyManager&& resource) {
    if constexpr (!destroy_multi_) {
      handle_ = resource.handle_;
      resource.handle_ = VK_NULL_HANDLE;
    } else {
      handle_ = std::move(resource.handle_);
    }
  }
  auto operator=(const DestroyManager&) -> DestroyManager& = delete;
  auto operator=(DestroyManager&& resource) -> DestroyManager& {
    destroyResource();
    if constexpr (!destroy_multi_) {
      handle_ = resource.handle_;
      resource.handle_ = VK_NULL_HANDLE;
    } else {
      handle_ = std::move(resource.handle_);
    }
  }
  ~DestroyManager() { destroyResource(); }
};

template <typename VkHandle>
struct OriginArgPackS {
  using Creator = decltype(creator<VkHandle>);
  template <typename Arg>
  struct Condition {
    static constexpr bool value =
      !AllocatorArg<Arg> && !std::same_as<Arg, VkHandle*>;
  };
  using type = toy::Filter<toy::FuncArgs<Creator>, Condition>;
};
template <typename VkHandle>
using OriginArgPack = OriginArgPackS<VkHandle>::type;
template <typename VkHandle>
struct ConstructArgPackS;
template <typename VkHandle>
  requires(!requires() { constructor_mapper<VkHandle>(); })
struct ConstructArgPackS<VkHandle> {
private:
  template <typename Arg>
  struct Mapper {
    using type =
      std::conditional_t<std::is_pointer_v<Arg> &&
                           std::is_const_v<std::remove_pointer_t<Arg>>,
                         std::remove_pointer_t<Arg>&,
                         Arg>;
  };

public:
  using type = toy::MapTo<OriginArgPack<VkHandle>, Mapper>;
};

template <typename VkHandle>
  requires requires() { constructor_mapper<VkHandle>(); }
struct ConstructArgPackS<VkHandle> {
  using type = toy::FuncArgs<decltype(constructor_mapper<VkHandle>)>;
};
template <typename VkHandle>
using ConstructArgPack = ConstructArgPackS<VkHandle>::type;

template <
  typename VkHandle,
  typename OriginArgTuple = OriginArgPack<VkHandle>::template apply<std::tuple>>
  requires(create_multi<VkHandle> && destroy_multi<VkHandle>) ||
          (!create_multi<VkHandle> && !destroy_multi<VkHandle>)
class OriginConstructor : public DestroyManager<VkHandle> {
private:
  static constexpr auto creator_ = creator<VkHandle>;
  static constexpr auto create_multi_ = create_multi<VkHandle>;
  static constexpr auto destroy_ctx_mapper_ = destroy_ctx_mapper<VkHandle>;
  static constexpr bool has_allocator_ =
    AllocatorArg<typename toy::FuncArgs<decltype(creator_)>::template at<-2>>;

public:
  OriginConstructor(const OriginConstructor&) = delete;
  OriginConstructor(OriginConstructor&&) = default;
  auto operator=(const OriginConstructor&) -> OriginConstructor& = delete;
  auto operator=(OriginConstructor&&) -> OriginConstructor& = default;
  OriginConstructor() = default;
  ~OriginConstructor() = default;
  OriginConstructor(OriginArgTuple args) {
    std::apply(
      [this](auto&... args) {
        if constexpr (!create_multi_) {
          if constexpr (has_allocator_) {
            creator_(args..., nullptr, &this->handle_);
          } else {
            creator_(args..., &this->handle_);
          }
        } else {
          if constexpr (has_allocator_) {
            creator_(args..., nullptr, this->handle_.data());
          } else {
            creator_(args..., this->handle_.data());
          }
        }
      },
      args);
  }
};
// template <typename VkHandle,
//           FactoryIdentity identity,
//           typename OriginArgTuple =
//             OriginArgPack<VkHandle>::template apply<std::tuple>>
//   requires(create_multi<VkHandle> && !destroy_multi<VkHandle>)
// class OriginFactory {
// private:
//   static constexpr auto creator_ = creator_factory<VkHandle, identity>;
//   static constexpr auto destroy_ctx_mapper_ =
//     destroy_ctx_mapper_factory<VkHandle, identity>;
//   static constexpr bool has_allocator_ =
//     AllocatorArg<typename toy::FuncArgs<decltype(creator_)>::template at<-2>>;

//   using Resource = DestroyManager<VkHandle>;
// public:
//   OriginFactory() = delete;
//   static Resource create(OriginArgTuple args) {
//     Resource resource;
//     std::apply(
//       [this](auto&... args) {
//         if constexpr (!create_multi_) {
//           if constexpr (has_allocator_) {
//             creator_(args..., nullptr, &this->handle_);
//           } else {
//             creator_(args..., &this->handle_);
//           }
//         } else {
//           if constexpr (has_allocator_) {
//             creator_(args..., nullptr, this->handle_.data());
//           } else {
//             creator_(args..., this->handle_.data());
//           }
//         }
//       },
//       args);
//   }
// };

template <typename VkHandle,
          FactoryIdentity identity = FactoryIdentity::DEFAULT,
          typename ConstructArgPack = ConstructArgPack<VkHandle>>
class CustomConstructor;

template <typename VkHandle,
          FactoryIdentity identity,
          typename... ConstructArgs>
  requires requires() { constructor_mapper<VkHandle>; }
class CustomConstructor<VkHandle, identity, toy::TypePack<ConstructArgs...>>
  : public OriginConstructor<VkHandle> {
private:
  using Base = OriginConstructor<VkHandle>;
  static constexpr auto constructor_mapper_ = constructor_mapper<VkHandle>;
  static constexpr auto create_multi_ = create_multi<VkHandle>;

public:
  CustomConstructor(ConstructArgs... args) {
    if constexpr (!create_multi_) {
      this->context_ = destroy_ctx_mapper_(args...);
    } else {
      uint32_t resource_count;
      std::tie(this->context_, resource_count) = destroy_ctx_mapper_(args...);
      this->handle_.resize(resource_count);
    }
    Base::operator=(Base(constructor_mapper_(args...)));
  }
};
template <typename VkHandle,
          FactoryIdentity identity,
          typename... ConstructArgs>
  requires(!requires() { constructor_mapper<VkHandle>; })
class CustomConstructor<VkHandle, identity, toy::TypePack<ConstructArgs...>>
  : public OriginConstructor<VkHandle> {
private:
  using Base = OriginConstructor<VkHandle>;

  template <typename OriginArgPack>
  struct ConstructMapper;
  template <typename... OriginArgs>
  struct ConstructMapper<toy::TypePack<OriginArgs...>> {
    template <typename ConstructArg, typename ContextArg>
    static auto argMapper(ConstructArg arg) -> ContextArg {
      if constexpr (std::same_as<ConstructArg, ContextArg>) {
        return arg;
      } else if constexpr (std::same_as<std::remove_reference_t<ConstructArg>,
                                        std::remove_pointer_t<ContextArg>>) {
        return &arg;
      }
    }
    static constexpr auto operator()(ConstructArgs... args) {
      return std::tuple{ argMapper<ConstructArgs, OriginArgs>(args)... };
    }
  };

public:
  CustomConstructor(ConstructArgs... args)
    : Base(ConstructMapper<OriginArgPack<VkHandle>>{}(args...)) {}
};

consteval auto normalMapper() {
  return [](auto context_handle, const auto& create_info) {
    return std::tuple{ context_handle };
  };
}
template <typename CreateInfo, typename PoolHandle>
consteval auto poolMapper(uint32_t CreateInfo::*count_member,
                          PoolHandle CreateInfo::*pool_member) {
  return
    [pool_member, count_member](auto context_handle, const auto& create_info) {
      return std::pair{ std::tuple{ context_handle, create_info.*pool_member },
                        create_info.*count_member };
    };
}

template <>
struct RegisterMeta<VkBuffer> {
  static constexpr auto creator = vkCreateBuffer;
  static constexpr auto create_multi = false;
  static constexpr auto destroyer = vkDestroyBuffer;
  static constexpr auto destroy_multi = false;
  static constexpr auto destroy_ctx_mapper = normalMapper();
};
template <>
struct RegisterMeta<VkCommandBuffer> {
  static constexpr auto creator = vkAllocateCommandBuffers;
  static constexpr auto create_multi = true;
  static constexpr auto destroyer = vkFreeCommandBuffers;
  static constexpr auto destroy_multi = true;
  static constexpr auto destroy_ctx_mapper =
    poolMapper(&VkCommandBufferAllocateInfo::commandBufferCount,
               &VkCommandBufferAllocateInfo::commandPool);
};
template <>
struct RegisterMeta<VkPipeline> {
  static constexpr auto creator = vkCreateGraphicsPipelines;
  static constexpr auto create_multi = true;
  static constexpr auto destroyer = vkDestroyPipeline;
  static constexpr auto destroy_multi = false;
  static constexpr auto destroy_ctx_mapper =
    poolMapper(&VkCommandBufferAllocateInfo::commandBufferCount,
               &VkCommandBufferAllocateInfo::commandPool);
};
template <typename VkHandle, FactoryIdentity identity>
struct FactoryMeta;
template <>
struct FactoryMeta<VkPipeline, FactoryIdentity::GRAPHIC> {
  static constexpr auto creator = vkCreateGraphicsPipelines;
  static constexpr auto create_multi = true;
};

template <typename VkHandle, FactoryIdentity identity>
class ResourceFactory;

// template class CreateManager<VkBuffer>;
using Buffer = CustomConstructor<VkBuffer>;
// template class CreateManager<VkCommandBuffer>;
using CommandBuffer = CustomConstructor<VkCommandBuffer>;
using Pipeline = OriginConstructor<VkPipeline>;
void test() {
  bool a =
    std::same_as<toy::FuncArgs<decltype(RegisterMeta<VkPipeline>::destroyer)>::
                   template at<-1>,
                 const VkAllocationCallbacks*>;

  static_assert(
    std::same_as<DestroyManager<VkBuffer>::Context, std::tuple<VkDevice>>);
  static_assert(std::same_as<DestroyManager<VkCommandBuffer>::Context,
                             std::tuple<VkDevice, VkCommandPool>>);
  // destroySingle<VkBuffer, PFN_vkDestroyBuffer, vkDestroyBuffer>(0, { 0 });
  // destroyMulti<VkCommandBuffer, PFN_vkFreeCommandBuffers,
  // vkFreeCommandBuffers>(
  // std::array{ VkCommandBuffer(0) }, { 0, 0 });
  auto info = VkBufferCreateInfo{};
  auto d = Buffer{ VkDevice(), info };
  // auto info = VkCommandBufferAllocateInfo{};
  auto e = CommandBuffer{ VkDevice(), VkCommandBufferAllocateInfo{} };
  auto f = Pipeline{};

  // CustomConstructorImpl<VkBuffer>(
  // std::tuple<VkDevice, const VkBufferCreateInfo&>{ VkDevice(),
  //                                                  VkBufferCreateInfo{} },
  // std::make_index_sequence<2>());
  // vkAllocateCommandBuffers(VkDevice                           device,
  //                          const VkCommandBufferAllocateInfo*
  //                          pAllocateInfo, VkCommandBuffer*
  //                          pCommandBuffers);
  // vkCreateGraphicsPipelines(VkDevice                            device,
  //                           VkPipelineCache pipelineCache, uint32_t
  //                           createInfoCount, const
  //                           VkGraphicsPipelineCreateInfo* pCreateInfos,
  //                           const VkAllocationCallbacks*        pAllocator,
  //                           VkPipeline* pPipelines);
  // vkCreateDevice(VkPhysicalDevice             physicalDevice,
  //                const VkDeviceCreateInfo*    pCreateInfo,
  //                const VkAllocationCallbacks* pAllocator,
  //                VkDevice*                    pDevice);
  // vkFreeCommandBuffers(VkDevice               device,
  //                      VkCommandPool          commandPool,
  //                      uint32_t               commandBufferCount,
  //                      const VkCommandBuffer* pCommandBuffers);
}

} // namespace vk2