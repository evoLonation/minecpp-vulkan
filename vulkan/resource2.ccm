export module vulkan.resource2;

import "vulkan_config.h";
import std;
import toy;

export namespace vk2 {

enum class FactoryIdentity {
  DEFAULT,
  GRAPHIC,
};

template <typename VkHandle>
struct RegisterMeta;
template <typename VkHandle, FactoryIdentity identity>
struct FactoryMeta;

template <typename VkHandle,
          FactoryIdentity identity = FactoryIdentity::DEFAULT>
using Meta = std::conditional_t<identity == FactoryIdentity::DEFAULT,
                                RegisterMeta<VkHandle>,
                                FactoryMeta<VkHandle, identity>>;
template <typename VkHandle>
constexpr auto destroyer = RegisterMeta<VkHandle>::destroyer;
template <typename VkHandle>
constexpr bool destroy_multi = RegisterMeta<VkHandle>::destroy_multi;
template <typename VkHandle, FactoryIdentity identity>
constexpr auto creator = Meta<VkHandle, identity>::creator;
template <typename VkHandle, FactoryIdentity identity>
constexpr bool create_multi = Meta<VkHandle, identity>::create_multi;

template <typename VkHandle, FactoryIdentity identity>
constexpr auto destroy_ctx_mapper =
  Meta<VkHandle, identity>::mapper::destroy_ctx_mapper;
template <typename VkHandle, FactoryIdentity identity>
constexpr auto constructor_mapper =
  Meta<VkHandle, identity>::mapper::constructor_mapper;
template <typename VkHandle, FactoryIdentity identity>
constexpr auto count_mapper = Meta<VkHandle, identity>::mapper::count_mapper;

template <typename Arg>
concept AllocatorArg = std::same_as<Arg, const VkAllocationCallbacks*>;

template <typename VkHandle>
class DestroyManager {
private:
  template <typename, FactoryIdentity, typename>
  friend class OriginFactory;
  static constexpr auto destroyer_ = destroyer<VkHandle>;
  static constexpr auto destroy_multi_ = destroy_multi<VkHandle>;
  template <typename Arg>
  struct Condition {
    static constexpr bool value =
      !AllocatorArg<Arg> &&
      (destroy_multi_
         ? !std::same_as<Arg, const VkHandle*> && !std::same_as<Arg, uint32_t>
         : !std::same_as<Arg, VkHandle>);
  };
  using HandleContainer =
    std::conditional_t<destroy_multi_, std::vector<VkHandle>, VkHandle>;

public:
  using Context = toy::MapTo<
    typename toy::Filter<toy::FuncArgs<decltype(destroyer_)>, Condition>,
    std::decay>::template apply<std::tuple>;

protected:
  HandleContainer handle_;
  Context         context_;

private:
  static constexpr bool has_allocator_ =
    AllocatorArg<typename toy::FuncArgs<decltype(destroyer_)>::template at<-1>>;

  void destroyResource() {
    if constexpr (!destroy_multi_) {
      if (handle_ != VK_NULL_HANDLE) {
        std::apply(
          [&handle = handle_](auto... args) {
            if constexpr (has_allocator_) {
              destroyer_(args..., handle, nullptr);
            } else {
              destroyer_(args..., handle);
            }
          },
          context_);
      }
    } else {
      if (!handle_.empty()) {
        std::apply(
          [&handles = handle_](auto... args) {
            if constexpr (has_allocator_) {
              destroyer_(args..., handles.size(), handles.data(), nullptr);
            } else {
              destroyer_(args..., handles.size(), handles.data());
            }
          },
          context_);
      }
    }
  }

public:
  DestroyManager() {
    if constexpr (!destroy_multi_) {
      handle_ = VK_NULL_HANDLE;
    }
  }
  DestroyManager(const DestroyManager&) = delete;
  DestroyManager(DestroyManager&& resource) {
    if constexpr (!destroy_multi_) {
      handle_ = resource.handle_;
      resource.handle_ = VK_NULL_HANDLE;
    } else {
      handle_ = std::move(resource.handle_);
    }
  }
  auto operator=(const DestroyManager&) -> DestroyManager& = delete;
  auto operator=(DestroyManager&& resource) -> DestroyManager& {
    destroyResource();
    if constexpr (!destroy_multi_) {
      handle_ = resource.handle_;
      resource.handle_ = VK_NULL_HANDLE;
    } else {
      handle_ = std::move(resource.handle_);
    }
  }
  ~DestroyManager() { destroyResource(); }
};

template <typename VkHandle,
          FactoryIdentity identity = FactoryIdentity::DEFAULT,
          typename ConstructArgPack =
            toy::FuncArgs<decltype(constructor_mapper<VkHandle, identity>)>>
class OriginFactory;
template <typename VkHandle,
          FactoryIdentity identity,
          typename... ConstructArgs>
class OriginFactory<VkHandle, identity, toy::TypePack<ConstructArgs...>> {
private:
  static constexpr auto creator_ = creator<VkHandle, identity>;
  static constexpr auto create_multi_ = create_multi<VkHandle, identity>;
  static constexpr auto destroy_multi_ = destroy_multi<VkHandle>;
  static constexpr auto destroy_ctx_mapper_ =
    destroy_ctx_mapper<VkHandle, identity>;
  static constexpr auto constructor_mapper_ =
    constructor_mapper<VkHandle, identity>;
  static constexpr bool has_allocator_ =
    AllocatorArg<typename toy::FuncArgs<decltype(creator_)>::template at<-2>>;

  using Resource = DestroyManager<VkHandle>;

public:
  OriginFactory() = delete;
  static auto create(ConstructArgs... args) {
    auto origin_args = constructor_mapper_(args...);
    auto context = destroy_ctx_mapper_(args...);
    if constexpr (!create_multi_) {
      return std::apply(
        // 这里使用auto是因为这里的args是直接传给vkApi的，
        // 用值传递的开销是最小的（即使是CreateInfo也已经转成了指针）
        [&context](auto... args) {
          auto resource = Resource{};
          auto handle = VkHandle{};
          if constexpr (has_allocator_) {
            creator_(args..., nullptr, &handle);
          } else {
            creator_(args..., &handle);
          }
          if constexpr (destroy_multi_) {
            resource.handle_.push_back(handle);
          } else {
            resource.handle_ = handle;
          }
          resource.context_ = std::forward<decltype(context)>(context);
          return resource;
        },
        origin_args);
    } else {
      return std::apply(
        [&context,
         count = count_mapper<VkHandle, identity>(args...)](auto... args) {
          auto handles = std::vector<VkHandle>(count);
          if constexpr (has_allocator_) {
            creator_(args..., nullptr, handles.data());
          } else {
            creator_(args..., handles.data());
          }
          if constexpr (destroy_multi_) {
            auto resource = Resource{};
            resource.handle_ = std::move(handles);
            resource.context_ = std::forward<decltype(context)>(context);
            return resource;
          } else {
            auto resources = std::vector<Resource>(count);
            for (auto [handle, resource] : views::zip(handles, resources)) {
              resource.handle_ = handle;
              resource.context_ = context;
            }
            return resources;
          }
        },
        origin_args);
    }
  }
};

template <typename Arg>
concept IsConstPointer =
  std::is_pointer_v<Arg> && std::is_const_v<std::remove_pointer_t<Arg>>;

template <typename VkHandle, FactoryIdentity identity>
struct ConstructArgPackS {
private:
  using Creator = decltype(creator<VkHandle, identity>);
  template <typename Arg>
  struct Condition {
    static constexpr bool value =
      !AllocatorArg<Arg> && !std::same_as<Arg, VkHandle*>;
  };
  template <typename Arg>
  struct Mapper {
    using type =
      std::conditional_t<IsConstPointer<Arg>, std::remove_pointer_t<Arg>&, Arg>;
    ;
  };

public:
  using type =
    toy::MapTo<toy::Filter<toy::FuncArgs<Creator>, Condition>, Mapper>;
};
template <typename VkHandle, FactoryIdentity identity>
using ConstructArgPack = ConstructArgPackS<VkHandle, identity>::type;
/**
 * @brief 根据提供的creator得到construct_mapper，实现为将引用转换为指针
 */
template <typename VkHandle,
          FactoryIdentity identity = FactoryIdentity::DEFAULT,
          typename ConstructArgPack = ConstructArgPack<VkHandle, identity>>
struct AutoConstructorMapper;
template <typename VkHandle,
          FactoryIdentity identity,
          typename... ConstructArgs>
struct AutoConstructorMapper<VkHandle,
                             identity,
                             toy::TypePack<ConstructArgs...>> {
  template <typename ConstructArg>
  static auto argMapper(ConstructArg arg) {
    if constexpr (std::is_lvalue_reference_v<ConstructArg>) {
      return &arg;
    } else {
      return arg;
    }
  }
  static constexpr auto operator()(ConstructArgs... args) {
    return std::tuple{ argMapper<ConstructArgs>(args)... };
  }
};

consteval auto normalMapper() {
  return [](auto context_handle, const auto& create_info) {
    return std::tuple{ context_handle };
  };
}
template <typename CreateInfo, typename PoolHandle>
consteval auto poolMapper(uint32_t CreateInfo::*count_member,
                          PoolHandle CreateInfo::*pool_member) {
  return
    [pool_member, count_member](auto context_handle, const auto& create_info) {
      return std::pair{ std::tuple{ context_handle, create_info.*pool_member },
                        create_info.*count_member };
    };
}

template <typename VkHandle>
struct NormalMapper {
  static constexpr auto destroy_ctx_mapper = normalMapper();
  static constexpr auto constructor_mapper = AutoConstructorMapper<VkHandle>{};
};

template <typename VkHandle, auto count_member, auto pool_member>
struct PoolMapper;
template <typename VkHandle,
          typename AllocateInfo,
          typename PoolHandle,
          uint32_t AllocateInfo::*count_member,
          PoolHandle AllocateInfo::*pool_member>
struct PoolMapper<VkHandle, count_member, pool_member> {
  template <bool is_count>
  consteval static auto generic_mapper() {
    return [](auto context_handle, const AllocateInfo& allocate_info) {
      if constexpr (!is_count) {
        return std::tuple{ context_handle, allocate_info.*pool_member };
      } else {
        return allocate_info.*count_member;
      }
    };
  }
  static constexpr auto destroy_ctx_mapper = generic_mapper<false>();
  static constexpr auto count_mapper = generic_mapper<true>();
  static constexpr auto constructor_mapper = AutoConstructorMapper<VkHandle>{};
};

template <typename VkHandle, FactoryIdentity identity>
struct PipelineMapper {
  using CreateInfo = std::remove_pointer_t<typename toy::FuncArgs<
    decltype(creator<VkHandle, identity>)>::template at<3>>;

  template <int type>
  consteval static auto generic_mapper() {
    return [](VkDevice              context_handle,
              VkPipelineCache       cache,
              std::span<CreateInfo> create_infos) {
      if constexpr (type == 1) {
        return std::tuple{ context_handle };
      } else if constexpr (type == 2) {
        return create_infos.size();
      } else {
        return std::tuple{
          context_handle, cache, create_infos.size(), create_infos.data()
        };
      }
    };
  }
  static constexpr auto destroy_ctx_mapper = generic_mapper<1>();
  static constexpr auto count_mapper = generic_mapper<2>();
  static constexpr auto constructor_mapper = generic_mapper<3>();
};

template <>
struct RegisterMeta<VkBuffer> {
  static constexpr auto creator = vkCreateBuffer;
  static constexpr auto create_multi = false;
  static constexpr auto destroyer = vkDestroyBuffer;
  static constexpr auto destroy_multi = false;
  using mapper = NormalMapper<VkBuffer>;
};
template <>
struct RegisterMeta<VkCommandBuffer> {
  static constexpr auto creator = vkAllocateCommandBuffers;
  static constexpr auto create_multi = true;
  static constexpr auto destroyer = vkFreeCommandBuffers;
  static constexpr auto destroy_multi = true;
  using mapper = PoolMapper<VkCommandBuffer,
                            &VkCommandBufferAllocateInfo::commandBufferCount,
                            &VkCommandBufferAllocateInfo::commandPool>;
};
template <>
struct RegisterMeta<VkPipeline> {
  static constexpr auto creator = vkCreateGraphicsPipelines;
  static constexpr auto create_multi = true;
  static constexpr auto destroyer = vkDestroyPipeline;
  static constexpr auto destroy_multi = false;
};
template <typename VkHandle, FactoryIdentity identity>
struct FactoryMeta;
template <>
struct FactoryMeta<VkPipeline, FactoryIdentity::GRAPHIC> {
  static constexpr auto creator = vkCreateGraphicsPipelines;
  static constexpr auto create_multi = true;
  using mapper = PipelineMapper<VkPipeline, FactoryIdentity::GRAPHIC>;
};
using Buffer = OriginFactory<VkBuffer>;
using CommandBuffer = OriginFactory<VkCommandBuffer>;
using GraphicPipelineFactory =
  OriginFactory<VkPipeline, FactoryIdentity::GRAPHIC>;
void test() {
  bool a =
    std::same_as<toy::FuncArgs<decltype(RegisterMeta<VkPipeline>::destroyer)>::
                   template at<-1>,
                 const VkAllocationCallbacks*>;

  static_assert(
    std::same_as<DestroyManager<VkBuffer>::Context, std::tuple<VkDevice>>);
  static_assert(std::same_as<DestroyManager<VkCommandBuffer>::Context,
                             std::tuple<VkDevice, VkCommandPool>>);
  // destroySingle<VkBuffer, PFN_vkDestroyBuffer, vkDestroyBuffer>(0, { 0 });
  // destroyMulti<VkCommandBuffer, PFN_vkFreeCommandBuffers,
  // vkFreeCommandBuffers>(
  // std::array{ VkCommandBuffer(0) }, { 0, 0 });
  auto info = VkBufferCreateInfo{};
  auto d = Buffer::create(VkDevice(), info);
  auto e = CommandBuffer::create(VkDevice(), VkCommandBufferAllocateInfo{});
  auto f = GraphicPipelineFactory::create(
    VkDevice(), VkPipelineCache(),
    std::vector<VkGraphicsPipelineCreateInfo>{});
  // auto e = create_multi<VkBuffer, FactoryIdentity::DEFAULT>;
  // auto d = Buffer::create();

  // auto info = VkCommandBufferAllocateInfo{};
  // auto e = CommandBuffer{ VkDevice(), VkCommandBufferAllocateInfo{} };
  // auto f = Pipeline{};

  // CustomConstructorImpl<VkBuffer>(
  // std::tuple<VkDevice, const VkBufferCreateInfo&>{ VkDevice(),
  //                                                  VkBufferCreateInfo{} },
  // std::make_index_sequence<2>());
  // vkAllocateCommandBuffers(VkDevice                           device,
  //                          const VkCommandBufferAllocateInfo*
  //                          pAllocateInfo, VkCommandBuffer*
  //                          pCommandBuffers);
  // vkCreateGraphicsPipelines(VkDevice                            device,
  //                           VkPipelineCache pipelineCache, uint32_t
  //                           createInfoCount, const
  //                           VkGraphicsPipelineCreateInfo* pCreateInfos,
  //                           const VkAllocationCallbacks*        pAllocator,
  //                           VkPipeline* pPipelines);
  // vkCreateDevice(VkPhysicalDevice             physicalDevice,
  //                const VkDeviceCreateInfo*    pCreateInfo,
  //                const VkAllocationCallbacks* pAllocator,
  //                VkDevice*                    pDevice);
  // vkFreeCommandBuffers(VkDevice               device,
  //                      VkCommandPool          commandPool,
  //                      uint32_t               commandBufferCount,
  //                      const VkCommandBuffer* pCommandBuffers);
}

} // namespace vk2