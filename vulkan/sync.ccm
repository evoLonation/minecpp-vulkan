export module vulkan.sync;

import "vulkan_config.h";
import vulkan.resource;
import vulkan.tool;
import std;
import toy;

export namespace vk {

auto createSemaphore(VkDevice device) -> Semaphore {
  VkSemaphoreCreateInfo create_info{
    .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,

  };
  return Semaphore{ device, create_info };
}
auto createFence(VkDevice device, bool signaled) -> Fence {
  VkFenceCreateInfo create_info{
    .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
  };
  if (signaled) {
    create_info.flags = VK_FENCE_CREATE_SIGNALED_BIT;
  }
  return Fence{ device, create_info };
}

void waitFence(VkDevice device, VkFence fence) {
  checkVkResult(
    vkWaitForFences(device, 1, &fence, VK_TRUE, std::numeric_limits<uint64_t>::max()), "wait fences"
  );
}

void resetFence(VkDevice device, VkFence fence) {
  checkVkResult(vkResetFences(device, 1, &fence), "reset fence");
}

/**
 * VK_SUCCESS: The fence specified by fence is signaled.
 * VK_NOT_READY: The fence specified by fence is unsignaled.
 * VK_ERROR_DEVICE_LOST: The device has been lost. See Lost Device.
 */
auto isFenceSignaled(VkDevice device, VkFence fence) -> bool {
  auto result = vkGetFenceStatus(device, fence);
  if (result == VK_SUCCESS) {
    return true;
  } else if (result == VK_NOT_READY) {
    return false;
  } else {
    vk::checkVkResult(result, "get fence status");
  }
  std::unreachable();
}

struct ScopeInfo {
  VkPipelineStageFlags stage_mask;
  VkAccessFlags        access_mask;
};
enum class ImageUse {
  UNDEFINED,
  COPY_DST,
  FRAGMENT_SAMPLER,
};
enum class BufferUse {
  COPY_DST,
  VERTEX_BUFFER_DRAW,
  INDEX_BUFFER_DRAW,
};

auto getBufferSyncInfo(BufferUse use) -> ScopeInfo {
  switch (use) {
  case BufferUse::COPY_DST:
    return { .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
             .access_mask = VK_ACCESS_TRANSFER_WRITE_BIT };
    break;
  case BufferUse::VERTEX_BUFFER_DRAW:
    return { .stage_mask = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
             .access_mask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT };
    break;
  case BufferUse::INDEX_BUFFER_DRAW:
    return { .stage_mask = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
             .access_mask = VK_ACCESS_INDEX_READ_BIT };
    break;
  }
}
auto getImageSyncInfo(bool is_dst, ImageUse use) -> std::pair<ScopeInfo, VkImageLayout> {
  switch (use) {
  case ImageUse::UNDEFINED:
    return { { .stage_mask =
                 is_dst ? VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT : VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
               .access_mask = VK_ACCESS_NONE },
             VK_IMAGE_LAYOUT_UNDEFINED };
    break;
  case ImageUse::COPY_DST:
    return { { .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
               .access_mask = VK_ACCESS_TRANSFER_WRITE_BIT },
             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL };
    break;
  case ImageUse::FRAGMENT_SAMPLER:
    return { { .stage_mask = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
               .access_mask = VK_ACCESS_SHADER_READ_BIT },
             VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL };
    break;
  }
}

void recordPipelineBarrier(
  VkCommandBuffer                                       cmdbuf,
  std::pair<VkPipelineStageFlags, VkPipelineStageFlags> stage_mask,
  std::span<const VkMemoryBarrier>                      memory_barriers,
  std::span<const VkBufferMemoryBarrier>                buffer_barriers,
  std::span<const VkImageMemoryBarrier>                 image_barriers
) {
  vkCmdPipelineBarrier(
    cmdbuf,
    stage_mask.first,
    stage_mask.second,
    //  VK_DEPENDENCY_BY_REGION_BIT:
    //  实现可以分区域进行同步(前面写一部分，后面就可以先读一部分)
    VK_DEPENDENCY_BY_REGION_BIT,
    memory_barriers.size(),
    memory_barriers.data(),
    buffer_barriers.size(),
    buffer_barriers.data(),
    image_barriers.size(),
    image_barriers.data()
  );
};
void recordBufferBarrier_(
  VkCommandBuffer cmdbuf,
  VkBuffer        buffer,
  ScopeInfo       src_scope,
  ScopeInfo       dst_scope,
  uint32_t        src_family,
  uint32_t        dst_family
) {
  auto buffer_barrier = VkBufferMemoryBarrier{
    .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    .pNext = nullptr,
    .srcAccessMask = src_scope.access_mask,
    .dstAccessMask = dst_scope.access_mask,
    .srcQueueFamilyIndex = src_family,
    .dstQueueFamilyIndex = dst_family,
    .buffer = buffer,
    .offset = 0,
    .size = VK_WHOLE_SIZE,
  };
  recordPipelineBarrier(
    cmdbuf, { src_scope.stage_mask, dst_scope.stage_mask }, {}, { &buffer_barrier, 1 }, {}
  );
}
void recordImageBarrier_(
  VkCommandBuffer       cmdbuf,
  VkImage               image,
  VkImageAspectFlagBits aspect,
  VkImageLayout         src_layout,
  VkImageLayout         dst_layout,
  ScopeInfo             src_scope,
  ScopeInfo             dst_scope,
  uint32_t              src_family,
  uint32_t              dst_family
) {
  auto image_barrier = VkImageMemoryBarrier{
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    .pNext = nullptr,
    .srcAccessMask = src_scope.access_mask,
    .dstAccessMask = dst_scope.access_mask,
    .oldLayout = src_layout,
    .newLayout = dst_layout,
    .srcQueueFamilyIndex = src_family,
    .dstQueueFamilyIndex = dst_family,
    .image = image,
    .subresourceRange =
      VkImageSubresourceRange{
        .aspectMask = aspect,
        .baseMipLevel = 0,
        .levelCount = 1,
        .baseArrayLayer = 0,
        .layerCount = 1,
      },
  };
  recordPipelineBarrier(
    cmdbuf, { src_scope.stage_mask, dst_scope.stage_mask }, {}, {}, { &image_barrier, 1 }
  );
}

struct BarrierScopeInfo {
  ScopeInfo src_scope;
  ScopeInfo dst_scope;
};

/**
 * @brief 对于所有权转移，需要分别在src family和dst family处各record一次barrier
 * 要想建立release op到acquire op的同步，只能在第一个submit设置signal sema
 * 并对应设置wait sema到第二个submit；
 * 而signal sema只有所有命令执行完后进行signal，wait sema可以设置wait的stage
 * 因此：
 * - 对于src family的record：将dstStageMask设置为BOTTOM即可；
 * - 对于dst family的record：另srcStageMask=dstStageMask
 * 从而实现release->bottom(submit)->target(submit)->target的依赖链
 */
struct TransferScopeInfo {
  BarrierScopeInfo src_barrier;
  BarrierScopeInfo dst_barrier;

  TransferScopeInfo(BarrierScopeInfo scope_info) {
    auto [src_scope, dst_scope] = scope_info;
    src_barrier = BarrierScopeInfo{
      .src_scope =
        ScopeInfo{
          .stage_mask = src_scope.stage_mask,
          .access_mask = src_scope.access_mask,
        },
      .dst_scope =
        ScopeInfo{
          .stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
          .access_mask = 0,
        },
    };
    dst_barrier = BarrierScopeInfo{
      .src_scope =
        ScopeInfo{
          .stage_mask = dst_scope.stage_mask,
          .access_mask = 0,
        },
      .dst_scope =
        ScopeInfo{
          .stage_mask = dst_scope.stage_mask,
          .access_mask = dst_scope.access_mask,
        },
    };
  }
};

struct ImageBarrierUseInfo {
  ImageUse src_use;
  ImageUse dst_use;
};

struct BufferBarrierUseInfo {
  BufferUse src_use;
  BufferUse dst_use;
};

struct TransferFamilyInfo {
  uint32_t src_family;
  uint32_t dst_family;
};

struct Transfer {
  std::function<void(VkCommandBuffer)> src_recorder;
  std::function<void(VkCommandBuffer)> dst_recorder;
  VkPipelineStageFlags                 dst_wait_stage;
};

void recordBufferBarrier(VkCommandBuffer cmdbuf, VkBuffer buffer, BufferBarrierUseInfo use_info) {
  recordBufferBarrier_(
    cmdbuf,
    buffer,
    getBufferSyncInfo(use_info.src_use),
    getBufferSyncInfo(use_info.dst_use),
    VK_QUEUE_FAMILY_IGNORED,
    VK_QUEUE_FAMILY_IGNORED
  );
}

auto getBufferTransfer(
  VkBuffer buffer, BufferBarrierUseInfo use_info, TransferFamilyInfo family_info
) -> Transfer {
  auto scope_info = TransferScopeInfo{ {
    .src_scope = getBufferSyncInfo(use_info.src_use),
    .dst_scope = getBufferSyncInfo(use_info.dst_use),
  } };
  return Transfer{
    .src_recorder =
      [scope_info = scope_info.src_barrier, buffer, family_info](VkCommandBuffer cmdbuf) {
        recordBufferBarrier_(
          cmdbuf,
          buffer,
          scope_info.src_scope,
          scope_info.dst_scope,
          family_info.src_family,
          family_info.dst_family
        );
      },
    .dst_recorder =
      [scope_info = scope_info.dst_barrier, buffer, family_info](VkCommandBuffer cmdbuf) {
        recordBufferBarrier_(
          cmdbuf,
          buffer,
          scope_info.src_scope,
          scope_info.dst_scope,
          family_info.src_family,
          family_info.dst_family
        );
      },
    .dst_wait_stage = scope_info.dst_barrier.src_scope.stage_mask
  };
}

void recordImageBarrier(
  VkCommandBuffer cmdbuf, VkImage image, VkImageAspectFlagBits aspect, ImageBarrierUseInfo use_info
) {
  auto [src_scope, src_layout] = getImageSyncInfo(false, use_info.src_use);
  auto [dst_scope, dst_layout] = getImageSyncInfo(true, use_info.dst_use);
  recordImageBarrier_(
    cmdbuf,
    image,
    aspect,
    src_layout,
    dst_layout,
    src_scope,
    dst_scope,
    VK_QUEUE_FAMILY_IGNORED,
    VK_QUEUE_FAMILY_IGNORED
  );
}

auto getImageTransfer(
  VkImage               image,
  VkImageAspectFlagBits aspect,
  ImageBarrierUseInfo   use_info,
  TransferFamilyInfo    family_info
) -> Transfer {
  auto [src_scope, src_layout] = getImageSyncInfo(false, use_info.src_use);
  auto [dst_scope, dst_layout] = getImageSyncInfo(true, use_info.dst_use);
  auto scope_info = TransferScopeInfo{ {
    .src_scope = src_scope,
    .dst_scope = dst_scope,
  } };
  return Transfer{
    .src_recorder =
      [scope_info = scope_info.src_barrier, image, family_info, src_layout, dst_layout, aspect](
        VkCommandBuffer cmdbuf
      ) {
        recordImageBarrier_(
          cmdbuf,
          image,
          aspect,
          src_layout,
          dst_layout,
          scope_info.src_scope,
          scope_info.dst_scope,
          family_info.src_family,
          family_info.dst_family
        );
      },
    .dst_recorder =
      [scope_info = scope_info.dst_barrier, image, family_info, src_layout, dst_layout, aspect](
        VkCommandBuffer cmdbuf
      ) {
        recordImageBarrier_(
          cmdbuf,
          image,
          aspect,
          src_layout,
          dst_layout,
          scope_info.src_scope,
          scope_info.dst_scope,
          family_info.src_family,
          family_info.dst_family
        );
      },
    .dst_wait_stage = scope_info.dst_barrier.src_scope.stage_mask
  };
}

} // namespace vk