export module vulkan.sync;

import "vulkan_config.h";
import vulkan.resource;
import vulkan.tool;
import std;
import toy;

export namespace vk {

auto createSemaphore(VkDevice device) -> Semaphore {
  VkSemaphoreCreateInfo create_info{
    .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,

  };
  return Semaphore{ device, create_info };
}
auto createFence(VkDevice device, bool signaled) -> Fence {
  VkFenceCreateInfo create_info{
    .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
  };
  if (signaled) {
    create_info.flags = VK_FENCE_CREATE_SIGNALED_BIT;
  }
  return Fence{ device, create_info };
}

/**
 * @brief 等待一个fence，等待结束后reset
 */
void consumeFence(VkDevice device, VkFence fence) {
  checkVkResult(
    vkWaitForFences(device, 1, &fence, VK_TRUE, std::numeric_limits<uint64_t>::max()), "wait fences"
  );
  checkVkResult(vkResetFences(device, 1, &fence), "reset fence");
}

void recordPipelineBarrier(
  VkCommandBuffer                                       cmdbuf,
  std::pair<VkPipelineStageFlags, VkPipelineStageFlags> stage_mask,
  std::span<const VkMemoryBarrier>                      memory_barriers,
  std::span<const VkBufferMemoryBarrier>                buffer_barriers,
  std::span<const VkImageMemoryBarrier>                 image_barriers
) {
  vkCmdPipelineBarrier(
    cmdbuf,
    stage_mask.first,
    stage_mask.second,
    //  VK_DEPENDENCY_BY_REGION_BIT:
    //  实现可以分区域进行同步(前面写一部分，后面就可以先读一部分)
    VK_DEPENDENCY_BY_REGION_BIT,
    memory_barriers.size(),
    memory_barriers.data(),
    buffer_barriers.size(),
    buffer_barriers.data(),
    image_barriers.size(),
    image_barriers.data()
  );
};

struct ScopeInfo {
  VkPipelineStageFlags stage_mask;
  VkAccessFlags        access_mask;
};
struct FamilyTransferInfo {
  uint32_t src_family;
  uint32_t dst_family;
};
enum class ImageUse {
  UNDEFINED,
  COPY_DST,
  FRAGMENT_SAMPLER,
};
enum class BufferUse {
  COPY_DST,
  VERTEX_BUFFER_DRAW,
  INDEX_BUFFER_DRAW,
};

auto getBufferSyncInfo(BufferUse use) -> ScopeInfo {
  switch (use) {
  case BufferUse::COPY_DST:
    return { .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
             .access_mask = VK_ACCESS_TRANSFER_WRITE_BIT };
    break;
  case BufferUse::VERTEX_BUFFER_DRAW:
    return { .stage_mask = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
             .access_mask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT };
    break;
  case BufferUse::INDEX_BUFFER_DRAW:
    return { .stage_mask = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
             .access_mask = VK_ACCESS_INDEX_READ_BIT };
    break;
  default:
    std::unreachable();
    break;
  }
}
auto getImageSyncInfo(bool is_dst, ImageUse use) -> std::pair<ScopeInfo, VkImageLayout> {
  switch (use) {
  case ImageUse::UNDEFINED:
    return { { .stage_mask =
                 is_dst ? VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT : VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
               .access_mask = VK_ACCESS_NONE },
             VK_IMAGE_LAYOUT_UNDEFINED };
    break;
  case ImageUse::COPY_DST:
    return { { .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
               .access_mask = VK_ACCESS_TRANSFER_WRITE_BIT },
             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL };
    break;
  case ImageUse::FRAGMENT_SAMPLER:
    return { { .stage_mask = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
               .access_mask = VK_ACCESS_SHADER_READ_BIT },
             VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL };
    break;
  default:
    std::unreachable();
    break;
  }
}

template <typename VkHandle>
using UseEnumOf = std::conditional_t<std::same_as<VkHandle, VkImage>, ImageUse, BufferUse>;

struct BarrierCommonInfo {
  ScopeInfo          src_scope;
  ScopeInfo          dst_scope;
  FamilyTransferInfo family_transfer;
};

/**
 * @param family_transfer : bool 代表是否在transfer的dst
 */
auto getBarrierCommonInfo(
  std::pair<ScopeInfo, ScopeInfo>                    scope,
  std::optional<std::pair<FamilyTransferInfo, bool>> family_transfer
) -> BarrierCommonInfo {

  /**
   * @brief 对于所有权转移，需要分别在src family和dst family处各record一次barrier
   * 要想建立release op到acquire op的同步，只能在第一个submit设置signal sema
   * 并对应设置wait sema到第二个submit；
   * 而signal sema只有所有命令执行完后进行signal，wait sema可以设置wait的stage
   * 因此：
   * - 对于src family的record：将dstStageMask设置为BOTTOM即可；
   * - 对于dst family的record：另srcStageMask=dstStageMask
   * 从而实现release->bottom(submit)->target(submit)->target的依赖链
   */
  auto get_access_mask = [&](auto src_access_mask, auto dst_access_mask) {
    using ret = std::pair<VkAccessFlags, VkAccessFlags>;
    if (family_transfer.has_value()) {
      return family_transfer->second ? ret{ VK_ACCESS_NONE, dst_access_mask }
                                     : ret{ src_access_mask, VK_ACCESS_NONE };
    }
    return ret{ src_access_mask, dst_access_mask };
  };
  auto get_stage_mask = [&](
                          auto src_stage_mask, auto dst_stage_mask
                        ) -> std::pair<VkPipelineStageFlags, VkPipelineStageFlags> {
    using ret = std::pair<VkPipelineStageFlags, VkPipelineStageFlags>;
    if (family_transfer.has_value()) {
      return family_transfer->second ? ret{ dst_stage_mask, dst_stage_mask }
                                     : ret{ src_stage_mask, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT };
    }
    return ret{ src_stage_mask, dst_stage_mask };
  };
  auto get_family = [&](bool is_dst) -> uint32_t {
    if (family_transfer.has_value()) {
      return is_dst ? family_transfer->first.dst_family : family_transfer->first.src_family;
    }
    return VK_QUEUE_FAMILY_IGNORED;
  };

  auto [src_access_mask, dst_access_mask] =
    get_access_mask(scope.first.access_mask, scope.second.access_mask);
  auto [src_stage_mask, dst_stage_mask] =
    get_stage_mask(scope.first.stage_mask, scope.second.stage_mask);
  return {
    .src_scope =
      ScopeInfo{
        .stage_mask = src_stage_mask,
        .access_mask = src_access_mask,
      },
    .dst_scope =
      ScopeInfo{
        .stage_mask = dst_stage_mask,
        .access_mask = dst_access_mask,
      },
    .family_transfer =
      FamilyTransferInfo{
        .src_family =
          family_transfer.has_value() ? family_transfer->first.src_family : VK_QUEUE_FAMILY_IGNORED,
        .dst_family =
          family_transfer.has_value() ? family_transfer->first.dst_family : VK_QUEUE_FAMILY_IGNORED,
      },
  };
}

} // namespace vk