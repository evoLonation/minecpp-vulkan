module;
#include "vulkan_config.h"

export module vulkan;

import std;
import tool;
import log;

namespace ranges = std::ranges;
namespace views = std::views;
using namespace tool;
using namespace log;

export {

template <typename F, typename... Args>
  requires std::invocable<F, Args &&..., uint32_t *,
                          FuncArg<sizeof...(Args) + 1, F>>
auto getVkResource(F func, Args &&...args) {
  uint32_t count;
  func(std::forward<Args>(args)..., &count, nullptr);
  std::vector<std::remove_pointer_t<FuncArg<sizeof...(Args) + 1, F>>> resources;
  resources.resize(count);
  func(args..., &count, resources.data());
  return resources;
}

void checkVkResult(VkResult vk_result, std::string_view action) {
  if (vk_result != VK_SUCCESS) {
    throwf("failed to {}", action);
  }
}

template <typename F, typename... Args>
  requires std::same_as<FuncArg<sizeof...(Args), F>,
                        const VkAllocationCallbacks *> &&
           std::invocable<F, Args &&..., const VkAllocationCallbacks *,
                          FuncArg<sizeof...(Args) + 1, F>>
auto createVkResource(F func, std::string_view name, Args && ...args) {
  using ResourceTypeHandle =
      std::remove_pointer_t<FuncArg<sizeof...(Args) + 1, F>>;
  ResourceTypeHandle resource;
  checkVkResult(func(std::forward<Args>(args)..., nullptr, &resource),
                std::format("create {}", name));
  return resource;
}
template <typename F, typename... Args>
  requires std::is_invocable_r_v<VkResult, F, Args &&...,
                                 FuncArg<sizeof...(Args), F>>
auto createVkResource(F func, std::string_view name, Args && ...args) {
  using ResourceTypeHandle = std::remove_pointer_t<FuncArg<sizeof...(Args), F>>;
  ResourceTypeHandle resource;
  checkVkResult(func(std::forward<Args>(args)..., &resource),
                std::format("create {}", name));
  return resource;
}

template <ranges::range RequiredRange, ranges::range AvailableRange,
          typename Mapper>
  requires RangeOf<RequiredRange, const char *> &&
           std::is_invocable_r_v<std::string_view, Mapper,
                                 ranges::range_reference_t<AvailableRange>>
void checkAvaliableSupports(RequiredRange &&required_range,
                            AvailableRange &&available_range,
                            std::string_view support_name, Mapper &&mapper) {
  debugf("the required {} {} are :\n {::}", required_range.size(),
         support_name, required_range);
	debugf("the available {} {} are :\n {::}", available_range.size(),
         support_name, available_range);
  auto unsupported_range =
      required_range |
      views::filter([&available_range, &mapper](const auto &required) {
        return ranges::none_of(
            available_range,
            [&required](auto extension) { return extension == required; },
            [&mapper](auto &extension) {
              return std::string_view{mapper(extension)};
            });
      });
  if (!unsupported_range.empty()) {
    throwf("these {} requested but not available: \n{::}", support_name,
           unsupported_range);
  }
}

template <typename T>
concept CustomFormatter = std::is_same_v<T, VkExtensionProperties> ||
                          std::is_same_v<T, VkLayerProperties>;

template <CustomFormatter T>
class std::formatter<T> : public std::formatter<std::string> {
public:
  template <typename FormatContext, typename... Args>
  auto format(const T &e, FormatContext &ctx) const {
    return std::formatter<std::string>::format(formatString(e), ctx);
  }

private:
  auto formatString(const T &e) const -> std::string {
    if constexpr (std::same_as<T, VkExtensionProperties>) {
      return std::format("{} (version {})", e.extensionName, e.specVersion);
    } else if constexpr (std::same_as<T, VkLayerProperties>) {
      return std::format(
          "{} (spec version {}, implementation version {}) : {} ", e.layerName,
          e.specVersion, e.implementationVersion, e.description);
    } else {
      throw 0;
    }
  }
};


/*
 * glfw window 相关
 */

auto createWindow(uint32_t width, uint32_t height, std::string_view title)
    ->GLFWwindow *;
void destroyWindow(GLFWwindow *p_window) noexcept;

// 抛出glfw的报错（如果有的话）
void checkGlfwError();

/*
 * instance, extension, layer相关
 * instance: vulkan最底层的对象，一切皆源于instance，存储几乎所有状态
 */
struct DebugMessengerInfo{
  VkDebugUtilsMessageSeverityFlagBitsEXT message_severity_level;
  VkDebugUtilsMessageTypeFlagsEXT message_type_flags;
};
auto createInstance(std::string_view appName) -> VkInstance;
auto createInstanceAndDebugMessenger(
    std::string_view app_name, PFN_vkDebugUtilsMessengerCallbackEXT callback,
    DebugMessengerInfo& debug_messenger_info)
    -> std::pair<VkInstance, VkDebugUtilsMessengerEXT>;

void destroyInstance(VkInstance instance) noexcept;
void destroyDebugMessenger(VkDebugUtilsMessengerEXT debug_messenger,
                           VkInstance instance) noexcept;
// 获得所有可能需要提供的 instance 级别的 extension
template <bool enableValidLayer>
auto getRequiredInstanceExtensions() -> std::vector<const char *>;
template <bool enableValidLayer>
auto getRequiredLayers() -> std::vector<const char *>;
//需要借助instance 来手动加载 debugMessenger 的create和destroy函数
auto createDebugUtilsMessengerEXT(
    VkInstance instance,
		const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo,
    const VkAllocationCallbacks *pAllocator,
    VkDebugUtilsMessengerEXT *pDebugMessenger) -> VkResult;
void destroyDebugUtilsMessengerEXT(VkInstance instance,
                                   VkDebugUtilsMessengerEXT debugMessenger,
                                   const VkAllocationCallbacks *pAllocator);
template <bool enable_valid_layer>
auto createInstanceTemplate(
    std::string_view appName, PFN_vkDebugUtilsMessengerCallbackEXT callback,
    DebugMessengerInfo* p_debug_messenger_info);
VKAPI_ATTR VkBool32 VKAPI_CALL
debugHandler(VkDebugUtilsMessageSeverityFlagBitsEXT message_severity,
             VkDebugUtilsMessageTypeFlagsEXT message_type,
             const VkDebugUtilsMessengerCallbackDataEXT *p_callback_data,
             void *p_user_data);

/*
 * surface 相关
 * 借助 instance 创建 surface
 */
auto createSurface(VkInstance instance, GLFWwindow *p_window) -> VkSurfaceKHR;
void destroySurface(VkSurfaceKHR surface, VkInstance instance) noexcept;

/*
 * physical device 相关
 * 借助 instance 得到所有 physical device
 * 与 surface 结合得到 physical device 的属性，并选择一个合适的
 * features, queue family indices, extensions 用于创建 logical device
 * surface capability, format, present mode 用于创建 swap chain
 */

using QueueIndexes = std::vector<std::pair<uint32_t, uint32_t>>;
struct PhysicalDeviceInfo{
	VkPhysicalDevice device;
	VkPhysicalDeviceProperties properties;
	VkPhysicalDeviceFeatures features;
	VkSurfaceCapabilitiesKHR capabilities;
	VkPresentModeKHR present_mode;
	VkSurfaceFormatKHR surface_format;
	QueueIndexes queue_indices;
};
struct QueueFamilyCheckContext {
  VkPhysicalDevice device;
  VkSurfaceKHR surface;
  size_t index;
  VkQueueFamilyProperties& properties;
};
struct DeviceCheckContext {
	VkPhysicalDeviceProperties& properties;
	VkPhysicalDeviceFeatures& features;
};
struct SurfaceCheckContext {
	VkSurfaceCapabilitiesKHR& capabilities;
	ranges::ref_view<std::vector<VkPresentModeKHR>> present_modes;
	ranges::ref_view<std::vector<VkSurfaceFormatKHR>> surface_formats;
};
struct SelectedSurfaceInfo {
	VkPresentModeKHR present_mode;
	VkSurfaceFormatKHR surface_format;
};
using SurfaceChecker = std::function<std::optional<SelectedSurfaceInfo>(
    const SurfaceCheckContext &)>;
using DeviceChecker = std::function<bool(const DeviceCheckContext &)>;
using QueueFamilyChecker = std::function<bool(const QueueFamilyCheckContext &)>;
using SurfaceChecker = std::function<std::optional<SelectedSurfaceInfo>(
    const SurfaceCheckContext &)>;

auto pickPhysicalDevice(VkInstance instance, VkSurfaceKHR surface,
                        std::span<const char *> required_extensions,
                        DeviceChecker device_checker,
                        SurfaceChecker surface_checker,
                        std::span<QueueFamilyChecker> queue_chekers)
    -> PhysicalDeviceInfo;

auto getQueueFamilyIndices(VkPhysicalDevice device, VkSurfaceKHR surface,
                           std::span<QueueFamilyChecker> queue_chekers)
    -> std::optional<QueueIndexes>;

auto checkPhysicalDeviceSupport(const DeviceCheckContext &ctx) -> bool;
auto checkSurfaceSupport(const SurfaceCheckContext &ctx)
    -> std::optional<SelectedSurfaceInfo>;
auto checkGraphicQueue(const QueueFamilyCheckContext &ctx) -> bool;
auto checkPresentQueue(const QueueFamilyCheckContext &ctx) -> bool;

/*
 * logical device 相关
 * 创建 logical device, 得到 queue
 */
auto createLogicalDevice(
    const PhysicalDeviceInfo &physical_device_info,
    std::span<const char *> required_extensions)
    -> std::pair<VkDevice, std::vector<VkQueue>>;
void destroyLogicalDevice(VkDevice device) noexcept;

/*
 * swap chain 相关
 */

auto createSwapChain(VkSurfaceKHR surface, VkDevice device,
                     VkSurfaceCapabilitiesKHR capabilities,
                     VkSurfaceFormatKHR surface_format,
                     VkPresentModeKHR present_mode, GLFWwindow *p_window,
                     std::span<uint32_t> queue_family_indices)
    -> std::pair<VkSwapchainKHR, VkExtent2D>;
void destroySwapChain(VkSwapchainKHR swapchain, VkDevice device) noexcept;

auto createImageViews(VkDevice device, VkSwapchainKHR swapchain,
                      VkFormat format)
    ->std::vector<VkImageView>;
void destroyImageViews(std::span<VkImageView> image_views,
                       VkDevice device) noexcept;

/*
 * render pass 相关
 */
auto createRenderPass(VkDevice device, VkFormat format) -> VkRenderPass;
void destroyRenderPass(VkRenderPass render_pass, VkDevice device) noexcept;

/*
 * pipeline 相关
 */
struct PipelineResource {
  VkShaderModule vertex_shader;
  VkShaderModule frag_shader;
  VkPipelineLayout pipeline_layout;
  VkPipeline pipeline;
};

auto createGraphicsPipeline(VkDevice device, VkRenderPass render_pass)
    ->PipelineResource;
void destroyGraphicsPipeline(PipelineResource pipeline_resource,
                             VkDevice device) noexcept;

/*
 * framebuffer 相关
 */
auto createFramebuffers(VkRenderPass render_pass, VkDevice device,
                        VkExtent2D extent, std::span<VkImageView> image_views)
    -> std::vector<VkFramebuffer>;
void destroyFramebuffers(std::span<VkFramebuffer> framebuffers,
                         VkDevice device) noexcept;

/*
* command buffer 相关
*/
auto createCommandPool(VkDevice device, uint32_t graphic_family_index)
    -> VkCommandPool;
void destroyCommandPool(VkCommandPool command_pool, VkDevice device) noexcept;
auto allocateCommandBuffer(VkDevice device, VkCommandPool command_pool,
                           uint32_t count) -> std::vector<VkCommandBuffer>;
void freeCommandBuffer(VkCommandBuffer command_buffer, VkDevice device,
                       VkCommandPool command_pool) noexcept;
                       
} // export