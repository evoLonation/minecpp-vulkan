export module render.resource;

import render.context;

import vulkan;

import <vulkan_config.h>;
import std;
import glm;
import toy;

export namespace render {

class DescriptorResource {
public:
  virtual auto getDescriptorResource() const
    -> std::variant<vk::DescriptorResource, std::vector<vk::DescriptorResource>> = 0;
};

class DeviceLocalResource {
public:
  virtual auto getTransfer(vk::TransferFamilyInfo family_info) const -> vk::Transfer = 0;
};
class ResourceRegister {
private:
  vk::Semaphore      _ownership_transfer_sema;
  vk::CommandBuffers _transfer_cmdbuf;
  vk::CommandBuffers _graphic_cmdbuf;

public:
  ResourceRegister(std::span<const DeviceLocalResource* const> resources) {
    auto& ctx = Context::getInstance();
    _ownership_transfer_sema = vk::createSemaphore(ctx.device);
    _transfer_cmdbuf = vk::allocateCommandBuffers(ctx.device, ctx.transfer_ctx.command_pool, 1);
    _graphic_cmdbuf = vk::allocateCommandBuffers(ctx.device, ctx.graphic_ctx.command_pool, 1);

    auto family_transfer =
      vk::TransferFamilyInfo{ ctx.transfer_ctx.family_index, ctx.graphic_ctx.family_index };

    auto transfers =
      resources |
      views::transform([&](auto* resource) { return resource->getTransfer(family_transfer); }) |
      ranges::to<std::vector>();
    vk::recordAndSubmit(
      _transfer_cmdbuf.get()[0],
      ctx.transfer_ctx.queue,
      [&](auto cmdbuf) {
        for (auto& transfer : transfers) {
          transfer.src_recorder(cmdbuf);
        }
      },
      {},
      { &_ownership_transfer_sema.get(), 1 },
      VK_NULL_HANDLE
    );
    vk::recordAndSubmit(
      _graphic_cmdbuf.get()[0],
      ctx.graphic_ctx.queue,
      [&](auto cmdbuf) {
        for (auto& transfer : transfers) {
          transfer.dst_recorder(cmdbuf);
        }
      },
      std::array{
        std::pair{ _ownership_transfer_sema.get(),
                   std::reduce(
                     transfers.begin(),
                     transfers.end(),
                     VkPipelineStageFlags(0),
                     [&](auto x, auto y) { return x | y.dst_wait_stage; }
                   ) },
      },
      {},
      VK_NULL_HANDLE
    );
  }
};

} // namespace render