export module render.resource;

import render.context;
import render.command;

import vulkan;

import <vulkan_config.h>;
import std;
import glm;
import toy;

export namespace render {

enum class ResourceType { UNIFORM, SAMPLER };

struct ResourceInfo {
  // all worker same, or each worker single resource
  std::variant<vk::DescriptorResource, std::vector<vk::DescriptorResource>> desc_resource;

  ResourceType resource_type;
};

class Resource {
public:
  virtual auto getResourceInfo() -> ResourceInfo = 0;
};

class DeviceLocalResource {
public:
  virtual auto getTransfer(vk::TransferFamilyInfo family_info) -> vk::Transfer = 0;
};
class ResourceRegister {
private:
  vk::Semaphore _ownership_transfer_sema;

public:
  ResourceRegister(std::span<DeviceLocalResource* const> resources) {
    auto& ctx = Context::getInstance();
    _ownership_transfer_sema = vk::createSemaphore(ctx.device);

    auto family_transfer =
      vk::TransferFamilyInfo{ ctx.transfer_ctx.family_index, ctx.graphic_ctx.family_index };

    auto transfers =
      resources |
      views::transform([&](auto* resource) { return resource->getTransfer(family_transfer); }) |
      ranges::to<std::vector>();
    auto& executor = CommandExecutor::getInstance();
    auto  waitable = executor
                      .submit(
                        CommandExecutor::Family::TRANSFER,
                        [&](auto cmdbuf) {
                          for (auto& transfer : transfers) {
                            transfer.src_recorder(cmdbuf);
                          }
                        },
                        {},
                        1
                      )
                      .second;

    executor.submit(
      CommandExecutor::Family::GRAPHICS,
      [&](auto cmdbuf) {
        for (auto& transfer : transfers) {
          transfer.dst_recorder(cmdbuf);
        }
      },
      std::array{
        WaitInfo{ waitable,
                  std::reduce(
                    transfers.begin(),
                    transfers.end(),
                    VkPipelineStageFlags(0),
                    [&](auto x, auto y) { return x | y.dst_wait_stage; }
                  ) },
      },
      0
    );
  }
};

} // namespace render
