export module render.loop;

import render.context;
import "glfw_config.h";
import "vulkan_config.h";
import std;
import toy;

export namespace rd {

class LoopAction {
public:
  virtual void loopAction(uint32_t interval_milli) = 0;
  LoopAction() = default;
};

enum class LoopOrder {
  UPDATE_INPUT = 1,
  EXECUTE_ACTIONS = 2,
  UPDATE_UNIFORM = 998,
  GUI_RENDER = 999,
  DRAWCALL = 1000,
};

namespace chrono = std::chrono;

class Loop : public toy::ProactiveSingleton<Loop> {
private:
  template <LoopOrder>
  friend class LoopActionLoader;
  std::map<LoopOrder, toy::RefContainer<LoopAction>> _action_map;

  chrono::time_point<chrono::high_resolution_clock> _last_time;

public:
  Loop() = default;
  void startLoop() {
    while (!glfwWindowShouldClose(Context::getInstance().window)) {
      auto interval = chrono::high_resolution_clock::now() - _last_time;
      _last_time += interval;
      auto interval_milli_ = chrono::duration_cast<chrono::milliseconds>(interval);
      // toy::debug(interval_milli_);
      auto interval_milli = interval_milli_.count();
      for (auto& [order, container] : _action_map) {
        for (auto& action : container) {
          action.loopAction(interval_milli);
        }
      }
    }
  }
};

template <LoopOrder order>
class LoopActionLoader : public toy::InterfaceLoader<LoopAction> {
public:
  LoopActionLoader() : toy::InterfaceLoader<LoopAction>(Loop::getInstance()._action_map[order]) {}
};

} // namespace rd