export module render.swapchain;

import render.base_context;

import vulkan;

import <vulkan_config.h>;
import std;
import toy;

export namespace rd {

class SwapchainContext {
public:
  vk::Swapchain                    swapchain;
  VkExtent2D                       extent;
  std::vector<VkImage>             images;
  std::vector<vk::ImageView>       image_views;
  vk::ImageResource                depth_image;
  std::optional<vk::ImageResource> sample_image;
  std::vector<vk::Framebuffer>     framebuffers;

private:
  auto tryCreateSwapchain(BaseContext& ctx) {
    return createSwapchain(
      ctx.pdevice_info.device,
      ctx.surface,
      ctx.device,
      ctx.pdevice_info.surface_format,
      ctx.pdevice_info.present_mode,
      ctx.window,
      swapchain
    );
  }
  void createResource(BaseContext& ctx, vk::SwapchainResource swapchain_resource) {
    std::tie(swapchain, extent, images) = std::move(swapchain_resource);
    image_views = images | views::transform([&](VkImage image) {
                    return vk::createImageView(
                      ctx.device,
                      image,
                      ctx.pdevice_info.surface_format.format,
                      vk::ImageType::COLOR_ATTACHMENT,
                      1
                    );
                  }) |
                  ranges::to<std::vector>();
    depth_image = vk::createImage(
      ctx.pdevice_info.device,
      ctx.device,
      ctx.depth_format,
      extent.width,
      extent.height,
      vk::ImageType::DEPTH_STENCIL,
      vk::TransferOption::NONE,
      1,
      ctx.sample_count.value_or(VK_SAMPLE_COUNT_1_BIT)
    );
    if (ctx.sample_count.has_value()) {
      sample_image = vk::createImage(
        ctx.pdevice_info.device,
        ctx.device,
        ctx.pdevice_info.surface_format.format,
        extent.width,
        extent.height,
        vk::ImageType::COLOR_ATTACHMENT,
        vk::TransferOption::NONE,
        1,
        ctx.sample_count.value()
      );
    }
    framebuffers =
      image_views | views::transform([&](auto& image_view) {
        return vk::createFramebuffer(
          ctx.render_pass,
          ctx.device,
          extent,
          image_view,
          depth_image.image_view,
          sample_image.transform([](auto& resource) { return resource.image_view.get(); })
        );
      }) |
      ranges::to<std::vector>();
  }
  auto destroyResource() {
    // move old resource to sorted declared variable to guarantee destroy order
    auto old_swap_chain = std::move(swapchain);
    auto old_image_views = std::move(image_views);
    auto old_depth_image = std::move(depth_image);
    auto old_framebuffers = std::move(framebuffers);
  }

public:
  SwapchainContext() = default;
  SwapchainContext(BaseContext& ctx) { createResource(ctx, tryCreateSwapchain(ctx).value()); }
  auto tryRecreate(BaseContext& ctx) -> bool {
    // todo: 换成范围更小的约束?
    vkDeviceWaitIdle(ctx.device);
    if (auto ret = tryCreateSwapchain(ctx); ret.has_value()) {
      destroyResource();
      createResource(ctx, std::move(ret.value()));
      return true;
    } else if (ret.error() == vk::SwapchainCreateError::EXTENT_ZERO) {
      return false;
    } else {
      toy::throwf("create swapchain return some error different to "
                  "SwapchainCreateError::EXTENT_ZERO");
    }
    std::unreachable();
  }
};

} // namespace rd