export module render.drawer;

import render.context;
import render.resource;
import render.vertex;
import render.command;
import render.loop;

import vulkan;

import <vulkan_config.h>;
import std;
import toy;

export namespace render {

class DrawRecorder {
public:
  virtual void record(VkCommandBuffer cmdbuf, int in_flight_index) = 0;
};

/**
 * @brief the most outside draw order
 */
enum class DrawStage {
  PIPELINE = 0,
  GUI = 1,
};

class Drawer : public toy::ProactiveSingleton<Drawer>,
               private LoopActionLoader<LoopOrder::DRAWCALL> {
private:
  struct Worker {
    vk::Semaphore image_available_sema;
    vk::Semaphore present_release_sema;
    vk::Semaphore graphic_acquire_sema;
    vk::Semaphore render_finished_sema;
    vk::Semaphore present_acquire_sema;
    Fence         fence;
  };
  std::vector<Worker> _workers;

  int  _in_flight_index;
  bool _last_present_failed;

  std::map<DrawStage, toy::RefContainer<DrawRecorder>> _recorders;

  // 0 is not use
  std::vector<int> _image_useds;

public:
  template <DrawStage stage>
  struct StageContainer : public toy::ProactiveSingleton<StageContainer<stage>> {
    operator toy::RefContainer<DrawRecorder>&() { return Drawer::getInstance()._recorders[stage]; }
  };

private:
  StageContainer<DrawStage::PIPELINE> _stage_container_default;
  StageContainer<DrawStage::GUI>      _stage_container_gui;

public:
  Drawer() {
    auto& ctx = Context::getInstance();
    for (int i = 0; i < ctx.worker_count; i++) {
      _workers.push_back(Worker{
        .image_available_sema = vk::createSemaphore(ctx.device),
        .present_release_sema = vk::createSemaphore(ctx.device),
        .graphic_acquire_sema = vk::createSemaphore(ctx.device),
        .render_finished_sema = vk::createSemaphore(ctx.device),
        .present_acquire_sema = vk::createSemaphore(ctx.device),
        .fence = Fence{},
      });
    }
    _in_flight_index = 0;
    _last_present_failed = false;
    _image_useds.resize(ctx.images.size());
    for (auto& usage : _image_useds) {
      usage = 0;
    }
  }
  void waitDone() {
    for (auto& worker : _workers) {
      worker.fence.wait();
      // must clean, otherwise CommandExecutor will never destroy
      worker.fence = Fence{};
    }
  }

  int currentFlightIndex() { return _in_flight_index; }

  void draw() {
    auto& ctx = Context::getInstance();
    auto& executor = CommandExecutor::getInstance();
    auto& worker = _workers[_in_flight_index];

    uint32_t image_index;

    auto& fence = worker.fence;
    fence.wait();

    if (auto result = vkAcquireNextImageKHR(
          ctx.device,
          ctx.swapchain,
          std::numeric_limits<uint64_t>::max(),
          worker.image_available_sema,
          VK_NULL_HANDLE,
          &image_index
        );
        result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || _last_present_failed) {
      if (ctx.tryRecreate()) {
        _last_present_failed = false;
        _image_useds.resize(ctx.images.size());
        for (auto& usage : _image_useds) {
          usage = 0;
        }
        draw();
        return;
      } else {
        // toy::debugf("recreate swapchain failed, draw frame return");
        return;
      }
    } else {
      vk::checkVkResult(result, "acquire next image");
    }

    auto image_used = _image_useds[image_index];
    if (!image_used) {
      _image_useds[image_index] = 1;
    }

    auto present_executor = executor[CommandExecutor::Family::PRESENT];
    auto graphic_executor = executor[CommandExecutor::Family::GRAPHICS];
    auto image = ctx.images[image_index];
    auto image_type = vk::ImageType::COLOR_ATTACHMENT;
    auto mip_range = vk::MipRange{ 0, 1 };
    auto framebuffer = ctx.framebuffers[image_index].get();
    auto p2g_layout_transition = vk::LayoutTransitionInfo{
      vk::ImageUse::PRESENT,
      vk::ImageUse::PRESENT,
    };
    auto p2g_family_info = vk::FamilyTransferInfo{
      present_executor.getFamily(),
      graphic_executor.getFamily(),
    };
    auto record_p2g = [&](auto cmdbuf, vk::CommonUse use, bool acquire) {
      vk::recordImageBarrier(
        cmdbuf,
        image,
        image_type,
        mip_range,
        p2g_layout_transition,
        acquire ? vk::BarrierScope::acquire(use) : vk::BarrierScope::release(use),
        p2g_family_info
      );
    };
    auto g2p_layout_transition = vk::LayoutTransitionInfo{
      vk::ImageUse::PRESENT,
      vk::ImageUse::PRESENT,
    };
    auto g2p_family_info = vk::FamilyTransferInfo{
      graphic_executor.getFamily(),
      present_executor.getFamily(),
    };
    auto record_g2p = [&](auto cmdbuf, vk::CommonUse use, bool acquire) {
      vk::recordImageBarrier(
        cmdbuf,
        image,
        image_type,
        mip_range,
        g2p_layout_transition,
        acquire ? vk::BarrierScope::acquire(use) : vk::BarrierScope::release(use),
        g2p_family_info
      );
    };
    if (image_used) {
      present_executor[_in_flight_index].submit(
        [&](auto cmdbuf) { record_p2g(cmdbuf, vk::CommonUse::NONE, false); },
        std::array{ vk::WaitInfo{ worker.image_available_sema.get(), vk::CommonUse::ALL } },
        std::array{ worker.present_release_sema.get() }
      );
    }

    if (image_used) {
      graphic_executor[2 * _in_flight_index].submit(
        [&](auto cmdbuf) { record_p2g(cmdbuf, vk::CommonUse::NONE, true); },
        std::array{ vk::WaitInfo{ worker.present_release_sema.get(), vk::CommonUse::ALL } },
        std::array{ worker.graphic_acquire_sema.get() }
      );
    }

    fence = graphic_executor[2 * _in_flight_index + 1].submit(
      [&](VkCommandBuffer cmdbuf) {
        vk::recordRenderPass(
          cmdbuf,
          ctx.render_pass,
          framebuffer,
          ctx.extent,
          [&](auto cmdbuf) {
            for (auto& stage_recorders : _recorders | views::values) {
              for (auto& recorder : stage_recorders) {
                recorder.record(cmdbuf, _in_flight_index);
              }
            }
          },
          ctx.sample_count.has_value()
        );
        record_g2p(cmdbuf, vk::CommonUse::ALL, false);
      },
      std::array{ vk::WaitInfo{ image_used ? worker.graphic_acquire_sema.get()
                                           : worker.image_available_sema.get(),
                                vk::ImageUse::COLOR_ATTACHMENT } },
      std::array{ worker.render_finished_sema.get() }
    );

    present_executor[_in_flight_index].submit(
      [&](auto cmdbuf) { record_g2p(cmdbuf, vk::CommonUse::NONE, true); },
      std::array{ vk::WaitInfo{ worker.render_finished_sema.get(), vk::CommonUse::ALL } },
      std::array{ worker.present_acquire_sema.get() }
    );

    auto present_info = VkPresentInfoKHR{
      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
      .waitSemaphoreCount = 1,
      .pWaitSemaphores = &worker.present_acquire_sema.get(),
      .swapchainCount = 1,
      .pSwapchains = &ctx.swapchain.get(),
      .pImageIndices = &image_index,
      // .pResults: 当有多个 swapchain 时检查每个的result
    };
    if (auto result =
          vkQueuePresentKHR(present_executor[_in_flight_index].getQueue(), &present_info);
        result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) {
      toy::debugf(
        "the queue present return {}",
        result == VK_ERROR_OUT_OF_DATE_KHR ? "out of date error" : "sub optimal"
      );
      _last_present_failed = true;
    } else {
      vk::checkVkResult(result, "present");
    }
    _in_flight_index = (_in_flight_index + 1) % _workers.size();
  }
  void loopAction(uint32_t _) override { draw(); }
};

template <DrawStage stage>
using DrawerLoader = toy::InterfaceLoader<DrawRecorder, Drawer::StageContainer<stage>>;

} // namespace render