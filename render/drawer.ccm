export module render.drawer;

import render.context;
import render.uniform;
import render.resource;
import render.vertex;
import render.command;

import vulkan;

import <vulkan_config.h>;
import std;
import toy;

export namespace render {

class DrawRecorder {
public:
  virtual void record(VkCommandBuffer cmdbuf, int in_flight_index) = 0;
};

class Drawer : public toy::ProactiveSingleton<Drawer> {
private:
  struct Worker {
    vk::Semaphore image_available_sema;
    vk::Semaphore present_release_sema;
    vk::Semaphore graphic_acquire_sema;
    vk::Semaphore render_finished_sema;
    vk::Semaphore present_acquire_sema;
    Fence         fence;
  };
  std::vector<Worker> _workers;

  int  _in_flight_index;
  bool _last_present_failed;

  toy::RefContainer<DrawRecorder> _recorders;
  std::vector<BaseUniform*>       _uniforms;

  std::chrono::high_resolution_clock::time_point _last_time;

  // 0 is not use
  std::vector<int> _image_useds;

public:
  Drawer() {
    auto& ctx = Context::getInstance();
    for (int i = 0; i < ctx.worker_count; i++) {
      _workers.push_back(Worker{
        .image_available_sema = vk::createSemaphore(ctx.device),
        .present_release_sema = vk::createSemaphore(ctx.device),
        .graphic_acquire_sema = vk::createSemaphore(ctx.device),
        .render_finished_sema = vk::createSemaphore(ctx.device),
        .present_acquire_sema = vk::createSemaphore(ctx.device),
        .fence = Fence{},
      });
    }
    _in_flight_index = 0;
    _last_present_failed = false;
    _last_time = std::chrono::high_resolution_clock::time_point{};
    _image_useds.resize(ctx.images.size());
    for (auto& usage : _image_useds) {
      usage = 0;
    }
  }
  void waitDone() {
    for (auto& worker : _workers) {
      worker.fence.wait();
      // must clean, otherwise CommandExecutor will never destroy
      worker.fence = Fence{};
    }
  }

  operator toy::RefContainer<DrawRecorder>&() { return _recorders; }

  // todo: 解耦
  void registerUniform(BaseUniform& uniform) { _uniforms.push_back(&uniform); }

  void draw() {
    auto& ctx = Context::getInstance();
    auto& executor = CommandExecutor::getInstance();
    auto& worker = _workers[_in_flight_index];

    uint32_t image_index;

    for (auto* uniform : _uniforms) {
      uniform->update(_in_flight_index);
    }

    auto& fence = worker.fence;
    fence.wait();

    if (auto result = vkAcquireNextImageKHR(
          ctx.device,
          ctx.swapchain,
          std::numeric_limits<uint64_t>::max(),
          worker.image_available_sema,
          VK_NULL_HANDLE,
          &image_index
        );
        result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || _last_present_failed) {
      if (ctx.tryRecreate()) {
        _last_present_failed = false;
        _image_useds.resize(ctx.images.size());
        for (auto& usage : _image_useds) {
          usage = 0;
        }
        draw();
        return;
      } else {
        toy::debugf("recreate swapchain failed, draw frame return");
        return;
      }
    } else {
      vk::checkVkResult(result, "acquire next image");
    }

    auto this_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(this_time - _last_time);
    toy::debug(duration);
    _last_time = this_time;

    auto image_used = _image_useds[image_index];
    if (!image_used) {
      _image_useds[image_index] = 1;
    }

    auto present_executor = executor[CommandExecutor::Family::PRESENT];
    auto graphic_executor = executor[CommandExecutor::Family::GRAPHICS];
    auto image = ctx.images[image_index];
    auto image_type = vk::ImageType::COLOR_ATTACHMENT;
    auto mip_range = vk::MipRange{ 0, 1 };
    auto framebuffer = ctx.framebuffers[image_index].get();
    auto p2g_layout_transition = vk::LayoutTransitionInfo{
      vk::ImageUse::PRESENT,
      vk::ImageUse::PRESENT,
    };
    auto p2g_family_info = vk::FamilyTransferInfo{
      present_executor.getFamily(),
      graphic_executor.getFamily(),
    };
    auto record_p2g = [&](auto cmdbuf, vk::CommonUse use, bool acquire) {
      vk::recordImageBarrier(
        cmdbuf,
        image,
        image_type,
        mip_range,
        p2g_layout_transition,
        acquire ? vk::BarrierScope::acquire(use) : vk::BarrierScope::release(use),
        p2g_family_info
      );
    };
    auto g2p_layout_transition = vk::LayoutTransitionInfo{
      vk::ImageUse::PRESENT,
      vk::ImageUse::PRESENT,
    };
    auto g2p_family_info = vk::FamilyTransferInfo{
      graphic_executor.getFamily(),
      present_executor.getFamily(),
    };
    auto record_g2p = [&](auto cmdbuf, vk::CommonUse use, bool acquire) {
      vk::recordImageBarrier(
        cmdbuf,
        image,
        image_type,
        mip_range,
        g2p_layout_transition,
        acquire ? vk::BarrierScope::acquire(use) : vk::BarrierScope::release(use),
        g2p_family_info
      );
    };
    if (image_used) {
      present_executor.submit(
        [&](auto cmdbuf) { record_p2g(cmdbuf, vk::CommonUse::NONE, false); },
        std::array{ vk::WaitInfo{ worker.image_available_sema.get(), vk::CommonUse::ALL } },
        std::array{ worker.present_release_sema.get() }
      );
    }

    if (image_used) {
      graphic_executor[1].submit(
        [&](auto cmdbuf) { record_p2g(cmdbuf, vk::CommonUse::NONE, true); },
        std::array{ vk::WaitInfo{ worker.present_release_sema.get(), vk::CommonUse::ALL } },
        std::array{ worker.graphic_acquire_sema.get() }
      );
    }

    fence = graphic_executor.submit(
      [&](VkCommandBuffer cmdbuf) {
        vk::recordRenderPass(
          cmdbuf,
          ctx.render_pass,
          framebuffer,
          ctx.extent,
          [&](auto cmdbuf) {
            for (auto* recorder : _recorders) {
              recorder->record(cmdbuf, _in_flight_index);
            }
          },
          ctx.sample_count.has_value()
        );
        record_g2p(cmdbuf, vk::CommonUse::ALL, false);
      },
      std::array{ vk::WaitInfo{ image_used ? worker.graphic_acquire_sema.get()
                                           : worker.image_available_sema.get(),
                                vk::ImageUse::COLOR_ATTACHMENT } },
      std::array{ worker.render_finished_sema.get() }
    );

    present_executor.submit(
      [&](auto cmdbuf) { record_g2p(cmdbuf, vk::CommonUse::NONE, true); },
      std::array{ vk::WaitInfo{ worker.render_finished_sema.get(), vk::CommonUse::ALL } },
      std::array{ worker.present_acquire_sema.get() }
    );

    auto present_info = VkPresentInfoKHR{
      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
      .waitSemaphoreCount = 1,
      .pWaitSemaphores = &worker.present_acquire_sema.get(),
      .swapchainCount = 1,
      .pSwapchains = &ctx.swapchain.get(),
      .pImageIndices = &image_index,
      // .pResults: 当有多个 swapchain 时检查每个的result
    };
    if (auto result = vkQueuePresentKHR(present_executor[1].getQueue(), &present_info);
        result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) {
      toy::debugf(
        "the queue present return {}",
        result == VK_ERROR_OUT_OF_DATE_KHR ? "out of date error" : "sub optimal"
      );
      _last_present_failed = true;
    } else {
      vk::checkVkResult(result, "present");
    }
    _in_flight_index = (_in_flight_index + 1) % _workers.size();
  }
};
} // namespace render