export module render.pipeline;

import render.context;
import render.vertex;
import render.resource;
import render.drawer;

import vulkan;

import <vulkan_config.h>;
import std;
import glm;
import toy;

export namespace render {

auto resourceType2Layout(ResourceType type) -> VkDescriptorSetLayout {
  auto& ctx = Context::getInstance();
  switch (type) {
  case ResourceType::UNIFORM:
    return ctx.uniform_dset_layout.get();
  case ResourceType::SAMPLER:
    return ctx.sampler_dset_layout.get();
  }
};

class DrawUnit;

class Pipeline : private DrawerLoader<DrawStage::PIPELINE> {
  friend DrawUnit;

private:
  using AutoLoader = toy::AutoLoader<Pipeline, DrawRecorder>;
  friend AutoLoader;

  std::vector<ResourceType>   _resource_types;
  vk::PipelineResource        _pipeline_resource;
  toy::RefContainer<DrawUnit> _draw_units;

  bool _dynamic_stencil_reference;

public:
  Pipeline(
    std::string_view                 vertex_shader_name,
    std::string_view                 frag_shader_name,
    VkPrimitiveTopology              topology,
    VertexInfo                       vertex_info,
    std::span<const ResourceType>    resource_types,
    std::optional<vk::StencilOption> stencil_option
  ) {
    auto& ctx = Context::getInstance();
    _resource_types.append_range(resource_types);
    _pipeline_resource = vk::createGraphicsPipeline(
      ctx.pdevice_info.device,
      ctx.device,
      ctx.render_pass,
      topology,
      vertex_shader_name,
      frag_shader_name,
      std::array{ vertex_info.binding_description },
      vertex_info.attribute_descriptions,
      _resource_types | views::transform([&](auto type) { return resourceType2Layout(type); }) |
        ranges::to<std::vector>(),
      ctx.sample_count.value_or(VK_SAMPLE_COUNT_1_BIT),
      stencil_option
    );
    _dynamic_stencil_reference =
      stencil_option.transform([](auto& option) { return option.dynamic_reference; }
      ).value_or(false);
  }
  void record(VkCommandBuffer cmdbuf, int in_flight_index) override;
};

// todo: add vertex and resource layout check
class DrawUnit : private toy::AutoLoader<DrawUnit> {
  friend Pipeline;

private:
  using AutoLoader = toy::AutoLoader<DrawUnit>;
  friend AutoLoader;

  VertexBuffer* _vertex_buffer;
  IndexBuffer*  _index_buffer;

  vk::DescriptorPool _dsc_pool;
  vk::DescriptorSets _dsets;

  std::vector<std::vector<VkDescriptorSet>> _worker_dsets;

  std::optional<uint32_t> _stencil_reference;

public:
  DrawUnit(
    Pipeline&                  pipeline,
    VertexBuffer&              vertex_buffer,
    IndexBuffer&               index_buffer,
    std::span<Resource* const> resources,
    std::optional<uint32_t>    stencil_reference
  )
    : AutoLoader{ pipeline._draw_units } {

    auto& ctx = Context::getInstance();
    auto& resource_types = pipeline._resource_types;
    if (resources.size() != resource_types.size()) {
      toy::throwf(
        "The resource size ({}) is not equal to pipeline descriptor layout size ({})",
        resources.size(),
        resource_types.size()
      );
    }
    auto ds_updates = std::vector<vk::DescriptorSetUpdate>{};
    auto uniform_count = 0;
    auto sampler_count = 0;
    auto ds_layouts = std::vector<VkDescriptorSetLayout>{};
    auto worker_dset_indices = std::vector<std::vector<int>>{};
    worker_dset_indices.resize(ctx.worker_count);
    for (auto [resource, type] : views::zip(resources, resource_types)) {
      auto [desc_resource, type_] = resource->getResourceInfo();
      if (type_ != type) {
        toy::throwf("The resources type is not match pipeline resource type");
      }
      auto layout = resourceType2Layout(type);
      if (desc_resource.index() == 0) {
        sampler_count++;
        for (auto& dset_indices : worker_dset_indices) {
          dset_indices.push_back(ds_layouts.size());
        }
        ds_layouts.push_back(layout);
        ds_updates.emplace_back(VK_NULL_HANDLE, std::get<0>(desc_resource));
      } else {
        auto dsp_resources = std::get<1>(desc_resource);
        uniform_count += dsp_resources.size();
        toy::checkThrowf(
          ctx.worker_count == dsp_resources.size(),
          "The dsp_resources size is not equal to number of worker"
        );
        for (auto [dset_indices, index] : views::zip(
               worker_dset_indices,
               views::iota(ds_layouts.size(), ds_layouts.size() + dsp_resources.size())
             )) {
          dset_indices.push_back(index);
        }
        ds_layouts.append_range(views::repeat(layout, dsp_resources.size()));
        ds_updates.append_range(dsp_resources | views::transform([](auto resource) {
                                  return vk::DescriptorSetUpdate{ VK_NULL_HANDLE, resource };
                                }));
      }
    }

    auto dsc_pool = vk::DescriptorPool{};
    auto dsets = vk::DescriptorSets{};
    auto worker_dsets = std::vector<std::vector<VkDescriptorSet>>{};
    worker_dsets.resize(ctx.worker_count);
    if (resources.size() > 0) {
      auto pool_infos = std::array{
        VkDescriptorPoolSize{
          .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
          .descriptorCount = (uint32_t)uniform_count,
        },
        VkDescriptorPoolSize{
          .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          .descriptorCount = (uint32_t)sampler_count,
        },
      };
      if (uniform_count == 0 || sampler_count == 0) {
        dsc_pool = vk::createDescriptorPool(
          ctx.device,
          uniform_count + sampler_count,
          std::span{ &pool_infos[uniform_count == 0 ? 1 : 0], 1 }
        );
      } else {
        dsc_pool = vk::createDescriptorPool(ctx.device, uniform_count + sampler_count, pool_infos);
      }
      dsets = vk::allocateDescriptorSets(ctx.device, dsc_pool, ds_layouts);
      for (auto [dsets_, dset_indices] : views::zip(worker_dsets, worker_dset_indices)) {
        dsets_.append_range(dset_indices | views::transform([&](auto index) {
                              return dsets.get()[index];
                            }));
      }
      for (auto [ds, ds_update] : views::zip(dsets.get(), ds_updates)) {
        ds_update.descriptor_set = ds;
      }
      vk::updateDescriptorSets(ctx.device, ds_updates);
    }

    _vertex_buffer = &vertex_buffer;
    _index_buffer = &index_buffer;
    _dsc_pool = std::move(dsc_pool);
    _dsets = std::move(dsets);
    _worker_dsets = std::move(worker_dsets);

    _stencil_reference = stencil_reference;
  }
};

auto getStencilReferences(std::span<const uint32_t> references)
  -> std::vector<std::pair<size_t, uint32_t>> {
  return references | toy::enumerate |
         toy::chunkBy([](auto a, auto b) { return a.second == b.second; }) |
         views::transform([](auto sub_range) {
           // the stencil reference is a reference, LOL
           auto [index, reference] = *sub_range.begin();
           return std::pair<size_t, uint32_t>{ index, reference };
         }) |
         ranges::to<std::vector>();
}

inline void Pipeline::record(VkCommandBuffer cmdbuf, int in_flight_index) {
  auto& ctx = Context::getInstance();
  // todo: the exception can not throw outside, find out why
  toy::checkThrowf(
    ranges::all_of(
      _draw_units,
      [&](auto& unit) { return unit._stencil_reference.has_value() == _dynamic_stencil_reference; }
    ),
    "the draw units are {} set dynamic stencil reference",
    _dynamic_stencil_reference ? "not" : ""
  );
  vk::recordDrawUnits(
    cmdbuf,
    _pipeline_resource.pipeline,
    ctx.extent,
    _pipeline_resource.pipeline_layout,
    _draw_units | views::transform([&](auto& unit) {
      return vk::DrawUnit{
        .vertex_buffer = unit._vertex_buffer->get(),
        .index_buffer = unit._index_buffer->get(),
        .count = (uint32_t)unit._index_buffer->getIndexNumber(),
        .descriptor_sets = unit._worker_dsets[in_flight_index],
      };
    }),
    _dynamic_stencil_reference
      ? std::optional{ vk::StencilReferences{ getStencilReferences(
          _draw_units |
          views::transform([&](auto& unit) { return unit._stencil_reference.value(); }) |
          ranges::to<std::vector>()
        ) } }
      : std::nullopt
  );
}

} // namespace render