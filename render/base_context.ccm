export module render.base_context;

import vulkan;

import <vulkan_config.h>;
import std;
import toy;
import glfw;

export namespace render {

struct BaseContext {
  glfw::Window window;

  template <bool enable_debug_messenger>
  struct InstanceWithDebugMessenger;
  template <>
  struct InstanceWithDebugMessenger<true> {
    vk::Instance             instance;
    vk::DebugMessenger       debug_messenger;
    vk::DebugMessengerConfig debug_config;
  };
  template <>
  struct InstanceWithDebugMessenger<false> {
    vk::Instance instance;
  };
  InstanceWithDebugMessenger<toy::enable_debug> instance;

  vk::Surface surface;

  vk::PhysicalDeviceInfo pdevice_info;
  vk::Device             device;

  struct CommandContext {
    std::vector<VkQueue> queues;
    uint32_t             family_index;
  };

  CommandContext graphic_ctx;
  CommandContext present_ctx;
  CommandContext transfer_ctx;

  VkFormat depth_format;

  std::optional<VkSampleCountFlagBits> sample_count;

  vk::RenderPass render_pass;

  vk::DescriptorSetLayout uniform_dset_layout;
  vk::DescriptorSetLayout sampler_dset_layout;

  BaseContext() = default;
  BaseContext(const std::string& app_name, int width, int height, bool multi_sample) {
    window = glfw::Window{ width, height, app_name };

    if constexpr (toy::enable_debug) {
      instance.debug_config = vk::DebugMessengerConfig{
        .message_severity_level = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
        .message_type_flags = VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT,
      };
      instance.instance = vk::createInstance(app_name, instance.debug_config);
      instance.debug_messenger = vk::createDebugMessenger(instance.instance, instance.debug_config);
    } else {
      instance.instance = vk::createInstance(app_name);
    }

    surface = vk::createSurface(instance.instance, window);

    // VK_KHR_SWAPCHAIN_EXTENSION_NAME 对应的扩展用于支持交换链
    auto required_device_extensions = std::array{ VK_KHR_SWAPCHAIN_EXTENSION_NAME };
    auto queue_requests = std::array{
      vk::QueueRequest{ 2, vk::checkGraphicQueue },
      vk::QueueRequest{ 2, vk::checkPresentQueue },
      vk::QueueRequest{ 1, vk::checkTransferQueue },
    };
    pdevice_info = vk::pickPhysicalDevice(
      instance.instance,
      surface,
      required_device_extensions,
      vk::checkPhysicalDeviceSupport,
      vk::checkSurfaceSupport,
      queue_requests
    );
    toy::debug(pdevice_info.family_indices);
    toy::debugf(
      "graphic family index {} transfer family index",
      pdevice_info.family_indices[0] == pdevice_info.family_indices[2] ? "==" : "!="
    );
    toy::debugf(
      "graphic family index {} present family index",
      pdevice_info.family_indices[0] == pdevice_info.family_indices[1] ? "==" : "!="
    );
    auto queue_create_info = views::zip(queue_requests, pdevice_info.family_indices) |
                             views::transform([](auto pair) {
                               return std::pair{ pair.second, pair.first.first };
                             }) |
                             ranges::to<std::vector>();
    auto [_device, queues] = vk::createDevice(
      pdevice_info.device, queue_create_info, pdevice_info.features, required_device_extensions
    );
    device = std::move(_device);
    auto get_ctx = [&](int index) {
      return CommandContext{
        .queues = std::move(queues[index]),
        .family_index = pdevice_info.family_indices[index],
      };
    };
    graphic_ctx = get_ctx(0);
    present_ctx = get_ctx(1);
    transfer_ctx = get_ctx(2);
    depth_format = vk::findDepthFormat(pdevice_info.device);
    if (multi_sample) {
      sample_count = vk::getMaxSampleCount(pdevice_info.properties);
      toy::debugf("the sample count is {}", (int)sample_count.value());
    }
    render_pass =
      vk::createRenderPass(device, pdevice_info.surface_format.format, depth_format, sample_count);
    uniform_dset_layout = vk::createUniformDescriptorSetLayout(device);
    sampler_dset_layout = vk::createSamplerDescriptorSetLayout(device);
  }
};

} // namespace render
