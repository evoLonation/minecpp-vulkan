export module render.sampler;

import render.context;
import render.resource;
import render.command;

import vulkan;

import "vulkan_config.h";
import "stb_image.h";
import std;
import toy;

export namespace render {

class SampledTexture : public Resource {
private:
  vk::Buffer _staging_buffer;
  vk::Memory _staging_memory;

  vk::ImageResource _image_resource;
  vk::Sampler       _sampler;

  static constexpr auto _image_type = vk::ImageType::SAMPLED_IMAGE;

public:
  SampledTexture() = default;
  SampledTexture(const std::string& path) {
    auto& ctx = Context::getInstance();

    int   width, height, channels;
    auto* pixels = stbi_load(path.data(), &width, &height, &channels, STBI_rgb_alpha);
    auto  image_size = static_cast<VkDeviceSize>(width * height * 4);
    if (pixels == nullptr) {
      toy::throwf("failed to load image {}", path.data());
    }
    auto image_data = std::as_bytes(std::span{ pixels, image_size });
    toy::debugf("image {} info: width {}, height {}", path.data(), width, height);

    std::tie(_staging_buffer, _staging_memory) =
      vk::createStagingBuffer(ctx.pdevice_info.device, ctx.device, image_data);

    stbi_image_free(pixels);

    auto format = vk::findSupportedFormat(
      ctx.pdevice_info.device, std::array{ VK_FORMAT_R8G8B8A8_SRGB }, _image_type
    );

    _image_resource =
      vk::createImage(ctx.pdevice_info.device, ctx.device, format, width, height, _image_type);

    auto max_anisotropy = ctx.pdevice_info.properties.limits.maxSamplerAnisotropy;
    _sampler = vk::createSampler(ctx.device, max_anisotropy);

    auto& executor = CommandExecutor::getInstance();
    auto  copy_executor = executor[CommandExecutor::Family::TRANSFER];
    auto  graphics_executor = executor[CommandExecutor::Family::GRAPHICS];
    auto  family_transfer =
      vk::FamilyTransferInfo{ copy_executor.getFamily(), graphics_executor.getFamily() };
    auto aspect = vk::getAspect(_image_type);
    auto layout_transition = vk::LayoutTransitionInfo{
      vk::ImageUse::COPY_DST,
      vk::ImageUse::FRAGMENT_SAMPLER,
    };

    auto recorder_copy = [&](VkCommandBuffer cmdbuf) {
      vk::recordImageBarrier(
        cmdbuf,
        _image_resource.image.get(),
        aspect,
        { vk::ImageUse::UNDEFINED, vk::ImageUse::COPY_DST },
        { vk::Scope{ vk::ImageUse::UNDEFINED, false },
          vk::Scope{ vk::ImageUse::COPY_DST, true } },
        {}
      );

      vk::copyBufferToImage(
        cmdbuf, _staging_buffer, _image_resource.image, vk::getAspect(_image_type), width, height
      );

      vk::recordImageBarrier(
        cmdbuf,
        _image_resource.image.get(),
        aspect,
        layout_transition,
        vk::BarrierScope::release(vk::ImageUse::COPY_DST),
        family_transfer
      );
    };

    auto recorder_acqurie = [&](VkCommandBuffer cmdbuf) {
      vk::recordImageBarrier(
        cmdbuf,
        _image_resource.image.get(),
        aspect,
        layout_transition,
        vk::BarrierScope::acquire(vk::ImageUse::FRAGMENT_SAMPLER),
        family_transfer
      );
    };

    auto waitable = copy_executor.submit(recorder_copy, {}, 1).second;
    graphics_executor.submit(
      recorder_acqurie, std::array{ WaitInfo{ waitable, vk::CommonUse::ALL } }, 0
    );
  }

  auto getResourceInfo() -> ResourceInfo override {
    return {
      .desc_resource =
        vk::DescriptorResource{ std::pair{ _image_resource.image_view.get(), _sampler.get() } },
      .resource_type = ResourceType::SAMPLER,
    };
  }
};

} // namespace render