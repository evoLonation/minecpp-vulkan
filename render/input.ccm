export module render.input;

import render.context;
import render.loop;

import "glfw_config.h";

import std;
import toy;

export namespace render {

class InputProcessor : public toy::ProactiveSingleton<InputProcessor>,
                       private LoopActionLoader<LoopOrder::PROCESS_INPUT> {
private:
  using _KeyDownHandler = std::function<void()>;
  using _KeyHoldHandler = std::function<void(int holdMilli)>;
  using _KeyReleaseHandler = std::function<void(int holdMilli)>;
  using _CursorMoveHandler = std::function<void(double x, double y)>;

public:
  struct KeyDownHandler : public _KeyDownHandler, public toy::AutoLoader<KeyDownHandler> {
    KeyDownHandler() = default;
    KeyDownHandler(int key, _KeyDownHandler handler)
      : _KeyDownHandler(std::move(handler)),
        toy::AutoLoader<KeyDownHandler>(InputProcessor::getInstance()._key_down_handlers[key]) {}
  };
  struct KeyReleaseHandler : public _KeyHoldHandler, public toy::AutoLoader<KeyReleaseHandler> {
    KeyReleaseHandler() = default;
    KeyReleaseHandler(int key, _KeyHoldHandler handler)
      : _KeyHoldHandler(std::move(handler)),
        toy::AutoLoader<KeyReleaseHandler>(InputProcessor::getInstance()._key_release_handlers[key]
        ) {}
  };
  struct KeyHoldHandler : public _KeyHoldHandler, public toy::AutoLoader<KeyHoldHandler> {
    KeyHoldHandler() = default;
    KeyHoldHandler(int key, _KeyHoldHandler handler)
      : _KeyHoldHandler(std::move(handler)),
        toy::AutoLoader<KeyHoldHandler>(InputProcessor::getInstance()._key_hold_handlers[key]) {}
  };
  struct CursorMoveHandler : public _CursorMoveHandler, public toy::AutoLoader<CursorMoveHandler> {
    CursorMoveHandler() = default;
    CursorMoveHandler(_CursorMoveHandler handler)
      : _CursorMoveHandler(std::move(handler)),
        toy::AutoLoader<CursorMoveHandler>(InputProcessor::getInstance()._cursor_move_handlers) {}
  };

private:
  inline static std::map<GLFWwindow*, InputProcessor*> _instance_map;

  std::map<int, std::chrono::high_resolution_clock::time_point> _pressed_keys;
  std::map<int, toy::RefContainer<KeyDownHandler>>              _key_down_handlers;
  std::map<int, toy::RefContainer<KeyHoldHandler>>              _key_hold_handlers;
  std::map<int, toy::RefContainer<KeyReleaseHandler>>           _key_release_handlers;
  toy::RefContainer<CursorMoveHandler>                          _cursor_move_handlers;

  double _last_x;
  double _last_y;
  bool   _cursor_visible;

  InputProcessor(const InputProcessor&) = delete;
  InputProcessor(InputProcessor&&) = delete;
  auto operator=(const InputProcessor&) -> InputProcessor& = delete;
  auto operator=(InputProcessor&&) -> InputProcessor& = delete;

public:
  InputProcessor() {
    GLFWwindow* window = Context::getInstance().window;
    _instance_map.insert({ window, this });
    // 须在创建窗口后、开始渲染前注册回调函数
    glfwSetKeyCallback(window, [](GLFWwindow* window, int key, int scancode, int action, int mods) {
      auto& instance = *_instance_map[window];
      if (action == GLFW_PRESS) {
        if (instance._key_down_handlers.contains(key)) {
          for (auto& handler : instance._key_down_handlers[key]) {
            handler();
          }
        }
        auto start_time = std::chrono::high_resolution_clock::now();
        instance._pressed_keys.insert({ key, start_time });
      } else if (action == GLFW_RELEASE) {
        if (instance._key_release_handlers.contains(key)) {
          auto start_time = instance._pressed_keys[key];
          auto end_time = std::chrono::high_resolution_clock::now();
          auto duration =
            std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
          for (auto& handler : instance._key_release_handlers[key]) {
            handler(duration.count());
          }
        }
        instance._pressed_keys.erase(key);
      }
    });
    glfwGetCursorPos(window, &_last_x, &_last_y);
    glfwSetCursorPosCallback(window, [](GLFWwindow* window, double x, double y) {
      auto& instance = *_instance_map[window];
      for (auto& handler : instance._cursor_move_handlers) {
        handler(x - instance._last_x, y - instance._last_y);
      }
      instance._last_x = x;
      instance._last_y = y;
    });
    _cursor_visible = false;
    setCursorVisible(true);
  }

  void setCursorVisible(bool visible) {
    if (_cursor_visible == visible) {
      return;
    }
    _cursor_visible = visible;
    if (visible) {
      glfwSetInputMode(Context::getInstance().window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
    } else {
      glfwSetInputMode(Context::getInstance().window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    }
  }
  bool isCursorVisible() const { return _cursor_visible; }

  void processInput() {
    glfwPollEvents();

    bool hasAny = false;
    for (const auto& pair : _pressed_keys) {
      auto _key = pair.first;
      auto end_time = std::chrono::high_resolution_clock::time_point{};
      if (_key_hold_handlers.contains(_key)) {
        if (!hasAny) {
          end_time = std::chrono::high_resolution_clock::now();
          hasAny = true;
        }
        auto start_time = pair.second;
        auto duration =
          std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        for (auto& handler : _key_hold_handlers[_key]) {
          handler(duration.count());
        }
      }
    }
  }
  void action() override { processInput(); }
};

using KeyDownHandler = InputProcessor::KeyDownHandler;
using KeyHoldHandler = InputProcessor::KeyHoldHandler;
using KeyReleaseHandler = InputProcessor::KeyReleaseHandler;
using CursorMoveHandler = InputProcessor::CursorMoveHandler;

} // namespace render
