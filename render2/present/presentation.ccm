export module render.vk.presentation;
import std;
import toy;

import "vulkan_config.h";

import render.vk.tracker;
import render.vk.device;
import render.vk.resource;
import render.vk.tool;
import render.vk.sync;
import render.vk.image;
import render.vk.executor;
import render.vk.reflections;
export import render.vk.swapchain;

export namespace rd::vk {

class Presentation {
public:
  Presentation(VkSurfaceKHR surface) {
    _surface = surface;
    _present_executor = &CommandExecutorManager::getInstance()[FamilyType::PRESENT];
    if (!recreate()) {
      toy::debugf("create swapchain failed when construct presentation");
    }
  }
  ~Presentation() {
    if (_swapchain.isValid()) {
      ImageContext::destroy(std::move(_image_ctxs), _swapchain.get());
    }
  }

  auto acquireNextImage() -> std::pair<uint32, VkResult> {
    uint32 image_index;
    auto   result = vkAcquireNextImageKHR(
      Device::getInstance(),
      _swapchain,
      std::numeric_limits<uint64_t>::max(),
      _acquire_ctx.available_sema,
      _acquire_ctx.available_fence,
      &image_index
    );
    checkVkResult(
      result, "acquire next image", { VK_SUCCESS, VK_ERROR_OUT_OF_DATE_KHR, VK_SUBOPTIMAL_KHR }
    );
    if (result != VK_SUCCESS) {
      toy::debugf("acquire next image return: {}", refl::result(result));
    }
    return { image_index, result };
  }

  struct Context {
    uint32               image_index;
    VkImage              image;
    VkImageView          image_view;
    ImageBarrierTracker* tracker;
  };
  auto prepare() -> std::optional<Context> {
    if (_need_recreate || !_swapchain.isValid()) {
      return std::nullopt;
    }
    if (_acquire_ctx.fence_waitable) {
      _acquire_ctx.available_fence.wait(true);
      _acquire_ctx.fence_waitable = false;
    }
    auto [image_index, result] = acquireNextImage();
    if (result == VK_ERROR_OUT_OF_DATE_KHR) {
      _need_recreate = true;
      return std::nullopt;
    }
    // success call
    _acquire_ctx.fence_waitable = true;
    _image_ctxs[image_index].need_release = true;
    auto& ctx = _image_ctxs[image_index];
    auto  image = _swapchain.getImages()[image_index];
    auto  image_view = _swapchain.getImageViews()[image_index].get();

    auto previous_layout = ctx.tracker.getNowLayout();
    // submit barrier(s) to wait _acquire_ctx.available_sema
    // toy::debugf(toy::NoLocation{}, "prepare(): will call syncScope");
    auto barrier = ctx.tracker.syncScope(
      Scope{ .stage_mask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT },
      _present_executor->getFamily(),
      VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
    );
    if (auto* recorder = std::get_if<BarrierRecorder>(&barrier)) {
      auto batch = RawWaitCommandBatch{
        .recorder = std::move(*recorder),
        .waits = { { _acquire_ctx.available_sema, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT } },
      };
      _present_executor->submit(batch);
    } else if (auto* recorder = std::get_if<FamilyTransferRecorder>(&barrier)) {
      auto release_batch = RawWaitCommandBatch{
        .recorder = std::move(recorder->release),
        .waits = { { _acquire_ctx.available_sema, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT } },
      };
      auto& release_executor = CommandExecutorManager::getInstance()[recorder->release_family];
      auto  waitable = release_executor.submit(release_batch);

      auto acquire_batch = CommandBatch{
        .recorder = std::move(recorder->acquire),
        .waits = { { &waitable, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT } },
      };
      _present_executor->submit(acquire_batch);
    }
    if (result == VK_SUCCESS) {
      return Context{
        .image_index = image_index,
        .image = image,
        .image_view = image_view,
        .tracker = &ctx.tracker,
      };
    } else {
      _need_recreate = true;
      return std::nullopt;
    }
  }
  auto vkPresent(uint32 image_index, VkSemaphore wait_sema, VkFence signal_fence) -> VkResult {
    auto fence_info = VkSwapchainPresentFenceInfoEXT{
      .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT,
      .swapchainCount = 1,
      .pFences = &signal_fence,
    };
    auto swapchain = _swapchain.get();
    auto present_info = VkPresentInfoKHR{
      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
      .pNext = &fence_info,
      .waitSemaphoreCount = 1,
      .pWaitSemaphores = &wait_sema,
      .swapchainCount = 1,
      .pSwapchains = &swapchain,
      .pImageIndices = &image_index,
    };
    auto result = vkQueuePresentKHR(
      CommandExecutorManager::getInstance()[FamilyType::PRESENT].getQueue(), &present_info
    );
    checkVkResult(result, "present", { VK_SUCCESS, VK_ERROR_OUT_OF_DATE_KHR, VK_SUBOPTIMAL_KHR });
    if (result != VK_SUCCESS) {
      toy::debugf("present return: {}", refl::result(result));
    }
    return result;
  }

  auto present(uint32 image_index) -> bool {
    auto& ctx = _image_ctxs[image_index];
    auto  wait_sema = ctx.present_wait_sema.get();
    auto  signal_fence = ctx.present_signal_fence.get();
    if (ctx.fence_waitable) {
      ctx.present_signal_fence.wait(true);
      ctx.fence_waitable = false;
    }
    auto barrier = ctx.tracker.syncScope(
      Scope{ .stage_mask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT },
      _present_executor->getFamily(),
      VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
    );
    if (auto* recorder = std::get_if<BarrierRecorder>(&barrier)) {
      auto batch = RawSignalCommandBatch{
        .recorder = std::move(*recorder),
        .signals = { { wait_sema, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT } },
      };
      _present_executor->submit(batch);
    } else if (auto* recorder = std::get_if<FamilyTransferRecorder>(&barrier)) {
      auto& release_executor = CommandExecutorManager::getInstance()[recorder->release_family];
      auto  release_batch = CommandBatch{
         .recorder = std::move(recorder->release),
      };
      auto waitable = release_executor.submit(release_batch);

      auto acquire_batch = RawSignalCommandBatch{
        .recorder = std::move(recorder->acquire),
        .waits = { { &waitable, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT } },
        .signals = { { wait_sema, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT } },
      };
      _present_executor->submit(acquire_batch);
    }
    auto result = vkPresent(image_index, wait_sema, signal_fence);
    // sema and fence is wait and signal in all result
    ctx.need_release = false;
    ctx.fence_waitable = true;
    if (result != VK_SUCCESS) {
      _need_recreate = true;
      return false;
    }
    return true;
  }

  auto recreate() -> bool {
    if (_swapchain.isValid()) {
      ImageContext::destroy(std::move(_image_ctxs), _swapchain);
    }
    auto capabilities = VkSurfaceCapabilitiesKHR{};
    checkVkResult(
      vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
        Device::getInstance().getPdevice().get(), _surface, &capabilities
      ),
      "get surface capabilities"
    );
    _swapchain = { _surface, capabilities, _swapchain.get() };
    if (!_swapchain.isValid()) {
      return false;
    }
    for (auto& image : _swapchain.getImages()) {
      _image_ctxs.emplace_back(image);
    }
    _need_recreate = false;
    return true;
  }

  auto getSwapchain() -> Swapchain& { return _swapchain; }

  Presentation(const Presentation&) noexcept = delete;
  Presentation(Presentation&&) noexcept = delete;
  auto operator=(const Presentation&) noexcept -> Presentation& = delete;
  auto operator=(Presentation&&) noexcept -> Presentation& = delete;

private:
  VkSurfaceKHR _surface;

  CommandExecutor* _present_executor;

  bool _need_recreate;

  Swapchain _swapchain;

  /**
   * @brief
   * before vkacquire, if fence_waitable is true, set fence_waitable to false and fence.wait()
   * pass sema and fence to vkacquire for signal
   * after vkacquire, if success, set fence_waitable to true and submit wait operation for sema
   * when destroy, need ensure destroy after ImageContext because if images is free, the sema is
   *  also free
   */
  struct AcquireContext {
    rs::Semaphore available_sema;
    Fence         available_fence;
    bool          fence_waitable;
    AcquireContext()
      : available_sema(createSemaphore()), available_fence{ false }, fence_waitable(false) {}
    ~AcquireContext() {
      if (fence_waitable) {
        available_fence.wait(false);
      }
    }
  };
  AcquireContext _acquire_ctx;

  /**
   * @brief
   * 1. sema: must submit signal operation before vkpresent, and pass to vkpresent for wait
   * 2. fence: need pass to vkpresent for signal when present done, so that when fence is signaled,
   * the sema must also be consumed by present
   * 1+2. if vkpresent is failed, must submit a wait operation of sema and signal operation of fence
   * with empty recorder
   * 3. wait() need be called before vkpresent and destroy to ensure both fence and sema are free
   * 4. fence_waitable: set true after vkpresent, and set false after wait()
   * can ensure when false, both sema and fence are free
   * 5. need_release: set true after success vkacquire and set false after success vkpresent
   * 6. when destory, first if waitable == true, then fence.wait(), then can ensure:
   *  1) both sema and fence are free;
   *  2) the image that need_release is false has present done. so just need call vkrelease for
   * images that need_release is true
   */
  struct ImageContext {
    VkImage             image;
    ImageBarrierTracker tracker;
    rs::Semaphore       present_wait_sema;
    Fence               present_signal_fence;
    bool                fence_waitable;
    bool                need_release;
    ImageContext(VkImage image)
      : image(image),
        tracker{ image, getSubresourceRange(VK_IMAGE_ASPECT_COLOR_BIT, MipRange{ 0, 1 }) },
        present_wait_sema(createSemaphore()), //
        present_signal_fence{ false },        //
        fence_waitable(false), need_release(false) {}
    /**
     * @brief is not the correct way to destroy valid context, please use destroy()
     */
    ~ImageContext() {
      if (image) {
        toy::debugf("error: must not destory using destructor, use destroy() instead");
      }
    }
    ImageContext(ImageContext&& a)
      : image(std::move(a.image)), tracker(std::move(a.tracker)),
        present_wait_sema(std::move(a.present_wait_sema)),
        present_signal_fence(std::move(a.present_signal_fence)),
        fence_waitable(std::move(a.fence_waitable)), need_release(std::move(a.need_release)) {
      a.image = VK_NULL_HANDLE;
    }
    static void destroy(std::vector<ImageContext> image_ctxs, VkSwapchainKHR swapchain) {
      auto need_release = std::vector<uint32>{};
      for (auto [index, ctx] : image_ctxs | toy::enumerate) {
        if (ctx.fence_waitable) {
          ctx.present_signal_fence.wait(false);
        }
        ctx.tracker.waitIdle();
        if (ctx.need_release) {
          need_release.push_back(index);
        }
        ctx.image = VK_NULL_HANDLE;
      }
      if (!need_release.empty()) {
        auto release_info = VkReleaseSwapchainImagesInfoEXT{
          .sType = VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT,
          .swapchain = swapchain,
          .imageIndexCount = static_cast<uint32>(need_release.size()),
          .pImageIndices = need_release.data(),
        };
        checkVkResult(
          vkReleaseSwapchainImagesEXT(Device::getInstance(), &release_info),
          "release swapchain images"
        );
      }
      image_ctxs.clear();
    }
  };
  std::vector<ImageContext> _image_ctxs;
};

} // namespace rd::vk