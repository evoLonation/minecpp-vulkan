export module render.vk.presentation;
import std;
import toy;

import "vulkan_config.h";

import render.vk.tracker;
import render.vk.device;
import render.vk.resource;
import render.vk.tool;
import render.vk.sync;
import render.vk.image;
import render.vk.executor;
import render.vk.reflections;
import render.vk.swapchain;

export namespace rd::vk {

class Presentation {
public:
  Presentation(VkSurfaceKHR surface);
  ~Presentation();

  struct Context {
    uint32               image_index;
    VkImage              image;
    VkImageView          image_view;
    ImageBarrierTracker* tracker;
  };
  auto prepare() -> std::optional<Context>;

  auto present(uint32 image_index) -> bool;

  auto recreate() -> bool;

  struct ImageContext;
  auto getImages() -> std::span<ImageContext> { return _image_ctxs; }

  auto getSwapchain() -> Swapchain& { return _swapchain; }

  Presentation(const Presentation&) noexcept = delete;
  Presentation(Presentation&&) noexcept = delete;
  auto operator=(const Presentation&) noexcept -> Presentation& = delete;
  auto operator=(Presentation&&) noexcept -> Presentation& = delete;

private:
  VkSurfaceKHR _surface;

  CommandExecutor* _present_executor;

  bool _need_recreate;

  Swapchain _swapchain;

  /**
   * @brief
   * before vkacquire, if fence_waitable is true, set fence_waitable to false and fence.wait()
   * pass sema and fence to vkacquire for signal
   * after vkacquire, if success, set fence_waitable to true and submit wait operation for sema
   * when destroy, need ensure destroy after ImageContext because if images is free, the sema is
   *  also free
   */
  struct AcquireContext {
    rs::Semaphore available_sema;
    Fence         available_fence;
    bool          fence_waitable;
    AcquireContext()
      : available_sema(createSemaphore()), available_fence{ false }, fence_waitable(false) {}
    ~AcquireContext() {
      if (fence_waitable) {
        available_fence.wait(false);
      }
    }
  };
  AcquireContext _acquire_ctx;

public:
  /**
   * @brief
   * 1. sema: must submit signal operation before vkpresent, and pass to vkpresent for wait
   * 2. fence: need pass to vkpresent for signal when present done, so that when fence is signaled,
   * the sema must also be consumed by present
   * 1+2. if vkpresent is failed, must submit a wait operation of sema and signal operation of fence
   * with empty recorder
   * 3. wait() need be called before vkpresent and destroy to ensure both fence and sema are free
   * 4. fence_waitable: set true after vkpresent, and set false after wait()
   * can ensure when false, both sema and fence are free
   * 5. need_release: set true after success vkacquire and set false after success vkpresent
   * 6. when destory, first if waitable == true, then fence.wait(), then can ensure:
   *  1) both sema and fence are free;
   *  2) the image that need_release is false has present done. so just need call vkrelease for
   * images that need_release is true
   */
  struct ImageContext {
    friend Presentation;

  private:
    VkImage             image;
    VkImageView         image_view;
    ImageBarrierTracker tracker;
    rs::Semaphore       present_wait_sema;
    Fence               present_signal_fence;
    bool                fence_waitable;
    bool                need_release;
    ImageContext(VkImage image, VkImageView image_view);

  public:
    /**
     * @brief is not the correct way to destroy valid context, please use destroy()
     */
    ~ImageContext();
    ImageContext(ImageContext&& a);
    static void destroy(std::vector<ImageContext> image_ctxs, VkSwapchainKHR swapchain);

  public:
    void waitIdle(uint64 nano_timeout = std::numeric_limits<uint64>::max());
    auto getImage() -> VkImage { return image; }
    auto getImageView() -> VkImageView { return image_view; }
  };

private:
  std::vector<ImageContext> _image_ctxs;

private:
  auto acquireNextImage() -> std::pair<uint32, VkResult>;
  auto vkPresent(uint32 image_index, VkSemaphore wait_sema, VkFence signal_fence) -> VkResult;
};

} // namespace rd::vk