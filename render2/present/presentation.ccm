export module render.vk.presentation;

import std;
import toy;

import "vulkan_config.h";
import render.vk.sync;

export namespace rd::vk {

class Presentation {
public:
  Presentation(VkImageLayout available_layout, VkImageLayout render_done_layout)
    : _available_layout(available_layout), _render_done_layout(render_done_layout) {}

  struct PresentContext {
    // must consume semas until present()
    // sema that need wait until image is available (transfer to graphics and available_layout)
    VkSemaphore wait_sema;
    // sema that need signal after draw is done and in render_done_layout
    VkSemaphore signal_sema;
    uint32_t    image_index;
    bool        need_recreate;
  };

  auto prepare() -> std::optional<PresentContext>;
  /**
   * @brief must call after a success prepare()
   *
   */
  void present();

private:
  VkImageLayout _available_layout;
  VkImageLayout _render_done_layout;

  struct ImageResource {
    Semaphore present_release_sema = { true };
    Semaphore graphic_acquire_sema = { true };
    Semaphore render_done_sema = { true };
    Semaphore graphic_release_sema = { true };
    Semaphore present_acquire_sema = { true };
  };

  std::map<VkImage, ImageResource> _image_resources;

  bool _present_recreated;
};

} // namespace rd::vk