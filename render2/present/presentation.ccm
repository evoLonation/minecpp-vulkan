export module render.vk.presentation;

import std;
import toy;

import "vulkan_config.h";
import render.vk.swapchain;
import render.vk.sync;
import render.vk.executor;
import render.vk.image;

export namespace rd::vk {

class Presentation {
public:
  Presentation(VkImageLayout available_layout, VkImageLayout render_done_layout)
    : _available_layout(available_layout), _render_done_layout(render_done_layout) {}

  struct PresentContext {
    // must consume semas until present()
    // sema that need wait until image is available (transfer to graphics and available_layout)
    VkSemaphore wait_sema;
    // sema that need signal after draw is done and in render_done_layout
    VkSemaphore signal_sema;
    uint32_t    image_index;
  };

  auto prepare() -> std::optional<PresentContext> {
    auto& swapchain = Swapchain::getInstance();
    if (!swapchain.valid()) {
      swapchain.updateCapabilities();
      if (swapchain.needRecreate()) {
        swapchain.recreate();
      }
    }
    if (!swapchain.valid()) {
      return std::nullopt;
    }
    // transfer new image ownership from present to graphics
    // transfer new image layout from presentable to <custom>
    auto  image_available_sema = swapchain.getImageAvailableSema();
    auto  image_index = swapchain.getCurrentImageIndex();
    auto& present_executor = executors::present;
    auto& graphic_executor = executors::tool;
    auto  image = swapchain.images()[image_index];
    auto  record_p2g = [&](VkCommandBuffer cmdbuf, bool acquire) {
      recordImageBarrier(
        cmdbuf,
        image,
        getSubresourceRange(VK_IMAGE_ASPECT_COLOR_BIT, vk::MipRange{ 0, 1 }),
        LayoutTransitionInfo{
          VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
          _available_layout,
        },
        acquire ? vk::BarrierScope::acquire(vk::Scope{
                     .stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
                  })
                 : vk::BarrierScope::release(vk::Scope{
                     .stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
                  }),
        FamilyTransferInfo{
          present_executor.getFamily(),
          graphic_executor.getFamily(),
        }
      );
    };
    auto present_release_sema = _image_resources[image].present_release_sema.get();
    auto graphic_acquire_sema = _image_resources[image].graphic_acquire_sema.get();
    present_executor[0].submit(
      [&](auto cmdbuf) { record_p2g(cmdbuf, false); },
      std::array{ WaitSemaphore{ image_available_sema, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT } },
      std::array{ present_release_sema }
    );
    graphic_executor.submit(
      [&](auto cmdbuf) { record_p2g(cmdbuf, true); },
      std::array{ WaitSemaphore{ present_release_sema, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT } },
      std::array{ graphic_acquire_sema }
    );

    return PresentContext{
      .wait_sema = graphic_acquire_sema,
      .signal_sema = _image_resources[image].render_done_sema,
      .image_index = image_index,
    };
  }
  /**
   * @brief must call after a success prepare()
   *
   */
  void present() {
    // transfer image ownership from graphics to present
    // transfer image layout from <custom> to presentable
    auto& swapchain = Swapchain::getInstance();
    auto  image_index = swapchain.getCurrentImageIndex();
    auto& present_executor = executors::present;
    auto& graphic_executor = executors::tool;
    auto  image = swapchain.images()[image_index];
    auto  record_g2p = [&](VkCommandBuffer cmdbuf, bool acquire) {
      recordImageBarrier(
        cmdbuf,
        image,
        getSubresourceRange(VK_IMAGE_ASPECT_COLOR_BIT, vk::MipRange{ 0, 1 }),
        vk::LayoutTransitionInfo{
          _render_done_layout,
          VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
        },
        acquire ? vk::BarrierScope::acquire(vk::Scope{
                     .stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
                  })
                 : vk::BarrierScope::release(vk::Scope{
                     .stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
                  }),
        vk::FamilyTransferInfo{
          graphic_executor.getFamily(),
          present_executor.getFamily(),
        }
      );
    };
    auto render_done_sema = _image_resources[image].render_done_sema.get();
    auto graphic_release_sema = _image_resources[image].graphic_release_sema.get();
    auto present_acquire_sema = _image_resources[image].present_acquire_sema.get();
    graphic_executor.submit(
      [&](auto cmdbuf) { record_g2p(cmdbuf, false); },
      std::array{ WaitSemaphore{ render_done_sema, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT } },
      std::array{ graphic_release_sema }
    );
    present_executor[1].submit(
      [&](auto cmdbuf) { record_g2p(cmdbuf, true); },
      std::array{ WaitSemaphore{ graphic_release_sema, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT } },
      std::array{ present_acquire_sema }
    );
    if (!swapchain.present(present_acquire_sema, present_executor[1].getQueue())) {
      swapchain.updateCapabilities();
      swapchain.recreate();
    }
  }

private:
  VkImageLayout _available_layout;
  VkImageLayout _render_done_layout;

  struct ImageResource {
    Semaphore present_release_sema = { true };
    Semaphore graphic_acquire_sema = { true };
    Semaphore render_done_sema = { true };
    Semaphore graphic_release_sema = { true };
    Semaphore present_acquire_sema = { true };
  };

  std::map<VkImage, ImageResource> _image_resources;
};

} // namespace rd::vk