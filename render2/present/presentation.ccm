export module render.vk.presentation;

import std;
import toy;

import "vulkan_config.h";
import render.vk.sync;
import render.vk.swapchain;
import render.vk.tracker;
import render.vk.image;

export namespace rd::vk {

class Presentation {
public:
  Presentation(Swapchain& swapchain);

  struct PresentContext {
    // must consume semas until present()
    // sema that need wait until image is available (transfer to graphics and available_layout)
    VkSemaphore          wait_sema;
    uint32               image_index;
    bool                 need_recreate;
    ImageBarrierTracker& tracker;
  };

  auto prepare() -> std::optional<PresentContext>;
  /**
   * @brief must call after a success prepare()
   *
   */
  void present();

private:
  struct ImageResource {
    Semaphore           present_wait_sema = { true };
    Semaphore           present_transfer_sema = { true };
    ImageBarrierTracker tracker;
  };

  std::map<VkImage, ImageResource> _image_resources;

  bool _present_recreated;
};

Presentation::Presentation(Swapchain& swapchain) {
  auto images = swapchain.images();
  for (auto& image : images) {
    _image_resources[image] = ImageResource{
      .tracker =
        ImageBarrierTracker{
          image,
          getSubresourceRange(VK_IMAGE_ASPECT_COLOR_BIT, vk::MipRange{ 0, 1 }),
        },
    };
  }
}

} // namespace rd::vk