export module render.presentation;

import std;
import toy;

import "vulkan_config.h";
import render.vk.swapchain;

export namespace rd::vk {

class Presentation {
public:
  Presentation(VkImageLayout available_layout, VkImageLayout draw_done_layout);

  struct PresentContext {
    // must consume semas until present()
    // sema that need wait until image is available (transfer to graphics and available_layout)
    VkSemaphore wait_sema;
    // sema that need signal after draw is done and in draw_done_layout
    VkSemaphore signal_sema;
    uint32_t    image_index;
  };

  auto prepare() -> std::optional<PresentContext> {
    auto& swapchain = Swapchain::getInstance();
    if (!swapchain.valid()) {
      swapchain.updateCapabilities();
      if (swapchain.needRecreate()) {
        swapchain.recreate();
      }
    }
    if (swapchain.valid()) {
      auto image_available_sema = swapchain.getImageAvailableSema();
      auto image_index = swapchain.getCurrentImageIndex();
      // transfer new image ownership from present to graphics
      // transfer new image layout from presentable to <custom>

      return { {

        .image_index = image_index,
      } };
    } else {
      return std::nullopt;
    }
  }
  /**
   * @brief must call after a success prepare()
   *
   */
  void present() {
    // transfer image ownership from graphics to present
    // transfer image layout from <custom> to presentable

    if (!swapchain.present()) {
      swapchain.updateCapabilities();
      swapchain.recreate();
    }
  }

  void loop() {

    if (!swapchain.valid()) {
      swapchain.updateCapabilities();
      if (swapchain.needRecreate()) {
        swapchain.recreate();
      }
    }

    if (swapchain.valid()) {
      // ...
      // must consume it util present()
      auto image_available_sema = swapchain.getImageAvailableSema();
      auto image_index = swapchain.getCurrentImageIndex();

      // custom draw
      // offer image_available_sema (transfer done) to wait
      // offer draw_done_sema to signal
      // offer image index from swapchain
      // after wait image_available_sema, the image belongs to graphics
      // and has converted to <custom> layout
      // before signal draw_done_sema, the image must at <custom> layout

      // transfer image ownership from graphics to present
      // transfer image layout from <custom> to presentable

      if (!swapchain.present()) {
        swapchain.updateCapabilities();
        swapchain.recreate();
      }

      // transfer new image ownership from present to graphics
      // transfer new image layout from presentable to <custom>
    }
  }
};

} // namespace rd::vk