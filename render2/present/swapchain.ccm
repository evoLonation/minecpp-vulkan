export module render.vk.swapchain;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.tool;
import render.vk.device;
import render.vk.sync;
import render.vk.image;
import render.vk.surface;
import render.vk.device;

import std;
import toy;

export namespace rd::vk {

class Swapchain : public rs::Swapchain {
public:
  /**
   * @brief maybe empty
   * @param concurrent_image_count the max image count user can acquire at same time, must >= 1
   */
  Swapchain(VkSurfaceKHR surface, uint32 concurrent_image_count = 1);
  /**
   * @brief call this method when need newest _capabilities such as needRecreate(), recreate()
   */
  void updateCapabilities();
  /**
   * @brief check if need recreate resources by compare _swapchain_extent with
   * _capabilities.currentExtent
   */
  auto needRecreate() -> bool;
  /**
   * @brief recreate resources by current _capabilities (maybe empty)
   */
  void recreate();
  /**
   * @brief the wait_sema always be waited by present() except throws
   * @return false: the _image_available_sema will be unaffected,
   * and need recreate() before next present()
   */
  auto present(VkSemaphore wait_sema, VkQueue present_queue) -> bool;
  auto valid() -> bool { return get() != VK_NULL_HANDLE; }
  auto images() const -> std::span<const VkImage> { return _images; }
  auto image_views() const -> std::span<const rs::ImageView> { return _image_views; }
  auto getCurrentImageIndex() const -> uint32 { return _image_index; }
  auto extent() const -> VkExtent2D { return _swapchain_extent; }
  /**
   * @brief must wait it after successfully present() or create() (check by valid())
   */
  auto getImageAvailableSema() const -> VkSemaphore { return _image_available_sema; }

  static auto format() -> VkFormat { return _format; }

private:
  static VkFormat         _format;
  static VkPresentModeKHR _present_mode;
  static VkColorSpaceKHR  _color_space;

public:
  static auto checkPdevice(VkSurfaceKHR surface, DeviceCapabilityBuilder& request) -> bool;

private:
  VkSurfaceKHR _surface;

  uint32                   _min_image_count;
  VkSurfaceCapabilitiesKHR _capabilities;
  VkExtent2D               _swapchain_extent;
  Semaphore                _image_available_sema;
  Fence                    _image_available_fence;

  auto acquireNextImage() -> bool;

  /**
   * @brief create swapchain and images determined by _swapchain_extent, if _swapchain_extent is
   * zero then create empty resources
   */
  void create();
  // member below is created by create() (also contains rs::Swapchain base class)
  std::vector<VkImage>       _images;
  std::vector<rs::ImageView> _image_views;
  bool                       _last_present_failed;
  uint32                     _image_index;
};

} // namespace rd::vk