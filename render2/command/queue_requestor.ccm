export module render.vk.queue_requestor;

import "vulkan_config.h";
import render.vk.tool;
import render.vk.surface;
import render.vk.device;

import std;
import toy;

export namespace rd::vk {

/**
 * @brief 二分图匹配算法
 */
auto hungarian(std::span<const std::vector<int>> graph, int right_count)
  -> std::optional<std::vector<int>> {

  auto left_count = (int)graph.size();
  auto match = std::vector<int>(right_count);
  ranges::fill(match, -1);
  auto found = std::vector<bool>(right_count);

  auto results = std::vector<int>(left_count);

  std::function<bool(int)> dfs = [&](int u) -> bool {
    toy::debugf("u: {}", u);
    for (auto v : graph[u]) {
      toy::debugf("u {} lookup {}", u, v);
      if (!found[v]) {
        found[v] = true;
        if (match[v] == -1 || dfs(match[v])) {
          toy::debugf("u {} select {}", u, v);
          match[v] = u;
          results[u] = v;
          return true;
        }
      }
    }
    toy::debugf("u {} no satisfied select", u);
    return false;
  };

  if (!ranges::all_of(views::iota(0u, graph.size()), [&dfs, &found](int u) {
        ranges::fill(found, false);
        return dfs(u);
      })) {
    return std::nullopt;
  } else {
    return results;
  }
}

struct QueueFamilyCheckContext {
  VkPhysicalDevice        device;
  size_t                  index;
  VkQueueFamilyProperties properties;
};

struct QueueFamilyRequirement {
  std::function<bool(QueueFamilyCheckContext)> checker;
  uint32                                       queue_count;
};

class QueueRequestor {
public:
  QueueRequestor(std::span<QueueFamilyRequirement const> requirements)
    : _requirements(requirements | ranges::to<std::vector>()) {}
  auto checkPdevice(DeviceCapabilityBuilder& request) -> bool {
    auto& pdevice = request.getPdevice();

    auto family_count = pdevice.getAllQueueFamilyProperties().size();
    auto requirement_count = _requirements.size();
    toy::debugf(
      "queue family count: {}, queue family requirement count: {}", family_count, requirement_count
    );

    std::vector<std::vector<int>> graph(requirement_count);

    for (auto [family_i, properties] : pdevice.getAllQueueFamilyProperties() | toy::enumerate) {
      // auto queue_count = static_cast<int>(properties.queueCount);
      toy::debugf("check queue family {}, which has {} queues", family_i, properties.queueCount);
      for (auto [requirement_i, requirement] : _requirements | toy::enumerate) {
        // auto& [queue_checker, queue_number] = queue_requirement;
        if (properties.queueCount >= requirement.queue_count &&
            requirement.checker(QueueFamilyCheckContext{ pdevice.get(), family_i, properties })) {
          graph[requirement_i].push_back(family_i);
          toy::debugf("queue request {} success", requirement_i);
        } else {
          toy::debugf("queue request {} failed", requirement_i);
        }
      }
    }
    if (auto res = hungarian(graph, family_count); res.has_value()) {
      request.family_queue_counts.append_range(
        res.value() | toy::enumerate | views::transform([&](auto pair) {
          auto& [index, family] = pair;
          return FamilyQueueCount{ static_cast<uint32>(family), _requirements[index].queue_count };
        })
      );
      _pdevice2family_queue_counts[pdevice.get()] = request.family_queue_counts;
      return true;
    } else {
      return false;
    }
  }
  // call after Device is constructed
  auto getFamilyQueueCounts(Device const& device) -> std::span<FamilyQueueCount const> {
    return _pdevice2family_queue_counts[device.getPdevice().get()];
  }

private:
  std::vector<QueueFamilyRequirement>                                 _requirements;
  std::unordered_map<VkPhysicalDevice, std::vector<FamilyQueueCount>> _pdevice2family_queue_counts;
};

} // namespace rd::vk