export module render.vk.sync;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.device;

import std;
import toy;

export namespace rd::vk {

namespace sync {

auto checkPdevice(DeviceCapabilityBuilder& builder) -> bool {
  return builder.enableFeature(&VkPhysicalDeviceVulkan13Features::synchronization2);
}

} // namespace sync

class Semaphore : public rs::Semaphore {
public:
  Semaphore() = default;
  Semaphore(bool init);
};

class Fence : public rs::Fence {
public:
  Fence() = default;
  Fence(bool signaled);
  /**
   * @brief wait to signaled state
   */
  void wait(bool reset);
  void reset();
  auto isSignaled() -> bool;
};

void recordPipelineBarrier(
  VkCommandBuffer                         cmdbuf,
  std::span<const VkMemoryBarrier2>       memory_barriers,
  std::span<const VkBufferMemoryBarrier2> buffer_barriers,
  std::span<const VkImageMemoryBarrier2>  image_barriers
) {
  auto dependency_info = VkDependencyInfo{
    .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
    //  VK_DEPENDENCY_BY_REGION_BIT:
    //  实现可以分区域进行同步(前面写一部分，后面就可以先读一部分)
    .dependencyFlags = 0,
    .memoryBarrierCount = static_cast<uint32>(memory_barriers.size()),
    .pMemoryBarriers = memory_barriers.data(),
    .bufferMemoryBarrierCount = static_cast<uint32>(buffer_barriers.size()),
    .pBufferMemoryBarriers = buffer_barriers.data(),
    .imageMemoryBarrierCount = static_cast<uint32>(image_barriers.size()),
    .pImageMemoryBarriers = image_barriers.data(),
  };
  vkCmdPipelineBarrier2(cmdbuf, &dependency_info);
};

struct Scope {
  VkPipelineStageFlags2 stage_mask;
  VkAccessFlags2        access_mask;
};

/**
 * @brief In case of ownership transfer that with src_use_stage/access and dst_use_stage/access
 * barrier in src family:
 * - src_stage/access: src_use_stage, src_use_access
 * - dst_stage/access: NONE, 0 (by spec: dst_stage/access are ignored)
 * barrier in dst family:
 * - must wait semaphore, wait stage: TOP
 * - src_stage/access: NONE, 0 (by spec: src_stage/access are ignored)
 * - dst_stage/access: dst_use_stage, dst_use_access
 * dependency chain:
 * src_use -> release op -> src_command done -> dst_command's wait stage start execute -> acquire op
 * -> dst_use
 */
struct BarrierScope {
  Scope src_scope;
  Scope dst_scope;

  /**
   * @brief generate the barrier scope used to record release operation
   * @param src_scope the scope happen before release op
   */
  static auto release(Scope src_scope) -> BarrierScope {
    return {
      src_scope,
      Scope{ VK_PIPELINE_STAGE_NONE, VK_ACCESS_NONE },
    };
  }
  /**
   * @brief generate the barrier scope used to record acquire operation
   * @param dst_scope the scope happen after acquire op
   */
  static auto acquire(Scope dst_scope) -> BarrierScope {
    return {
      Scope{ VK_PIPELINE_STAGE_NONE, VK_ACCESS_NONE },
      dst_scope,
    };
  }
};

struct FamilyTransferInfo {
  uint32 src_family = VK_QUEUE_FAMILY_IGNORED;
  uint32 dst_family = VK_QUEUE_FAMILY_IGNORED;
};

void recordBufferBarrier(
  VkCommandBuffer    cmdbuf,
  VkBuffer           buffer,
  BarrierScope       barrier_scope,
  FamilyTransferInfo family_info
) {
  auto [src_scope, dst_scope] = barrier_scope;
  auto buffer_barrier = VkBufferMemoryBarrier2{
    .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
    .pNext = nullptr,
    .srcStageMask = src_scope.stage_mask,
    .srcAccessMask = src_scope.access_mask,
    .dstStageMask = dst_scope.stage_mask,
    .dstAccessMask = dst_scope.access_mask,
    .srcQueueFamilyIndex = family_info.src_family,
    .dstQueueFamilyIndex = family_info.dst_family,
    .buffer = buffer,
    .offset = 0,
    .size = VK_WHOLE_SIZE,
  };
  recordPipelineBarrier(cmdbuf, {}, { &buffer_barrier, 1 }, {});
}

struct LayoutTransitionInfo {
  VkImageLayout src_layout;
  VkImageLayout dst_layout;
};

void recordImageBarrier(
  VkCommandBuffer         cmdbuf,
  VkImage                 image,
  VkImageSubresourceRange subresource_range,
  LayoutTransitionInfo    layout_info,
  BarrierScope            barrier_scope,
  FamilyTransferInfo      family_info
) {
  auto [src_scope, dst_scope] = barrier_scope;
  auto image_barrier = VkImageMemoryBarrier2{
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
    .pNext = nullptr,
    .srcStageMask = src_scope.stage_mask,
    .srcAccessMask = src_scope.access_mask,
    .dstStageMask = dst_scope.stage_mask,
    .dstAccessMask = dst_scope.access_mask,
    .oldLayout = layout_info.src_layout,
    .newLayout = layout_info.dst_layout,
    .srcQueueFamilyIndex = family_info.src_family,
    .dstQueueFamilyIndex = family_info.dst_family,
    .image = image,
    .subresourceRange = subresource_range,
  };
  recordPipelineBarrier(cmdbuf, {}, {}, { &image_barrier, 1 });
}

} // namespace rd::vk