export module render.vk.command;

import "vulkan_config.h";
import render.vk.resource;

import std;
import toy;

export namespace rd::vk {

/**
 * @brief Create a Command Pool object
 *
 * @param family_index
 * @param short_live True means the commandbuffers from the pool will be short-lived, meaning that
 * they will by reset or freed in short time
 * @return CommandPool
 */
auto createCommandPool(uint32_t family_index, bool short_live) -> rs::CommandPool;

auto allocateCommandBuffers(VkCommandPool command_pool, uint32_t count) -> rs::CommandBuffers;

template <typename T>
concept Recorder = std::invocable<T, VkCommandBuffer>;

struct WaitSemaphore {
  VkSemaphore          sema;
  VkPipelineStageFlags stage_mask;
};

void recordAndSubmit(
  VkCommandBuffer                cmdbuf,
  VkQueue                        queue,
  Recorder auto&&                recorder,
  std::span<const WaitSemaphore> wait_infos,
  std::span<const VkSemaphore>   signal_semas,
  VkFence                        signal_fence
);

} // namespace rd::vk

namespace rd::vk {

void beginRecord(VkCommandBuffer cmdbuf);
void endAndSubmitRecord(
  VkCommandBuffer                cmdbuf,
  VkQueue                        queue,
  std::span<const WaitSemaphore> wait_infos,
  std::span<const VkSemaphore>   signal_semas,
  VkFence                        signal_fence
);

void recordAndSubmit(
  VkCommandBuffer                cmdbuf,
  VkQueue                        queue,
  Recorder auto&&                recorder,
  std::span<const WaitSemaphore> wait_infos,
  std::span<const VkSemaphore>   signal_semas,
  VkFence                        signal_fence
) {
  beginRecord(cmdbuf);
  recorder(cmdbuf);
  endAndSubmitRecord(cmdbuf, queue, wait_infos, signal_semas, signal_fence);
}

} // namespace rd::vk