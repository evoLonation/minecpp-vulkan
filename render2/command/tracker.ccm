export module render.vk.tracker;
import std;
import toy;
import render.vk.sync;
import render.vk.reflections;
import render.vk.executor;

import <vulkan_config.h>;

export namespace rd::vk {

using BarrierRecorder = std::function<void(VkCommandBuffer)>;
struct FamilyTransferRecorder {
  std::function<void(VkCommandBuffer)> release;
  std::function<void(VkCommandBuffer)> acquire;
  uint32                               release_family;
};

struct ImageAdditionalInfo {
  // if old reads exist, then layout is for old reads;
  // else if old write exists, then layout is for old write.
  VkImageLayout           _layout;
  VkImageSubresourceRange _subresource_range;
};

// note:
// 目前只可用于 每个family只有一个queue的 情况
// 单线程顺序执行
// todo:
// 可以同步一个buffer/image的子范围
// 可以同步不同Queue之间
template <bool IsImage>
class CommonBarrierTracker
  : private std::conditional_t<IsImage, ImageAdditionalInfo, std::tuple<>> {
private:
  using VkHandle = std::conditional_t<IsImage, VkImage, VkBuffer>;

public:
  CommonBarrierTracker() = default;
  CommonBarrierTracker(VkHandle handle, VkImageSubresourceRange subresource_range)
    : _handle(handle), _last_write_scope(), _last_read_stages(), _family() {
    // the resource first is not owned by any family
    _family = std::numeric_limits<uint32>::max();
    if constexpr (IsImage) {
      ImageAdditionalInfo::_layout = VK_IMAGE_LAYOUT_UNDEFINED;
      ImageAdditionalInfo::_subresource_range = subresource_range;
    }
  }
  auto valid() -> bool { return _handle.get() != nullptr; }
  /**
   * @brief Sync the new scope to old scope(s)
   * For read scope, it will generate a dependency between last write scope
   * For write scope, it will generate a dependency between all old read scopes or old write scope
   * For family change, all types new scope will sync to all types old scope, and it will generate a
   * ownership transfer.
   *
   * @param scope
   * @param family
   * @param layout
   * @return std::variant<BarrierRecorder, FamilyTransferRecorder>
   */
  auto syncScope(Scope scope, uint32 family, VkImageLayout layout)
    -> std::variant<BarrierRecorder, FamilyTransferRecorder>;

  /**
   * @brief Set the last scope of the dependency chain, generally call after the resource's scope
   * changed due to other factors, such as render pass since render pass will execute internal
   * dependency and change the scope of the resource.
   * After call, next syncScope() will generate a dependency between this scope and new scope
   *
   */
  void setNewScope(Scope scope, uint32 family, VkImageLayout layout);

  auto getNowScope() -> Scope;

  auto getNowFamily() -> uint32 { return _family; }

  template <typename = void>
    requires IsImage
  auto getSubresourceRange() -> VkImageSubresourceRange {
    return ImageAdditionalInfo::_subresource_range;
  }
  template <typename = void>
    requires IsImage
  auto getNowLayout() -> VkImageLayout {
    return ImageAdditionalInfo::_layout;
  }

private:
  std::unique_ptr<std::remove_pointer_t<VkHandle>, decltype([](auto) {})> _handle;

  // if _last_read_stages has value, they must newer than _last_write_scope
  // when _last_write_scope is set, _last_read_stages must be cleared
  // both are empty only before first syncScope() or setNewScope()
  Scope                 _last_write_scope;
  VkPipelineStageFlags2 _last_read_stages;
  uint32                _family;

  auto needFamilyTransfer(uint32 family) -> bool {
    return _family != family && _family != std::numeric_limits<uint32>::max();
  }

  auto needLayoutTransition(VkImageLayout layout) -> bool {
    if constexpr (IsImage) {
      return ImageAdditionalInfo::_layout != layout;
    } else {
      return false;
    }
  }

protected:
  auto generateRecorder(Scope src_scope, Scope dst_scope, uint32 family, VkImageLayout layout)
    -> std::variant<BarrierRecorder, FamilyTransferRecorder>;
};

template <bool IsImage>
auto CommonBarrierTracker<IsImage>::generateRecorder(
  Scope src_scope, Scope dst_scope, uint32 family, VkImageLayout layout
) -> std::variant<BarrierRecorder, FamilyTransferRecorder> {
  auto recorder = std::variant<BarrierRecorder, FamilyTransferRecorder>{};
  auto handle = _handle.get();
  if (!needFamilyTransfer(family)) {
    auto scopes = BarrierScope{ src_scope, dst_scope };
    if constexpr (IsImage) {
      auto subresource = ImageAdditionalInfo::_subresource_range;
      auto layouts = LayoutTransitionInfo{ ImageAdditionalInfo::_layout, layout };
      recorder = [handle, scopes, subresource, layouts](VkCommandBuffer cmdbuf) {
        recordImageBarrier(cmdbuf, handle, subresource, layouts, scopes, {});
      };
    } else {
      recorder = [handle, scopes](VkCommandBuffer cmdbuf) {
        recordBufferBarrier(cmdbuf, handle, scopes, {});
      };
    }
  } else {
    auto release_scopes = BarrierScope::release(src_scope);
    auto acquire_scopes = BarrierScope::acquire(dst_scope);
    auto families = FamilyTransferInfo{ _family, family };
    if constexpr (IsImage) {
      auto subresource = ImageAdditionalInfo::_subresource_range;
      auto layouts = LayoutTransitionInfo{ ImageAdditionalInfo::_layout, layout };
      recorder = FamilyTransferRecorder{
        .release =
          [handle, release_scopes, families, subresource, layouts](VkCommandBuffer cmdbuf) {
            recordImageBarrier(cmdbuf, handle, subresource, layouts, release_scopes, families);
          },
        .acquire =
          [handle, acquire_scopes, families, subresource, layouts](VkCommandBuffer cmdbuf) {
            recordImageBarrier(cmdbuf, handle, subresource, layouts, acquire_scopes, families);
          },
        .release_family = _family,
      };
    } else {
      recorder = FamilyTransferRecorder{
        .release = [handle, release_scopes, families](VkCommandBuffer cmdbuf
                   ) { recordBufferBarrier(cmdbuf, handle, release_scopes, families); },
        .acquire = [handle, acquire_scopes, families](VkCommandBuffer cmdbuf
                   ) { recordBufferBarrier(cmdbuf, handle, acquire_scopes, families); },
        .release_family = _family,
      };
    }
  }
  if constexpr (false) {
    toy::debugf(toy::NoLocation{}, "{} Barrier Info:", IsImage ? "Image" : "Buffer");
    toy::debugf(
      toy::NoLocation{}, "  Vk{}: {}", IsImage ? "Image" : "Buffer", reinterpret_cast<void*>(handle)
    );
    if (needFamilyTransfer(family)) {
      toy::debugf(
        toy::NoLocation{}, "  Generate 2 barriers for family transfer: {} -> {}", _family, family
      );
    }
    toy::debugf(toy::NoLocation{}, "  src scope: {}", scope2Str(src_scope));
    toy::debugf(toy::NoLocation{}, "  dst scope: {}", scope2Str(dst_scope));
    if constexpr (IsImage) {
      toy::debugf(
        toy::NoLocation{},
        "  layout transition: {} -> {}",
        refl::imageLayout(ImageAdditionalInfo::_layout),
        refl::imageLayout(layout)
      );
    }
  }
  return recorder;
}

template <bool IsImage>
auto CommonBarrierTracker<IsImage>::syncScope(Scope scope, uint32 family, VkImageLayout layout)
  -> std::variant<BarrierRecorder, FamilyTransferRecorder> {
  toy::throwf(scope.stage_mask != 0, "dst stage of STAGE_NONE in barrier is meaningless");
  if constexpr (IsImage) {
    toy::throwf(layout != VK_IMAGE_LAYOUT_UNDEFINED, "layout cannot be VK_IMAGE_LAYOUT_UNDEFINED");
  }
  auto type = checkAccessType(scope.access_mask);
  using enum AccessType;
  auto recorder = std::variant<BarrierRecorder, FamilyTransferRecorder>{};
  auto generateRecorder = [&](Scope src_scope) {
    recorder = this->generateRecorder(src_scope, scope, family, layout);
  };

  // if old reads exist, sync to all old reads, else sync to old write (no matter empty or not)
  auto syncWithAll = [&]() { generateRecorder(getNowScope()); };
  auto syncWithWrite = [&]() { generateRecorder(_last_write_scope); };
  auto clearOldScopes = [&]() {
    _last_write_scope = Scope{};
    _last_read_stages = 0;
  };
  auto updateScopes = [&]() {
    if (type == WRITE) {
      _last_write_scope = scope;
      _last_write_scope.access_mask = extractWriteAccess(_last_write_scope.access_mask);
    } else {
      _last_read_stages |= scope.stage_mask;
    }
  };
  // special case
  if (needFamilyTransfer(family) || needLayoutTransition(layout) || type == WRITE) {
    syncWithAll();
    clearOldScopes();
    updateScopes();
  } else {
    // only if type == READ
    syncWithWrite();
    updateScopes();
  }
  _family = family;
  if constexpr (IsImage) {
    ImageAdditionalInfo::_layout = layout;
  }
  return recorder;
}

template <bool IsImage>
void CommonBarrierTracker<IsImage>::setNewScope(Scope scope, uint32 family, VkImageLayout layout) {
  toy::throwf(scope.stage_mask != 0, "setNewScope: stage of STAGE_NONE is meaningless");
  // No matter what type of scope it is, just assign to write scope, so that we can ensure next
  // syncScope call can sync with it
  _last_read_stages = 0;
  _last_write_scope = scope;
  _family = family;
  if constexpr (IsImage) {
    ImageAdditionalInfo::_layout = layout;
  }
}

template <bool IsImage>
auto CommonBarrierTracker<IsImage>::getNowScope() -> Scope {
  auto scope = Scope{};
  if (_last_read_stages != 0) {
    scope = Scope{
      .stage_mask = _last_read_stages,
      .access_mask = VK_ACCESS_NONE,
    };
  } else {
    scope = _last_write_scope;
  }
  return scope;
}

template <bool IsImage>
class CommonWaitableTracker : public CommonBarrierTracker<IsImage> {
public:
  using CommonBarrierTracker<IsImage>::CommonBarrierTracker;
  ~CommonWaitableTracker() {
    if (this->valid()) {
      this->waitIdle();
    }
  }
  CommonWaitableTracker(CommonWaitableTracker&& a) noexcept = default;
  auto operator=(CommonWaitableTracker&& a) noexcept -> CommonWaitableTracker& {
    if (this->valid()) {
      this->waitIdle();
    }
    this->CommonBarrierTracker<IsImage>::operator=(std::move(a));
    return *this;
  }

  /**
   * @brief submit a barrier to sync with previous scope and wait
   * will not influence the state of resource last scope
   * even though we submit a barrier, since the barrier sync nothing dst, we can just ignore it
   */
  void waitIdle(uint64 nano_timeout = std::numeric_limits<uint64>::max());

  auto setNewScope(Scope scope, uint32 family, VkImageLayout layout) {
    _idle = false;
    this->CommonBarrierTracker<IsImage>::setNewScope(scope, family, layout);
  }
  auto syncScope(Scope scope, uint32 family, VkImageLayout layout) {
    _idle = false;
    return this->CommonBarrierTracker<IsImage>::syncScope(scope, family, layout);
  }

private:
  bool _idle = true;
};

template <bool IsImage>
void CommonWaitableTracker<IsImage>::waitIdle(uint64 nano_timeout) {
  if (_idle) {
    return;
  }
  auto layout = VK_IMAGE_LAYOUT_UNDEFINED;
  if constexpr (IsImage) {
    layout = this->getNowLayout();
  }
  auto src_scope = this->getNowScope();
  auto dst_scope = Scope{
    .stage_mask = VK_PIPELINE_STAGE_NONE,
    .access_mask = VK_ACCESS_NONE,
  };
  auto  ret = this->generateRecorder(src_scope, dst_scope, this->getNowFamily(), layout);
  auto& barrier = std::get<BarrierRecorder>(ret);
  auto& executor = CommandExecutorManager::getInstance()[this->getNowFamily()];
  executor.submit(barrier).wait(VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, nano_timeout);
  _idle = true;
}

/**
 * @brief the result of first call can ignore, or can just call setNewScope() first
 */
class BufferBarrierTracker {
public:
  BufferBarrierTracker() = default;
  BufferBarrierTracker(VkBuffer buffer) : _base(buffer, {}) {}

  auto valid() -> bool { return _base.valid(); }
  auto syncScope(Scope scope, uint32 family)
    -> std::variant<BarrierRecorder, FamilyTransferRecorder> {
    return _base.syncScope(scope, family, {});
  }
  void setNewScope(Scope scope, uint32 family) { _base.setNewScope(scope, family, {}); }

  void waitIdle(uint64 nano_timeout = std::numeric_limits<uint64>::max()) {
    _base.waitIdle(nano_timeout);
  }

  auto getNowScope() -> Scope { return _base.getNowScope(); }
  auto getNowFamily() -> uint32 { return _base.getNowFamily(); }

private:
  CommonWaitableTracker<false> _base;
};

class ImageBarrierTracker {
public:
  ImageBarrierTracker() = default;
  ImageBarrierTracker(VkImage image, VkImageSubresourceRange subresource_range)
    : _base(image, subresource_range) {}

  auto valid() -> bool { return _base.valid(); }
  auto syncScope(Scope scope, uint32 family, VkImageLayout layout)
    -> std::variant<BarrierRecorder, FamilyTransferRecorder> {
    return _base.syncScope(scope, family, layout);
  }
  void setNewScope(Scope scope, uint32 family, VkImageLayout layout) {
    _base.setNewScope(scope, family, layout);
  }
  void waitIdle(uint64 nano_timeout = std::numeric_limits<uint64>::max()) {
    _base.waitIdle(nano_timeout);
  }

  auto getNowScope() -> Scope { return _base.getNowScope(); }
  auto getNowFamily() -> uint32 { return _base.getNowFamily(); }
  auto getSubresourceRange() -> VkImageSubresourceRange { return _base.getSubresourceRange(); }
  auto getNowLayout() -> VkImageLayout { return _base.getNowLayout(); }

private:
  CommonWaitableTracker<true> _base;
};

} // namespace rd::vk
