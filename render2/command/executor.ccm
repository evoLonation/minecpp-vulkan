export module render.vk.executor:impl;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.device;
import render.vk.sync;
import render.vk.command;

import std;
import toy;

namespace rd::vk {

// 按照构造时的顺序
using QueueFamily = uint32;

struct PoolState {
  std::size_t allocate_n;
  std::size_t inuse_n;
};

template <typename ResourceT, typename Derived>
class CommonPool {

private:
  std::deque<ResourceT>   _resources;
  std::vector<ResourceT*> _resource_frees;

public:
  auto allocate() {
    ResourceT* resource;
    if (_resource_frees.empty()) {
      _resources.push_back(Derived::_creator());
      resource = &_resources.back();
    } else {
      resource = _resource_frees.back();
      _resource_frees.pop_back();
    }
    auto deleter = [&](ResourceT* resource) { _resource_frees.push_back(resource); };
    return std::unique_ptr<ResourceT, decltype(deleter)>{ resource, deleter };
  }
  auto getState() -> PoolState {
    return { _resources.size(), _resources.size() - _resource_frees.size() };
  }
};

class FencePool : public CommonPool<Fence, FencePool> {
private:
  friend CommonPool<Fence, FencePool>;
  static constexpr auto _creator = []() { return Fence{ false }; };
};
class SemaphorePool : public CommonPool<Semaphore, SemaphorePool> {
private:
  friend CommonPool<Semaphore, SemaphorePool>;
  static constexpr auto _creator = []() { return Semaphore{ true }; };
};

class CmdbufPool {
private:
  rs::CommandPool                 _cmd_pool;
  static constexpr auto           _cmdbuf_allocate_n = 5;
  std::vector<rs::CommandBuffers> _cmdbufs;
  std::vector<VkCommandBuffer>    _cmdbuf_frees;

public:
  CmdbufPool() = default;
  CmdbufPool(uint32 family_index) { _cmd_pool = createCommandPool(family_index, true); }

  auto allocate() {
    auto handle = VkCommandBuffer{};
    if (_cmdbuf_frees.empty()) {
      _cmdbufs.emplace_back(allocateCommandBuffers(_cmd_pool, _cmdbuf_allocate_n));
      auto resources = _cmdbufs.back().get();
      [&]<size_t... indices>(std::index_sequence<indices...> index_seq) {
        (_cmdbuf_frees.emplace_back(resources[indices]), ...);
      }(std::make_index_sequence<_cmdbuf_allocate_n - 1>{});
      handle = resources[_cmdbuf_allocate_n - 1];
    } else {
      handle = _cmdbuf_frees.back();
      _cmdbuf_frees.pop_back();
    }
    auto deleter = [&](VkCommandBuffer handle) { _cmdbuf_frees.push_back(handle); };
    return std::unique_ptr<std::remove_pointer_t<VkCommandBuffer>, decltype(deleter)>{
      handle, std::move(deleter)
    };
  }
  auto getState() -> PoolState {
    return { _cmdbufs.size() * _cmdbuf_allocate_n,
             _cmdbufs.size() * _cmdbuf_allocate_n - _cmdbuf_frees.size() };
  }
};

template <typename PoolT>
using PoolResource = toy::FuncRet<decltype(&PoolT::allocate)>;

template <typename ResourceT>
class ResourceRef {
private:
  static inline auto borrow_deleter = [](bool* borrowed) { *borrowed = false; };
  std::unique_ptr<bool, decltype(borrow_deleter)> _borrowed;

protected:
  ResourceT* _resource;

public:
  ResourceRef() = default;
  ResourceRef(ResourceT* resource, bool& borrowed) {
    borrowed = true;
    _borrowed.reset(&borrowed);
    _resource = resource;
  }
  auto& get() { return *_resource; }
};

class FenceRef : public ResourceRef<Fence> {
public:
  FenceRef() = default;
  FenceRef(Fence* fence, bool& borrowed, std::mutex& mutex)
    : ResourceRef<Fence>(fence, borrowed), _mutex(&mutex) {}
  void wait() {
    auto guard = std::lock_guard<std::mutex>{ *_mutex };
    get().wait(false);
  }
  auto isSignaled() -> bool {
    auto guard = std::lock_guard<std::mutex>{ *_mutex };
    return get().isSignaled();
  }

private:
  std::mutex* _mutex;
};
using SemaphoreRef = ResourceRef<Semaphore>;

class Waitable {
private:
  std::vector<SemaphoreRef> _semas;

public:
  Waitable() = default;
  Waitable(std::vector<SemaphoreRef> semas) : _semas(std::move(semas)) {}
  auto consume() -> SemaphoreRef;
};

export struct WaitInfo {
  Waitable&            waitable;
  VkPipelineStageFlags stage_mask;
};

export class CommandExecutor : public toy::ProactiveSingleton<CommandExecutor> {
public:
  auto submit(
    QueueFamily               family,
    uint32                  queue_index,
    Recorder auto&&           recorder,
    std::span<WaitInfo const> wait_infos,
    uint32                  signal_n
  ) -> std::pair<FenceRef, Waitable>;

  auto submit(
    QueueFamily                    family,
    uint32                       queue_index,
    Recorder auto&&                recorder,
    std::span<const WaitSemaphore> wait_infos,
    std::span<const VkSemaphore>   signal_semas
  ) -> FenceRef;

  class QueueExecutor {
  private:
    QueueFamily                   _family;
    std::pair<uint32, uint32> _queue_range;
    uint32                      _queue_index;

  public:
    QueueExecutor() = default;
    QueueExecutor(QueueFamily family, std::pair<uint32, uint32> queue_range)
      : _family(family), _queue_range(queue_range), _queue_index(queue_range.first) {}
    auto submit(
      Recorder auto&&                recorder,
      std::span<const WaitSemaphore> wait_infos,
      std::span<const VkSemaphore>   signal_semas
    ) -> FenceRef {
      return getInstance().submit(
        _family, _queue_index, std::forward<decltype(recorder)>(recorder), wait_infos, signal_semas
      );
    }
    auto submit(Recorder auto&& recorder, std::span<WaitInfo const> wait_infos, uint32 signal_n)
      -> std::pair<FenceRef, Waitable> {
      return getInstance().submit(
        _family, _queue_index, std::forward<decltype(recorder)>(recorder), wait_infos, signal_n
      );
    }

    auto getFamily() -> uint32 { return getInstance()._cmd_contexts.at(_family).family_index; }
    auto getQueue() -> VkQueue {
      return getInstance()._cmd_contexts.at(_family).queues[_queue_index];
    }

    auto operator[](uint32 queue_index) -> QueueExecutor& {
      _queue_index = _queue_range.first + queue_index;
      toy::throwf(_queue_index < _queue_range.second, "out of queue range");
      return *this;
    }
  };

  struct State {
    std::map<QueueFamily, PoolState> cmdbuf_states;
    PoolState                        fence_state;
    PoolState                        sema_state;
  };
  auto getState() -> State {
    auto guard = std::lock_guard<std::mutex>{ _mutex };
    return {
      _cmd_contexts | views::transform([](auto& ctx) {
        return std::pair{ ctx.first, ctx.second.cmdbuf_pool.getState() };
      }) |
        ranges::to<std::map>(),
      _fence_pool.getState(),
      _sema_pool.getState(),
    };
  }

  CommandExecutor(Device& device, std::span<FamilyQueueCount const> family_infos);
  ~CommandExecutor();
  CommandExecutor(const CommandExecutor&) noexcept = delete;
  CommandExecutor(CommandExecutor&&) noexcept = delete;
  auto operator=(const CommandExecutor&) noexcept -> CommandExecutor& = delete;
  auto operator=(CommandExecutor&&) noexcept -> CommandExecutor& = delete;

private:
  struct WorkingCmdbuf {
    PoolResource<CmdbufPool> cmdbuf;
    Fence*                   fence;
    std::vector<VkSemaphore> wait_semas;
    std::vector<VkSemaphore> signal_semas;
    WorkingCmdbuf(
      CmdbufPool&              pool,
      Fence*                   fence,
      std::vector<VkSemaphore> wait_semas,
      std::vector<VkSemaphore> signal_semas
    )
      : cmdbuf(pool.allocate()), fence(fence), wait_semas(std::move(wait_semas)),
        signal_semas(std::move(signal_semas)) {}
  };
  struct WorkingFence {
    PoolResource<FencePool> fence;

    bool borrowed;
    bool cmd_done;
    WorkingFence(FencePool& pool) : fence(pool.allocate()), borrowed(false), cmd_done(false) {}
  };
  struct WorkingSemaphore {
    PoolResource<SemaphorePool> sema;

    bool borrowed;
    bool signal_cmd_done;
    // if no wait, true
    bool wait_cmd_done;
    WorkingSemaphore(SemaphorePool& pool)
      : sema(pool.allocate()), borrowed(false), signal_cmd_done(false), wait_cmd_done(true) {}
  };
  using WorkingCmdbufs = std::map<VkCommandBuffer, WorkingCmdbuf>;
  using WorkingFences = std::map<VkFence, WorkingFence>;
  using WorkingSemaphores = std::map<VkSemaphore, WorkingSemaphore>;

  auto addWorkingFence() -> FenceRef;
  auto addWorkingSemas(uint32 sema_n) -> std::vector<SemaphoreRef>;
  auto addWorkingCmdbuf(
    CmdbufPool&              cmdbuf_pool,
    WorkingCmdbufs&          working_cmdbufs,
    Fence*                   fence,
    std::vector<VkSemaphore> wait_semas,
    std::vector<VkSemaphore> signal_semas
  ) -> VkCommandBuffer;

  struct CommandContext {
    uint32             family_index;
    std::vector<VkQueue> queues;
    CmdbufPool           cmdbuf_pool;
    WorkingCmdbufs       working_cmdbufs;
  };

  std::map<QueueFamily, CommandContext> _cmd_contexts;

private:
  void collect();

  FencePool     _fence_pool;
  SemaphorePool _sema_pool;

  WorkingFences     _working_fences;
  WorkingSemaphores _working_semas;

  std::mutex  _mutex;
  std::thread _thread;
  bool        _task_done;

  void task();

  struct SubmitImplResult {
    VkQueue                    queue;
    FenceRef                   borrowed_fence;
    std::vector<SemaphoreRef>  borrowed_semas;
    VkCommandBuffer            cmdbuf;
    std::vector<VkSemaphore>   signal_semas;
    std::vector<WaitSemaphore> wait_infos;
  };
  auto submitImpl(
    QueueFamily               family,
    uint32                  queue_index,
    std::span<WaitInfo const> wait_infos,
    uint32                  signal_n
  ) -> SubmitImplResult;
};

auto CommandExecutor::submit(
  QueueFamily               family,
  uint32                  queue_index,
  Recorder auto&&           recorder,
  std::span<WaitInfo const> wait_infos_,
  uint32                  signal_n
) -> std::pair<FenceRef, Waitable> {
  auto [queue, borrowed_fence, borrowed_semas, cmdbuf, signal_semas, wait_infos] =
    submitImpl(family, queue_index, wait_infos_, signal_n);
  recordAndSubmit(cmdbuf, queue, recorder, wait_infos, signal_semas, borrowed_fence.get());
  return std::pair{ std::move(borrowed_fence), std::move(borrowed_semas) };
}

auto CommandExecutor::submit(
  QueueFamily                    family,
  uint32                       queue_index,
  Recorder auto&&                recorder,
  std::span<const WaitSemaphore> wait_infos,
  std::span<const VkSemaphore>   signal_semas
) -> FenceRef {
  auto guard = std::lock_guard<std::mutex>{ _mutex };
  auto& [_, queues, cmdbuf_pool, working_cmdbufs] = _cmd_contexts.at(family);
  auto queue = queues[queue_index];
  auto borrowed_fence = addWorkingFence();
  auto cmdbuf = addWorkingCmdbuf(cmdbuf_pool, working_cmdbufs, &borrowed_fence.get(), {}, {});
  recordAndSubmit(cmdbuf, queue, recorder, wait_infos, signal_semas, borrowed_fence.get());
  return borrowed_fence;
}

export using WaitSemaphore = WaitSemaphore;

} // namespace rd::vk