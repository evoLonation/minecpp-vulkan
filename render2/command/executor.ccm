export module render.vk.executor;
import std;
import toy;

import render.vk.sync;
import render.vk.resource;
import render.vk.tool;
import render.vk.device;

import "vulkan_config.h";

export namespace rd::vk {

class CommandBuffer : public rs::CommandBuffer {
public:
  /**
   * @brief Construct a new Command Buffer object
   *
   * @param cmdbuf must is a newly created command buffer
   */
  CommandBuffer(rs::CommandBuffer cmdbuf) : rs::CommandBuffer(std::move(cmdbuf)), _semaphore{} {}

  /**
   * @brief Must ensure waitIdle can immediately return true (into idle state). Prepare for
   * submitting by record commands to cmdbuf and increase the semaphore signal value.
   *
   * @param recorder
   */
  void record(std::function<void(VkCommandBuffer cmdbuf)> const& recorder) {
    // vkBeginCommandBuffer 会隐式执行vkResetCommandBuffer
    // vkResetCommandBuffer(worker.command_buffer, 0);
    auto begin_info = VkCommandBufferBeginInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
      /** \param VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT specifies that each
       * recording of the command buffer will only be submitted once, and the
       * command buffer will be reset and recorded again between each submission.
       * \param VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT specifies that a
       * secondary command buffer is considered to be entirely inside a render
       * pass. If this is a primary command buffer, then this bit is ignored.
       * \param VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT specifies that a
       * command buffer can be resubmitted to any queue of the same queue family
       * while it is in the pending state, and recorded into multiple primary
       * command buffers.*/
      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
      .pInheritanceInfo = nullptr,
    };
    checkVkResult(vkBeginCommandBuffer(get(), &begin_info), "begin command buffer");
    recorder(get());
    checkVkResult(vkEndCommandBuffer(get()), "end command buffer");
    _semaphore.increaseValue();
  }
  /**
   * @brief Get the Timeline Semaphore and the value should be signaled after complete execute. Call
   * it after record().
   *
   * @return std::pair<VkSemaphore, uint64> The timeline semaphore and the value should be signaled
   * to, the executor must make the cmdbuf complete execute before the semaphore is signaled to the
   * value.
   */
  auto getSignalInfo() -> std::pair<VkSemaphore, uint64> {
    return { _semaphore.get(), _semaphore.getNewestValue() };
  }
  auto waitIdle(uint64 nano_timeout = std::numeric_limits<uint64>::max()) -> bool {
    return _semaphore.waitIdle(nano_timeout);
  }

private:
  TimelineSemaphore _semaphore;
};

class CommandBufferPool {
public:
  CommandBufferPool(uint32 family_index) {
    _pool = rs::CommandPool{ VkCommandPoolCreateInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
      // VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT：允许重置单个command
      // buffer，否则就要重置命令池里的所有buffer
      // VK_COMMAND_POOL_CREATE_TRANSIENT_BIT: 命令缓冲区会很频繁的记录新命令
      .flags =
        VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT | VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
      .queueFamilyIndex = family_index,
    } };
  }
  auto allocate() -> CommandBuffer {
    if (_idle_cmdbufs.size() == 0) {
      workingToIdle();
    } else {
      tryShrink();
    }
    if (_idle_cmdbufs.size() == 0) {
      expand();
    }
    auto ret = std::move(_idle_cmdbufs.back());
    _idle_cmdbufs.pop_back();
    return ret;
  }

  void recycle(CommandBuffer cmdbuf) { _working_cmdbufs.push_back(std::move(cmdbuf)); }

  CommandBufferPool(const CommandBufferPool&) noexcept = delete;
  CommandBufferPool(CommandBufferPool&&) noexcept = delete;
  auto operator=(const CommandBufferPool&) noexcept -> CommandBufferPool& = delete;
  auto operator=(CommandBufferPool&&) noexcept -> CommandBufferPool& = delete;

private:
  rs::CommandPool            _pool;
  std::vector<CommandBuffer> _idle_cmdbufs;
  std::list<CommandBuffer>   _working_cmdbufs;

  void workingToIdle() {
    for (auto iter = _working_cmdbufs.begin(); iter != _working_cmdbufs.end();) {
      if (iter->waitIdle(0)) {
        _idle_cmdbufs.push_back(std::move(*iter));
        iter = _working_cmdbufs.erase(iter);
      } else {
        iter++;
      }
    }
  }
  void expand() {
    auto cmdbufs = rs::CommandBuffers{ VkCommandBufferAllocateInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
      .commandPool = _pool,
      // VK_COMMAND_BUFFER_LEVEL_PRIMARY: 主缓冲区，类似于main
      // VK_COMMAND_BUFFER_LEVEL_SECONDARY: 次缓冲区，可复用，类似于其他函数
      .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
      .commandBufferCount = 5,
    } };
    _idle_cmdbufs.append_range(
      rs::CommandBuffers::split(std::move(cmdbufs)) |
      views::transform([](rs::CommandBuffer& cmdbuf) { return CommandBuffer(std::move(cmdbuf)); })
    );
  }

  void tryShrink() {
    auto shrink_size = 20;
    if (_idle_cmdbufs.size() <= shrink_size) {
      return;
    }
    toy::debugf("shrink {} -> {}", _idle_cmdbufs.size(), shrink_size);
    auto range = _idle_cmdbufs | views::transform([](CommandBuffer& cmdbuf) -> decltype(auto) {
                   return static_cast<rs::CommandBuffer&>(cmdbuf);
                 }) |
                 views::drop(shrink_size);
    rs::CommandBuffers::join(range);
    _idle_cmdbufs.erase(_idle_cmdbufs.begin() + shrink_size, _idle_cmdbufs.end());
  }
};

class CommandBufferRecyclable : public CommandBuffer {
public:
  CommandBufferRecyclable(CommandBufferPool* pool) : CommandBuffer(pool->allocate()), _pool(pool) {}
  ~CommandBufferRecyclable() { recycle(); }
  CommandBufferRecyclable(CommandBufferRecyclable&&) noexcept = default;

  auto operator=(CommandBufferRecyclable&& a) noexcept -> CommandBufferRecyclable& {
    recycle();
    CommandBuffer::operator=(std::move(a));
    _pool = a._pool;
    return *this;
  }

private:
  CommandBufferPool* _pool;

  void recycle() {
    if (get()) {
      _pool->recycle(std::move(*this));
    }
  }
};

// struct WaitInfo {
//   VkPipelineStageFlags stage_mask;
//   TimelineSemaphore    sema;
// };
// struct SignalInfo {
//   VkPipelineStageFlags stage_mask;
//   TimelineSemaphore    sema;
// };

/**
 * @brief Have ownership of cmdbuf will be submitted to and semaphores will be signaled by
 * submission of the cmdbuf, user can use it to signal another submit or host wait.
 * As long as the object is not destroyed, these semaphores and cmdbuf will remain associated
 * with this submission and will not be recycled.
 */
class Waitable {
public:
  Waitable(
    CommandBufferRecyclable                                                cmdbuf,
    std::unordered_map<VkPipelineStageFlags2, TimelineSemaphoreRecyclable> _stage_semas
  )
    : _stage_semas(std::move(_stage_semas)), _cmdbuf(std::move(cmdbuf)) {}

  auto wait(
    VkPipelineStageFlags2 stage = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    uint64                nano_timeout = std::numeric_limits<uint64>::max()
  ) -> bool {
    if (stage == VK_PIPELINE_STAGE_ALL_COMMANDS_BIT) {
      return _cmdbuf.waitIdle(nano_timeout);
    }
    return _stage_semas.at(stage).waitIdle(nano_timeout);
  }

  auto getWaitInfo(VkPipelineStageFlags2 stage) -> std::pair<VkSemaphore, uint64> {
    if (stage == VK_PIPELINE_STAGE_ALL_COMMANDS_BIT) {
      return _cmdbuf.getSignalInfo();
    }
    auto& sema = _stage_semas.at(stage);
    return { sema, sema.getNewestValue() };
  }

private:
  CommandBufferRecyclable                                                _cmdbuf;
  std::unordered_map<VkPipelineStageFlags2, TimelineSemaphoreRecyclable> _stage_semas;
};

struct CommandBatch {
  std::function<void(VkCommandBuffer)>                     recorder;
  std::vector<std::pair<Waitable*, VkPipelineStageFlags2>> waits;
  std::vector<VkPipelineStageFlags2>                       signals;
};

struct RawWaitCommandBatch {
  std::function<void(VkCommandBuffer)>                       recorder;
  std::vector<std::pair<VkSemaphore, VkPipelineStageFlags2>> waits;
  std::vector<VkPipelineStageFlags2>                         signals;
};
struct RawSignalCommandBatch {
  std::function<void(VkCommandBuffer)>                       recorder;
  std::vector<std::pair<Waitable*, VkPipelineStageFlags2>>   waits;
  std::vector<std::pair<VkSemaphore, VkPipelineStageFlags2>> signals;
};

class CommandExecutor {
public:
  CommandExecutor(uint32 family_index, uint32 queue_index, TimelineSemaphorePool* sema_pool)
    : _family_index(family_index), _cmdbuf_pool(family_index), _sema_pool(sema_pool) {
    vkGetDeviceQueue(Device::getInstance(), family_index, queue_index, &_queue);
  }
  auto submit(std::function<void(VkCommandBuffer)> recorder) -> Waitable {
    auto batch = CommandBatch{ std::move(recorder), {}, {} };
    return submit(batch);
  }
  /**
   * @brief submit a command batch to device, return the waitable. Waitable can be waited for
   * stages that include all stages in batch.signals on host (call waitable.wait()) and device
   * (call submit()).
   *
   * @param batch the batch to submit
   * @return Waitable
   */
  auto submit(CommandBatch const& batch) -> Waitable {
    auto [submit_info, waitable] = getSubmitInfo(batch);
    checkVkResult(vkQueueSubmit2(_queue, 1, &submit_info.info, VK_NULL_HANDLE), "submit queue");
    return std::move(waitable);
  }

  auto submit(std::span<CommandBatch const> batches) -> std::vector<Waitable> {
    auto submit_infos = std::vector<SubmitInfo>{};
    auto vk_submit_infos = std::vector<VkSubmitInfo2>{};
    auto waitables = std::vector<Waitable>{};
    for (auto& batch : batches) {
      auto [submit_info, waitable] = getSubmitInfo(batch);
      submit_infos.push_back(std::move(submit_info));
      vk_submit_infos.push_back(submit_info.info);
      waitables.push_back(std::move(waitable));
    }
    checkVkResult(
      vkQueueSubmit2(_queue, vk_submit_infos.size(), vk_submit_infos.data(), VK_NULL_HANDLE),
      "submit queue"
    );
    return waitables;
  }
  auto submit(RawWaitCommandBatch batch) -> Waitable {
    auto cmdbuf = CommandBufferRecyclable{ &_cmdbuf_pool };
    cmdbuf.record(batch.recorder);
    auto cmdbuf_info = std::make_unique<VkCommandBufferSubmitInfo>(VkCommandBufferSubmitInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
      .commandBuffer = cmdbuf.get(),
    });
    auto wait_infos = getWaitInfos(batch.waits);
    auto [waitable, signal_infos] = getSignalInfos(std::move(cmdbuf), batch.signals);
    auto submit_info = VkSubmitInfo2{
      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
      .waitSemaphoreInfoCount = static_cast<uint32_t>(wait_infos.size()),
      .pWaitSemaphoreInfos = wait_infos.data(),
      .commandBufferInfoCount = 1,
      .pCommandBufferInfos = cmdbuf_info.get(),
      .signalSemaphoreInfoCount = static_cast<uint32_t>(signal_infos.size()),
      .pSignalSemaphoreInfos = signal_infos.data(),
    };
    checkVkResult(vkQueueSubmit2(_queue, 1, &submit_info, VK_NULL_HANDLE), "submit queue");
    return std::move(waitable);
  }

  auto submit(RawSignalCommandBatch batch) -> Waitable {
    auto cmdbuf = CommandBufferRecyclable{ &_cmdbuf_pool };
    cmdbuf.record(batch.recorder);
    auto cmdbuf_info = std::make_unique<VkCommandBufferSubmitInfo>(VkCommandBufferSubmitInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
      .commandBuffer = cmdbuf.get(),
    });
    auto wait_infos = getWaitInfos(batch.waits);
    auto [waitable, signal_infos] = getSignalInfos(std::move(cmdbuf), batch.signals);
    auto submit_info = VkSubmitInfo2{
      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
      .waitSemaphoreInfoCount = static_cast<uint32_t>(wait_infos.size()),
      .pWaitSemaphoreInfos = wait_infos.data(),
      .commandBufferInfoCount = 1,
      .pCommandBufferInfos = cmdbuf_info.get(),
      .signalSemaphoreInfoCount = static_cast<uint32_t>(signal_infos.size()),
      .pSignalSemaphoreInfos = signal_infos.data(),
    };
    checkVkResult(vkQueueSubmit2(_queue, 1, &submit_info, VK_NULL_HANDLE), "submit queue");
    return std::move(waitable);
  }

  auto getFamily() const -> uint32 { return _family_index; }
  auto getQueue() const -> VkQueue { return _queue; }

private:
  struct SubmitInfo {
    VkSubmitInfo2                              info;
    std::vector<VkSemaphoreSubmitInfo>         wait_infos;
    std::vector<VkSemaphoreSubmitInfo>         signal_infos;
    std::unique_ptr<VkCommandBufferSubmitInfo> cmdbuf_info;
  };

  auto getWaitInfos(std::vector<std::pair<Waitable*, VkPipelineStageFlags2>> const& waits
  ) -> std::vector<VkSemaphoreSubmitInfo> {
    auto wait_infos = std::vector<VkSemaphoreSubmitInfo>{};
    for (auto& wait : waits) {
      auto [sema, value] = wait.first->getWaitInfo(wait.second);
      wait_infos.push_back(VkSemaphoreSubmitInfo{
        .sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
        .semaphore = sema,
        .value = value,
        .stageMask = wait.second,
      });
    }
    return wait_infos;
  }
  auto getWaitInfos(std::vector<std::pair<VkSemaphore, VkPipelineStageFlags2>> const& raw_waits
  ) -> std::vector<VkSemaphoreSubmitInfo> {
    auto wait_infos = std::vector<VkSemaphoreSubmitInfo>{};
    for (auto& [sema, stage] : raw_waits) {
      wait_infos.push_back(VkSemaphoreSubmitInfo{
        .sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
        .semaphore = sema,
        .stageMask = stage,
      });
    }
    return wait_infos;
  }

  auto getCmdbufSignalInfo(CommandBuffer& cmdbuf) -> VkSemaphoreSubmitInfo {
    auto [sema, value] = cmdbuf.getSignalInfo();
    return VkSemaphoreSubmitInfo{
      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
      .semaphore = sema,
      .value = value,
      .stageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    };
  }
  auto getSignalInfos(
    CommandBufferRecyclable                                           cmdbuf,
    std::vector<std::pair<VkSemaphore, VkPipelineStageFlags2>> const& signals
  ) -> std::pair<Waitable, std::vector<VkSemaphoreSubmitInfo>> {
    auto signal_infos = getWaitInfos(signals);
    signal_infos.push_back(getCmdbufSignalInfo(cmdbuf));
    return { Waitable{ std::move(cmdbuf), {} }, std::move(signal_infos) };
  }

  auto getSignalInfos(
    CommandBufferRecyclable cmdbuf, std::vector<VkPipelineStageFlags2> const& signals
  ) -> std::pair<Waitable, std::vector<VkSemaphoreSubmitInfo>> {
    auto signal_infos = std::vector<VkSemaphoreSubmitInfo>{};
    auto stage_signal_semas =
      std::unordered_map<VkPipelineStageFlags2, TimelineSemaphoreRecyclable>{};
    for (auto& signal : signals) {
      auto sema = TimelineSemaphoreRecyclable{ _sema_pool };
      signal_infos.push_back(VkSemaphoreSubmitInfo{
        .sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
        .semaphore = sema.get(),
        .value = sema.increaseValue(),
        .stageMask = signal,
      });
      stage_signal_semas.emplace(signal, std::move(sema));
    }
    signal_infos.push_back(getCmdbufSignalInfo(cmdbuf));
    return { Waitable{ std::move(cmdbuf), std::move(stage_signal_semas) },
             std::move(signal_infos) };
  }

  auto getSubmitInfo(CommandBatch const& batch) -> std::pair<SubmitInfo, Waitable> {
    auto cmdbuf = CommandBufferRecyclable{ &_cmdbuf_pool };
    cmdbuf.record(batch.recorder);
    auto cmdbuf_info = std::make_unique<VkCommandBufferSubmitInfo>(VkCommandBufferSubmitInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
      .commandBuffer = cmdbuf.get(),
    });
    auto wait_infos = getWaitInfos(batch.waits);
    auto [waitable, signal_infos] = getSignalInfos(std::move(cmdbuf), batch.signals);
    auto submit_info = VkSubmitInfo2{
      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
      .waitSemaphoreInfoCount = static_cast<uint32_t>(wait_infos.size()),
      .pWaitSemaphoreInfos = wait_infos.data(),
      .commandBufferInfoCount = 1,
      .pCommandBufferInfos = cmdbuf_info.get(),
      .signalSemaphoreInfoCount = static_cast<uint32_t>(signal_infos.size()),
      .pSignalSemaphoreInfos = signal_infos.data(),
    };
    return std::pair{
      SubmitInfo{
        .info = submit_info,
        .wait_infos = std::move(wait_infos),
        .signal_infos = std::move(signal_infos),
        .cmdbuf_info = std::move(cmdbuf_info),
      },
      std::move(waitable),
    };
  }

private:
  uint32  _family_index;
  VkQueue _queue;

  CommandBufferPool      _cmdbuf_pool;
  TimelineSemaphorePool* _sema_pool;
};

enum class FamilyType {
  GRAPHICS,
  TRANSFER,
  PRESENT,
};

// template <typename EnumT>
using EnumT = FamilyType;
class CommandExecutorManager : public toy::ProactiveSingleton<CommandExecutorManager> {
public:
  CommandExecutorManager(std::span<std::pair<EnumT, FamilyQueueCount> const> family_infos) {
    for (auto& [family, info] : family_infos) {
      auto& [family_i, count] = info;
      _families[family] = family_i;
      for (auto queue_index : views::iota(0u, count)) {
        _executors[family_i].emplace_back(family_i, queue_index, &_sema_pool);
      }
    }
  }

  auto operator[](uint32 family, uint32 queue_index) -> CommandExecutor& {
    return _executors.at(family).at(queue_index);
  }

  auto operator[](uint32 family) -> CommandExecutor& { return operator[](family, 0); }

  auto operator[](EnumT family, uint32 queue_index) -> CommandExecutor& {
    return operator[](_families.at(family), queue_index);
  }

  auto operator[](EnumT family) -> CommandExecutor& { return operator[](family, 0); }

private:
  TimelineSemaphorePool                                   _sema_pool;
  std::unordered_map<uint32, std::deque<CommandExecutor>> _executors;
  std::unordered_map<FamilyType, uint32>                  _families;
};

} // namespace rd::vk