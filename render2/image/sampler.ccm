export module render.sampler;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.tool;
import render.vk.device;
import render.vk.image;
import render.vk.buffer;
import render.vk.format;
import render.vk.sync;
import render.vk.executor;

import "stb_image.h";

import std;
import toy;

export namespace rd {

class SampledTexture : public vk::DeviceChecker<SampledTexture> {
private:
  vk::StagingBuffer _staging_buffer;

  vk::Image       _image;
  vk::rs::Sampler _sampler;

private:
  static constexpr auto _formats = std::array{ VK_FORMAT_R8G8B8A8_SRGB };
  static constexpr auto _usage =
    VkImageUsageFlags{ VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT |
                       VK_IMAGE_USAGE_TRANSFER_SRC_BIT };
  static constexpr auto _aspect = VK_IMAGE_ASPECT_COLOR_BIT;
  static constexpr auto _shader_read_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
  static inline auto    _max_anisotropy = float{};

  friend vk::DeviceChecker<SampledTexture>;
  static auto checkPdevice(const vk::PdeviceContext& ctx) -> bool {
    return ctx.checkFormatSupport(
      vk::FormatTarget::OPTIMAL_TILING,
      VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT |
        VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT,
      _formats
    );
  }

public:
  SampledTexture() = default;
  SampledTexture(const std::string& path, bool mipmap) {
    auto& ctx = vk::Device::getInstance();

    // todo: just execute once in whole program
    _max_anisotropy = ctx.properties().limits.maxSamplerAnisotropy;

    uint32_t width, height, channels;

    auto* pixels =
      stbi_load(path.data(), &(int&)width, &(int&)height, &(int&)channels, STBI_rgb_alpha);
    auto image_size = static_cast<VkDeviceSize>(width * height * 4);
    if (pixels == nullptr) {
      toy::throwf("failed to load image {}", path.data());
    }
    auto image_data = std::as_bytes(std::span{ pixels, image_size });
    toy::debugf("image {} info: width {}, height {}", path.data(), width, height);

    _staging_buffer = { image_data };

    stbi_image_free(pixels);

    auto mip_extents = std::vector<VkExtent2D>{};
    auto mip_range = vk::MipRange{
      .base_level = 0,
      .count = 1,
    };
    auto mip_levels = uint32_t{};
    if (mipmap) {
      mip_extents = vk::computeMipExtents({ width, height });
      mip_levels = mip_extents.size();
      mip_range.count = mip_levels;
    }

    _image = vk::Image{
      _formats[0], width, height, _usage, _aspect, mip_levels, VK_SAMPLE_COUNT_1_BIT,
    };

    _sampler = vk::createSampler(_max_anisotropy);

    auto& executor = vk::CommandExecutor::getInstance();
    auto  copy_executor = executor[vk::QueueFamily::TRANSFER];
    auto  graphics_executor = executor[vk::QueueFamily::GRAPHICS][0];
    auto  family_transfer =
      vk::FamilyTransferInfo{ copy_executor.getFamily(), graphics_executor.getFamily() };

    auto recorder_copy = [&](VkCommandBuffer cmdbuf) {
      vk::recordImageBarrier(
        cmdbuf,
        _image,
        vk::getSubresourceRange(_aspect, mip_range),
        { VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL },
        {
          vk::Scope{
            .stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
          },
          vk::Scope{
            .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
            .access_mask = VK_ACCESS_TRANSFER_WRITE_BIT,
          },
        },
        {}
      );

      vk::copyBufferToImage(cmdbuf, _staging_buffer, _image, _aspect, width, height, 0);

      vk::recordImageBarrier(
        cmdbuf,
        _image,
        vk::getSubresourceRange(_aspect, mip_range),
        {
          VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
          mipmap ? VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        },
        vk::BarrierScope::release(vk::Scope{
          .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
          .access_mask = VK_ACCESS_TRANSFER_WRITE_BIT,
        }),
        family_transfer
      );
    };

    auto recorder_blit = [&](VkCommandBuffer cmdbuf) {
      vk::recordImageBarrier(
        cmdbuf,
        _image,
        vk::getSubresourceRange(_aspect, mip_range),
        {
          VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
          mipmap ? VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        },
        vk::BarrierScope::acquire(mipmap ? vk::Scope{
          .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
          .access_mask = VK_ACCESS_TRANSFER_WRITE_BIT | VK_ACCESS_TRANSFER_READ_BIT,
        }: vk::Scope{
          .stage_mask = _shader_read_stage,
          .access_mask = VK_ACCESS_SHADER_READ_BIT,
        }),
        family_transfer
      );

      if (mipmap) {
        for (auto dst_mip_level : views::iota(1u, mip_extents.size())) {
          vk::recordImageBarrier(
            cmdbuf,
            _image,
            vk::getSubresourceRange(
              _aspect, vk::MipRange{ .base_level = dst_mip_level - 1, .count = 1 }
            ),
            { VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL },
            { vk::Scope{
                .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
                .access_mask = VK_ACCESS_TRANSFER_WRITE_BIT,
              },
              vk::Scope{
                .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
                .access_mask = VK_ACCESS_TRANSFER_READ_BIT,
              } },
            {}
          );
          vk::blitImage(
            cmdbuf,
            vk::ImageBlit{
              .image = _image,
              .aspect = _aspect,
              .layout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
              .mip_level = dst_mip_level - 1,
              .extent = mip_extents[dst_mip_level - 1],
            },
            vk::ImageBlit{
              .image = _image,
              .aspect = _aspect,
              .layout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
              .mip_level = dst_mip_level,
              .extent = mip_extents[dst_mip_level],
            }
          );
        }
        vk::recordImageBarrier(
          cmdbuf,
          _image,
          vk::getSubresourceRange(_aspect, { .base_level = mip_levels - 1, .count = 1 }),
          { VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL },
          { vk::Scope{
              .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
              .access_mask = VK_ACCESS_TRANSFER_WRITE_BIT,
            },
            vk::Scope{
              .stage_mask = _shader_read_stage,
              .access_mask = VK_ACCESS_SHADER_READ_BIT,
            } },
          {}
        );
        vk::recordImageBarrier(
          cmdbuf,
          _image,
          vk::getSubresourceRange(_aspect, { .base_level = 0, .count = mip_levels - 1 }),
          { VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL },
          { vk::Scope{
              .stage_mask = VK_PIPELINE_STAGE_TRANSFER_BIT,
              .access_mask = 0,
            },
            vk::Scope{
              .stage_mask = _shader_read_stage,
              .access_mask = VK_ACCESS_SHADER_READ_BIT,
            } },
          {}
        );
      }
    };

    auto waitable = copy_executor.submit(recorder_copy, {}, 1).second;
    auto fence = graphics_executor
                   .submit(
                     recorder_blit,
                     std::array{ vk::WaitInfo{ waitable, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT } },
                     0
                   )
                   .first;
    // todo: no need to wait, sync with sema
    fence.get().wait();
  }
};

} // namespace rd