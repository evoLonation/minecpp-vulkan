export module render.sampler;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.device;
import render.vk.image;
import render.vk.buffer;

import std;
import toy;

export namespace rd {

class SampledTexture {
public:
  SampledTexture() = default;
  SampledTexture(const std::string& path, bool mipmap, VkPipelineStageFlagBits use_stage);
  auto image() const -> VkImage { return _image; }
  auto image_view() const -> VkImageView { return _image.image_view(); }
  auto sampler() const -> VkSampler { return _sampler; }
  auto getLayout() const -> VkImageLayout { return VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; }

private:
  vk::StagingBuffer _staging_buffer;

  vk::Image       _image;
  vk::rs::Sampler _sampler;

private:
  static std::vector<VkFormat> _formats;

  static constexpr auto _usage =
    VkImageUsageFlags{ VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT |
                       VK_IMAGE_USAGE_TRANSFER_SRC_BIT };
  static constexpr auto _aspect = VK_IMAGE_ASPECT_COLOR_BIT;
  static inline auto    _max_anisotropy = float{};

public:
  static auto device_checker(vk::DeviceCapabilityRequest& request) -> bool {
    return request.getPdevice().checkFormatSupport(
      vk::FormatTarget::OPTIMAL_TILING,
      VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT |
        VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT,
      _formats
    );
  }
};

} // namespace rd