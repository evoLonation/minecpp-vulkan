/*
 * instance, extension, layer相关
 * instance: vulkan最底层的对象，一切皆源于instance，存储几乎所有状态
 */
export module render.vk.instance;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.tool;
import toy;
import std;

export namespace rd::vk {

struct DebugMessengerConfig {
  VkDebugUtilsMessageSeverityFlagBitsEXT message_severity_level;
  VkDebugUtilsMessageTypeFlagsEXT        message_type_flags;
};

auto getDebugMessengerInfo(const DebugMessengerConfig& config
) -> VkDebugUtilsMessengerCreateInfoEXT;

template <bool enable>
struct DebugMessenger;
template <>
struct DebugMessenger<false> {};
template <>
struct DebugMessenger<true> {
  DebugMessengerConfig _config;
  rs::DebugMessenger   _messenger;
};

VKAPI_ATTR VkBool32 VKAPI_CALL debugHandler(
  VkDebugUtilsMessageSeverityFlagBitsEXT      message_severity,
  VkDebugUtilsMessageTypeFlagsEXT             message_type,
  const VkDebugUtilsMessengerCallbackDataEXT* p_callback_data,
  void*                                       p_user_data
);

class Instance : public rs::Instance,
                 private DebugMessenger<toy::enable_debug>,
                 public toy::ProactiveSingleton<Instance> {
public:
  Instance(const std::string& app_name, std::span<std::string> extensions) {

    auto debug_info = std::optional<VkDebugUtilsMessengerCreateInfoEXT>{};
    using DebugMessenger = DebugMessenger<toy::enable_debug>;
    if (toy::enable_debug) {
      DebugMessenger::_config = DebugMessengerConfig{
        .message_severity_level = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
        .message_type_flags = VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT,
      };
      debug_info = VkDebugUtilsMessengerCreateInfoEXT{
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
        .messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
        .messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
                       VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
                       VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
        .pfnUserCallback = debugHandler,
        .pUserData = reinterpret_cast<void*>(&(DebugMessenger::_config)),
      };
    }

    /*
     * 1. 创建appInfo
     * 2. 创建createInfo（指向appInfo）
     * 3. 调用createInstance创建instance
     */

    auto app_info = VkApplicationInfo{
      .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
      .pApplicationName = app_name.data(),
      .applicationVersion = VK_MAKE_VERSION(1, 0, 0),
      .engineVersion = VK_MAKE_VERSION(1, 0, 0),
      .apiVersion = VK_API_VERSION_1_0,
    };

    std::vector<const char*> required_extensions;
    std::vector<const char*> required_layers;

    required_extensions.append_range(extensions | views::transform([](const auto& str) {
                                       return str.data();
                                     }));

    if (debug_info.has_value()) {
      // VK_EXT_debug_utils 扩展用于扩展debug功能
      required_extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
      required_layers.push_back("VK_LAYER_KHRONOS_validation");
    }

    checkAvaliableSupports(
      required_extensions,
      getVkResources(vkEnumerateInstanceExtensionProperties, nullptr),
      [](auto& extension) { return extension.extensionName; }
    );

    checkAvaliableSupports(
      required_layers,
      getVkResources(vkEnumerateInstanceLayerProperties),
      [](auto& layer) { return layer.layerName; }
    );

    auto create_info = VkInstanceCreateInfo{
      .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
      .pNext = debug_info.has_value() ? &debug_info.value() : nullptr,
      .pApplicationInfo = &app_info,
      .enabledLayerCount = (uint32_t)required_layers.size(),
      .ppEnabledLayerNames = required_layers.data(),
      .enabledExtensionCount = (uint32_t)required_extensions.size(),
      .ppEnabledExtensionNames = required_extensions.data(),
    };

    rs::Instance::operator=({ create_info });
    if (debug_info.has_value()) {
      DebugMessenger::_messenger = { debug_info.value() };
    }
  }
};

} // namespace rd::vk
