export module render.vk.device;

import std;
import toy;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.format;

export namespace rd::vk {

enum class FormatTarget {
  BUFFER,
  OPTIMAL_TILING,
  LINEAR_TILING,
};

class PhysicalDevice {
private:
  VkPhysicalDevice           device;
  VkPhysicalDeviceProperties properties;
  VkPhysicalDeviceFeatures   features;

public:
  auto get() const -> VkPhysicalDevice;
  auto getProperties() const -> VkPhysicalDeviceProperties const&;
  auto getFeatures() const -> VkPhysicalDeviceFeatures const&;
  auto checkFormatSupport(
    FormatTarget type, VkFormatFeatureFlags features, std::span<VkFormat const> formats
  ) const -> bool;
};

struct DeviceCapabilityRequest {
  std::vector<std::string>                          extensions;
  std::vector<VkBool32 VkPhysicalDeviceFeatures::*> features;
};

using DeviceChecker =
  std::function<std::tuple<bool, DeviceCapabilityRequest>(const PhysicalDevice&)>;

class Device;

class DeviceBuilder {
public:
  auto addChecker(DeviceChecker checker);
  auto setQueueInfo();
  void buildDevice();

private:
};

class Device : public rs::Device, public toy::ProactiveSingleton<Device> {
public:
  Device();

  auto getPdevice() const { return _pdevice; }
  auto getEnableFeatures() const -> const VkPhysicalDeviceFeatures& { return _features; }
  auto getEnableExtensions() const -> std::span<std::string>;

  using toy::ProactiveSingleton<Device>::getInstance;

  PhysicalDevice           _pdevice;
  VkPhysicalDeviceFeatures _features;
};

} // namespace rd::vk