export module render.vk.device;

import std;
import toy;

import "vulkan_config.h";
import render.vk.resource;

export namespace rd::vk {

enum class FormatTarget {
  BUFFER,
  OPTIMAL_TILING,
  LINEAR_TILING,
};

class PhysicalDevice {
public:
  PhysicalDevice() = default;
  PhysicalDevice(VkPhysicalDevice pdevice);
  auto get() const -> VkPhysicalDevice { return _handle; }
  auto getProperties() const -> VkPhysicalDeviceProperties const& { return _properties; }
  auto getFeatures() const -> VkPhysicalDeviceFeatures const& { return _features; }
  auto getVk12Features() const -> VkPhysicalDeviceVulkan12Features const& { return _vk12features; }
  auto getVk13Features() const -> VkPhysicalDeviceVulkan13Features const& { return _vk13features; }
  auto getMemoryProperties() const -> VkPhysicalDeviceMemoryProperties const& {
    return _memory_properties;
  }
  auto getAllQueueFamilyProperties() const -> std::span<VkQueueFamilyProperties const> {
    return _queue_family_properties;
  }
  auto getAllExtensionProperties() const
    -> std::unordered_map<std::string, VkExtensionProperties> const {
    return _extension_properties;
  }
  auto checkFormatSupport(
    FormatTarget type, VkFormatFeatureFlags features, std::span<VkFormat const> formats
  ) const -> bool;

private:
  VkPhysicalDevice                                       _handle;
  VkPhysicalDeviceProperties                             _properties;
  VkPhysicalDeviceFeatures                               _features;
  VkPhysicalDeviceVulkan12Features                       _vk12features;
  VkPhysicalDeviceVulkan13Features                       _vk13features;
  VkPhysicalDeviceMemoryProperties                       _memory_properties;
  std::vector<VkQueueFamilyProperties>                   _queue_family_properties;
  std::unordered_map<std::string, VkExtensionProperties> _extension_properties;
  std::unordered_map<VkFormat, VkFormatProperties> mutable _format_properties;
};

struct FamilyQueueCount {
  uint32 family_index;
  uint32 queue_count;
};

struct DeviceCapabilityBuilder {
  DeviceCapabilityBuilder() = default;
  DeviceCapabilityBuilder(PhysicalDevice const& device) : _device(&device) {}
  std::vector<std::string>                                  extensions;
  std::vector<VkBool32 VkPhysicalDeviceFeatures::*>         features;
  std::vector<VkBool32 VkPhysicalDeviceVulkan12Features::*> vk12features;
  std::vector<VkBool32 VkPhysicalDeviceVulkan13Features::*> vk13features;
  std::vector<FamilyQueueCount>                             family_queue_counts;

  auto enableExtension(std::string name) -> bool {
    if (_device->getAllExtensionProperties().contains(name)) {
      extensions.push_back(name);
      return true;
    }
    return false;
  }
  auto enableFeature(VkBool32 VkPhysicalDeviceFeatures::*member) -> bool {
    if (_device->getFeatures().*member) {
      features.push_back(member);
      return true;
    }
    return false;
  }
  auto enableFeature(VkBool32 VkPhysicalDeviceVulkan13Features::*member) -> bool {
    if (_device->getVk13Features().*member) {
      vk13features.push_back(member);
      return true;
    }
    return false;
  }
  auto enableFeature(VkBool32 VkPhysicalDeviceVulkan12Features::*member) -> bool {
    if (_device->getVk12Features().*member) {
      vk12features.push_back(member);
      return true;
    }
    return false;
  }
  auto getPdevice() -> const PhysicalDevice& { return *_device; }

private:
  PhysicalDevice const* _device;
};

using DeviceCapabilityChecker = std::function<bool(DeviceCapabilityBuilder& request)>;
class Device : public rs::Device, public toy::ProactiveSingleton<Device> {
public:
  Device(std::span<DeviceCapabilityChecker> checkers, rs::Instance& instance);

  auto getPdevice() const { return _pdevice; }
  auto getEnabledFeatures() const -> const VkPhysicalDeviceFeatures& { return _features; }
  auto getEnabledExtensions() const -> std::span<std::string>;

  using toy::ProactiveSingleton<Device>::getInstance;

private:
  PhysicalDevice           _pdevice;
  VkPhysicalDeviceFeatures _features;
};

} // namespace rd::vk