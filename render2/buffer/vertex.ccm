export module render.vertex;

import "vulkan_config.h";
import render.vk.device;
import render.vk.buffer;
import render.vk.sync;
import render.vk.tracker;

import std;
import glm;
import toy;

namespace rd {

template <VkFormat format_, typename T>
  requires std::is_trivially_copyable_v<T>
struct FormatTypeInfo {
  static constexpr auto format = format_;
  using type = T;
};

using FormatTypeInfos = toy::TypePack<
  FormatTypeInfo<VK_FORMAT_R32G32_SFLOAT, glm::vec2>,        //
  FormatTypeInfo<VK_FORMAT_R32G32B32_SFLOAT, glm::vec3>,     //
  FormatTypeInfo<VK_FORMAT_R32G32B32A32_SFLOAT, glm::vec4>,  //
  FormatTypeInfo<VK_FORMAT_R32_SFLOAT, float>,               //
  FormatTypeInfo<VK_FORMAT_R64G64_SFLOAT, glm::dvec2>,       //
  FormatTypeInfo<VK_FORMAT_R64G64B64_SFLOAT, glm::dvec3>,    //
  FormatTypeInfo<VK_FORMAT_R64G64B64A64_SFLOAT, glm::dvec4>, //
  FormatTypeInfo<VK_FORMAT_R64_SFLOAT, double>               //
  >;

export namespace vk::device_checkers {
auto vertex(vk::DeviceCapabilityBuilder&) -> bool;
}

export struct VertexInfo {
  const VkVertexInputBindingDescription*             binding_description;
  std::span<const VkVertexInputAttributeDescription> attribute_descriptions;
  friend auto operator==(const VertexInfo& a, const VertexInfo& b) -> bool;
  VertexInfo() = default;
  VertexInfo(
    const VkVertexInputBindingDescription*             binding_description,
    std::span<const VkVertexInputAttributeDescription> attribute_descriptions
  )
    : binding_description(binding_description), attribute_descriptions(attribute_descriptions) {}
};

template <typename Type>
consteval auto formatMapper() -> VkFormat {
  return FormatTypeInfos::filter<[]<typename T>() {
    return std::same_as<typename T::type, Type>;
  }>::template at<0>::format;
}

export template <typename... DataTypes>
  requires(std::is_trivially_copyable_v<DataTypes> && ...)
struct Vertex {
public:
  Vertex(const DataTypes&... data) {
    int i = 0;
    ((*reinterpret_cast<DataTypes*>(
        std::launder(reinterpret_cast<char*>(&storage) + align_info.second[i])
      ) = data,
      i++),
     ...);
  }
  static auto getVertexInfo() -> VertexInfo {
    return { &binding_description<>, attribute_descriptions<> };
  }

private:
  static constexpr auto align_info = []() {
    auto alignments = std::array{ alignof(DataTypes)... };
    auto sizeofs = std::array{ sizeof(DataTypes)... };
    auto alignment = size_t{ 0 };
    auto offsets = std::array<uint32, sizeof...(DataTypes)>{};

    alignment = *ranges::max_element(alignments);
    offsets[0] = 0;
    for (auto i = 1; i < sizeof...(DataTypes); i++) {
      auto unalign_offset = offsets[i - 1] + sizeofs[i - 1];
      offsets[i] =
        (unalign_offset / alignments[i] + static_cast<bool>(unalign_offset % alignments[i])) *
        alignments[i];
    }
    return std::pair{ alignment, offsets };
  }();
  using Base = std::aligned_storage_t<
    align_info.second.back() + sizeof(typename toy::TypePack<DataTypes...>::template at<-1>),
    align_info.first>;
  Base storage;

  // must make the static member as template variable, otherwise the Vertex is incomplete type when
  // construct the variable
  template <typename = void>
  static constexpr auto binding_description = VkVertexInputBindingDescription{
    .binding = 0,
    .stride = sizeof(Vertex),
    // VK_VERTEX_INPUT_RATE_{VERTEX|INSTANCE}:
    // 是在每个vertex或者instance后移动到下一个data entry
    .inputRate = VK_VERTEX_INPUT_RATE_VERTEX,
  };
  template <typename = void>
  static constexpr auto attribute_descriptions = []() {
    auto attribute_descriptions =
      std::array<VkVertexInputAttributeDescription, sizeof...(DataTypes)>{};
    uint32 i = 0;
    ((attribute_descriptions[i] =
        VkVertexInputAttributeDescription{
          .location = i,
          .binding = 0,
          .format = formatMapper<DataTypes>(),
          .offset = align_info.second[i],
        },
      i++),
     ...);
    return attribute_descriptions;
  }();
};

class DeviceLocalBuffer : public vk::Buffer {
private:
  vk::StagingBuffer        _staging_buffer;
  vk::BufferBarrierTracker _tracker;

public:
  DeviceLocalBuffer() = default;

  DeviceLocalBuffer(
    VkBufferUsageFlags usage, vk::Scope dst_scope, std::span<const std::byte> buffer_data
  );
};

export class VertexBuffer : public DeviceLocalBuffer {
private:
  VertexInfo _vertex_info;

public:
  VertexBuffer() = default;
  template <ranges::contiguous_range R>
  VertexBuffer(R&& range) : VertexBuffer{ std::span<const ranges::range_value_t<R>>{ range } } {}
  template <toy::InstantiationOf<Vertex> VertexT>
  // using VertexT = Vertex<glm::vec3>;
  VertexBuffer(std::span<const VertexT> vertex_data)
    : VertexBuffer(std::as_bytes(vertex_data), VertexT::getVertexInfo()) {}

  auto getVertexInfo() const -> VertexInfo { return _vertex_info; }

private:
  VertexBuffer(std::span<const std::byte> vertex_data, VertexInfo vertex_info);
};

export class IndexBuffer : public DeviceLocalBuffer {
public:
  auto getIndexType() -> VkIndexType { return VK_INDEX_TYPE_UINT16; }

private:
  int _index_number;

public:
  IndexBuffer() = default;
  IndexBuffer(std::span<const uint16_t> indices);

  auto getIndexNumber() -> uint32 { return _index_number; }
};

} // namespace rd
