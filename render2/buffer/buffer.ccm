export module render.vk.buffer;

import std;
import toy;

import "vulkan_config.h";
import render.vk.tool;
import render.vk.resource;
import render.vk.device;
import render.vk.memory;

export namespace rd::vk {

auto createBuffer(VkDeviceSize buffer_size, VkBufferUsageFlags usage) -> rs::Buffer {
  auto buffer_info = VkBufferCreateInfo{
    .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    .size = buffer_size,
    .usage = usage,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
  };
  return { Device::getInstance(), buffer_info };
}

class Buffer : public rs::Buffer {
public:
  Buffer() = default;
  Buffer(VkDeviceSize buffer_size, VkBufferUsageFlags usage, VkMemoryPropertyFlags property_flags) {
    rs::Buffer::operator=(createBuffer(buffer_size, usage));
    _memory = { get(), property_flags };
  }
  auto memory() const -> VkDeviceMemory { return _memory; }

private:
  Memory _memory;
};

class HostVisibleBuffer : public Buffer {
public:
  HostVisibleBuffer() = default;
  HostVisibleBuffer(VkDeviceSize buffer_size, VkBufferUsageFlags usage)
    : Buffer(buffer_size, usage, HostVisibleMemory::propreties), _memory(Buffer::memory()) {}
  HostVisibleBuffer(std::span<const std::byte> buffer_data, VkBufferUsageFlags usage)
    : HostVisibleBuffer(buffer_data.size(), usage) {
    memory().fill(buffer_data);
  }
  auto memory() -> HostVisibleMemory& { return _memory; }
  auto operator->() -> HostVisibleMemory& { return _memory; }

private:
  HostVisibleMemory _memory;
};

class StagingBuffer : public HostVisibleBuffer {
public:
  StagingBuffer() = default;
  StagingBuffer(VkDeviceSize buffer_size)
    : HostVisibleBuffer(buffer_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT) {}
  StagingBuffer(std::span<const std::byte> buffer_data)
    : HostVisibleBuffer(buffer_data, VK_BUFFER_USAGE_TRANSFER_SRC_BIT) {}
};

template <typename DataType>
  requires std::is_trivially_copyable_v<DataType>
// using DataType = float;
class UniformBuffer : public HostVisibleBuffer {
public:
  UniformBuffer() = default;
  UniformBuffer(DataType& data)
    : HostVisibleBuffer(
        std::as_bytes(std::span<DataType>{ &data, 1 }), VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
      ),
      _cache_data(data), _p_data(&data) {}

  void update() {
    auto now_bytes = std::as_bytes(std::span<DataType>{ _p_data, 1 });
    auto cached_bytes = std::as_writable_bytes(std::span<DataType>{ &_cache_data, 1 });
    if (ranges::mismatch(now_bytes, cached_bytes).in1 != now_bytes.end()) {
      std::copy(now_bytes.begin(), now_bytes.end(), cached_bytes.begin());
      memory().fill(cached_bytes);
    }
  }

private:
  DataType  _cache_data;
  DataType* _p_data;
};

void recordCopyBuffer(
  VkCommandBuffer transfer_cmdbuf,
  VkBuffer        src_buffer,
  VkBuffer        dst_buffer,
  VkDeviceSize    buffer_size
) {
  auto copy_info = VkBufferCopy{
    // this offset is about buffer, not about memory
    .srcOffset = 0,
    .dstOffset = 0,
    .size = buffer_size,
  };
  vkCmdCopyBuffer(transfer_cmdbuf, src_buffer, dst_buffer, 1, &copy_info);
}

} // namespace rd::vk