export module render.vk.render_pass;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.sync;
import render.vk.device;
import render.vk.buffer;
import render.vertex;
import render.sampler;

import std;
import toy;

export namespace rd::vk {

class FlightContext {
public:
  static constexpr auto flight_n = 2;
};

struct PipelineResource {
  rs::ShaderModule   vertex_shader;
  rs::ShaderModule   frag_shader;
  rs::PipelineLayout pipeline_layout;
  rs::Pipeline       pipeline;
};

struct StencilOption {
  VkStencilOpState front;
  VkStencilOpState back;

  bool dynamic_reference;
};

struct DepthOption {
  VkCompareOp compare_op;
  bool        overwrite;
};

struct AttachmentInfo {
  VkFormat              format;
  VkSampleCountFlagBits sample_count;
  struct ExternalDependency {
    Scope         scope;
    VkImageLayout layout;
    bool          keep_content = true;
  };
  ExternalDependency enter_dep = {
    .scope = {
      .stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
      .access_mask = 0,
    },
    .layout = VK_IMAGE_LAYOUT_UNDEFINED,
    .keep_content = false,
  };
  ExternalDependency exit_dep = {
    .scope = {
      .stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
      .access_mask = 0,
    },
    .layout = VK_IMAGE_LAYOUT_UNDEFINED,
    .keep_content = false,
  };
};

struct DescriptorInfo {
  VkDescriptorType   type;
  VkShaderStageFlags stage;
  uint32_t           count;
};

struct DescriptorSetInfo {
  std::vector<DescriptorInfo> descriptors;
};

struct SubpassInfo {
  // if multi_sample has value, every color attachment in colors must has the same sample_count
  std::vector<uint32_t> colors;
  // if inputs is
  std::vector<uint32_t> inputs;
  struct MultiSample {
    // size must equal to colors
    std::vector<std::optional<uint32_t>> resolves;
    // must not sample_1
    VkSampleCountFlagBits sample_count;
  };
  std::optional<MultiSample> multi_sample;
  struct DepthStencil {
    uint32_t      attachment;
    DepthOption   depth_option;
    StencilOption stencil_option;
  };

  // if has value, depth_option and stencil_option has value depend on attachment format
  std::optional<uint32_t>      depst_attachment;
  std::optional<DepthOption>   depth_option;
  std::optional<StencilOption> stencil_option;

  std::string                    vertex_shader_name;
  std::string                    frag_shader_name;
  VkPrimitiveTopology            topology;
  VertexInfo                     vertex_info;
  std::vector<DescriptorSetInfo> descriptor_sets;
};

struct RenderPassInfo {
  VkExtent2D                  extent;
  std::vector<AttachmentInfo> attachments;
  std::vector<SubpassInfo>    subpasses;
};

class Pipeline {
public:
  class Recorder {
  public:
    void setDescriptorSet(uint32_t index, std::span<class DescriptorSet* const> descriptor_set);
    void setIndexBuffer();
    void setVertexBuffer();
    void draw();
  };
  void setRecorder(std::function<void(Recorder)> recorder);
  auto pipeline() const -> VkPipeline { return _pipeline.pipeline; }
  auto descriptor_set_layouts() const -> std::span<const rs::DescriptorSetLayout> {
    return _dset_layouts;
  }
  Pipeline(PipelineResource pipeline_resource, std::vector<rs::DescriptorSetLayout> dset_layouts)
    : _pipeline(std::move(pipeline_resource)), _dset_layouts(std::move(dset_layouts)) {}

private:
  PipelineResource                     _pipeline;
  std::vector<rs::DescriptorSetLayout> _dset_layouts;
};
class RenderPass {
public:
  RenderPass() = default;
  RenderPass(RenderPassInfo info) {
    _render_pass = createRenderPass(info.attachments, info.subpasses);
    _pipelines = createPipeline(_render_pass, info.extent, info.subpasses);
  }

  auto operator[](uint32_t index) -> Pipeline& { return _pipelines[index]; }

private:
  static auto createRenderPass(
    std::span<const AttachmentInfo> attachments, std::span<const SubpassInfo> subpasses
  ) -> rs::RenderPass;
  static auto createPipeline(
    VkRenderPass render_pass, VkExtent2D extent, std::span<const SubpassInfo> subpasses
  ) -> std::vector<Pipeline>;
  static constexpr auto _color_formats = std::array{
    VK_FORMAT_R8G8B8A8_SRGB,
  };
  static constexpr auto _depth_formats = std::array{
    VK_FORMAT_D16_UNORM,
    VK_FORMAT_D32_SFLOAT,
  };
  static constexpr auto _stencil_formats = std::array{
    VK_FORMAT_S8_UINT,
  };
  static constexpr auto _depth_stencil_formats = std::array{
    VK_FORMAT_D24_UNORM_S8_UINT,
  };

  rs::RenderPass        _render_pass;
  std::vector<Pipeline> _pipelines;
};

class DescritporPool : public rs::DescriptorPool {
public:
  DescritporPool(uint32_t set_count, std::span<const VkDescriptorPoolSize> type_counts) {
    auto pool_create_info = VkDescriptorPoolCreateInfo{
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
      // VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: 允许freeDescriptorSets
      .flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
      // 会分配描述符集的最大数量
      .maxSets = set_count,
      .poolSizeCount = static_cast<uint32_t>(type_counts.size()),
      .pPoolSizes = type_counts.data(),
    };
    rs::DescriptorPool::operator=({ Device::getInstance(), pool_create_info });
  }
};

class DescriptorSet {
public:
  DescriptorSet(const DescritporPool& pool, const Pipeline& pipeline, uint32_t set_id) {
    auto dset_layout = pipeline.descriptor_set_layouts()[set_id].get();
    auto allocate_info = VkDescriptorSetAllocateInfo{
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
      .descriptorPool = pool,
      .descriptorSetCount = 1,
      .pSetLayouts = &dset_layout,
    };
    _dsets = { Device::getInstance(), allocate_info };
  }
  auto operator[](uint32_t binding) -> class Descriptor;
  auto get() const -> VkDescriptorSet { return _dsets.get()[0]; }

private:
  rs::DescriptorSets _dsets;
};

class Descriptor {
public:
  auto operator=(std::initializer_list<std::reference_wrapper<Buffer const>> resources
  ) -> Descriptor& {
    auto buffer_infos = resources | views::transform([&](Buffer const& buffer) {
                          return VkDescriptorBufferInfo{
                            .buffer = buffer,
                            .offset = 0,
                            .range = VK_WHOLE_SIZE,
                          };
                        }) |
                        ranges::to<std::vector>();
    auto write_info = VkWriteDescriptorSet{
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
      .dstSet = _dset->get(),
      .dstBinding = _binding,
      // 数组起始索引
      .dstArrayElement = 0,
      .descriptorCount = static_cast<uint32_t>(resources.size()),
      .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
      .pBufferInfo = buffer_infos.data(),
    };
    vkUpdateDescriptorSets(Device::getInstance(), 1, &write_info, 0, nullptr);
    return *this;
  }
  auto operator=(std::initializer_list<std::reference_wrapper<SampledTexture const>> resources
  ) -> Descriptor& {
    auto image_infos = resources | views::transform([&](SampledTexture const& texture) {
                         return VkDescriptorImageInfo{
                           .sampler = texture.sampler(),
                           .imageView = texture.image_view(),
                           .imageLayout = texture.getLayout(),
                         };
                       }) |
                       ranges::to<std::vector>();
    auto write_info = VkWriteDescriptorSet{
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
      .dstSet = _dset->get(),
      .dstBinding = _binding,
      // 数组起始索引
      .dstArrayElement = 0,
      .descriptorCount = static_cast<uint32_t>(resources.size()),
      .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
      .pImageInfo = image_infos.data(),
    };
    vkUpdateDescriptorSets(Device::getInstance(), 1, &write_info, 0, nullptr);
    return *this;
  }
  auto operator=(auto const& resource) -> Descriptor& { return *this = { std::cref(resource) }; }
  Descriptor(DescriptorSet* dset, uint32_t binding) : _dset(dset), _binding(binding) {}

private:
  DescriptorSet* _dset;
  uint32_t       _binding;
};

auto DescriptorSet::operator[](uint32_t binding) -> Descriptor { return { this, binding }; }

} // namespace rd::vk