export module render.vk.render_pass;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.sync;
import render.vk.buffer;
import render.vertex;
import render.sampler;

import std;
import toy;

export namespace rd::vk {

class FlightContext {
public:
  static constexpr auto flight_n = 2;
};

struct PipelineResource {
  rs::ShaderModule   vertex_shader;
  rs::ShaderModule   frag_shader;
  rs::PipelineLayout pipeline_layout;
  rs::Pipeline       pipeline;
};

struct StencilOption {
  VkStencilOpState front;
  VkStencilOpState back;

  bool dynamic_reference;
};

struct DepthOption {
  VkCompareOp compare_op;
  bool        overwrite;
};

struct AttachmentInfo {
  VkFormat              format;
  VkSampleCountFlagBits sample_count;
  struct ExternalDependency {
    Scope         scope;
    VkImageLayout layout;
    bool          keep_content;
  };
  ExternalDependency enter_dep = {
    .scope = {
      .stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
      .access_mask = 0,
    },
    .layout = VK_IMAGE_LAYOUT_UNDEFINED,
  };
  ExternalDependency exit_dep = {
    .scope = {
      .stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
      .access_mask = 0,
    },
    .layout = VK_IMAGE_LAYOUT_UNDEFINED,
    .keep_content = true,
  };
};

struct DescriptorInfo {
  VkDescriptorType   type;
  VkShaderStageFlags stage;
  uint32_t           count;
};

struct DescriptorSetInfo {
  std::vector<DescriptorInfo> descriptors;
};

struct SubpassInfo {
  // if multi_sample has value, every color attachment in colors must has the same sample_count
  std::vector<uint32_t> colors;
  // if inputs is
  std::vector<uint32_t> inputs;
  struct MultiSample {
    // size must equal to colors
    std::vector<std::optional<uint32_t>> resolves;
    // must not sample_1
    VkSampleCountFlagBits sample_count;
  };
  std::optional<MultiSample> multi_sample;
  struct DepthStencil {
    uint32_t      attachment;
    DepthOption   depth_option;
    StencilOption stencil_option;
  };

  // if has value, depth_option and stencil_option has value depend on attachment format
  std::optional<uint32_t>      depst_attachment;
  std::optional<DepthOption>   depth_option;
  std::optional<StencilOption> stencil_option;

  std::string                    vertex_shader_name;
  std::string                    frag_shader_name;
  VkPrimitiveTopology            topology;
  VertexInfo                     vertex_info;
  std::vector<DescriptorSetInfo> descriptor_sets;
};

struct RenderPassInfo {
  std::vector<AttachmentInfo> attachments;
  std::vector<SubpassInfo>    subpasses;
};

class Pipeline {
public:
  class Recorder;
  std::function<void(Recorder&)> recorder;

  auto pipeline() const -> VkPipeline { return _pipeline.pipeline; }
  auto pipeline_layout() const -> VkPipelineLayout { return _pipeline.pipeline_layout; }
  auto descriptor_set_layouts() const -> std::span<const rs::DescriptorSetLayout> {
    return _dset_layouts;
  }
  Pipeline(PipelineResource pipeline_resource, std::vector<rs::DescriptorSetLayout> dset_layouts)
    : _pipeline(std::move(pipeline_resource)), _dset_layouts(std::move(dset_layouts)) {}

private:
  PipelineResource                     _pipeline;
  std::vector<rs::DescriptorSetLayout> _dset_layouts;
};

class Framebuffer;
class RenderPass {
public:
  auto render_pass() const -> VkRenderPass { return _render_pass; }

  RenderPass() = default;
  RenderPass(RenderPassInfo info) {
    _render_pass = createRenderPass(info.attachments, info.subpasses);
    _pipelines = createPipeline(_render_pass, info.subpasses);
  }

  auto operator[](uint32_t index) -> Pipeline& { return _pipelines[index]; }

  void recordDraw(
    VkCommandBuffer cmdbuf, Framebuffer& framebuffer, std::span<const VkClearValue> clear_values
  );

private:
  static auto createRenderPass(
    std::span<const AttachmentInfo> attachments, std::span<const SubpassInfo> subpasses
  ) -> rs::RenderPass;
  static auto createPipeline(VkRenderPass render_pass, std::span<const SubpassInfo> subpasses)
    -> std::vector<Pipeline>;
  static constexpr auto _color_formats = std::array{
    VK_FORMAT_R8G8B8A8_SRGB,
  };
  static constexpr auto _depth_formats = std::array{
    VK_FORMAT_D16_UNORM,
    VK_FORMAT_D32_SFLOAT,
  };
  static constexpr auto _stencil_formats = std::array{
    VK_FORMAT_S8_UINT,
  };
  static constexpr auto _depth_stencil_formats = std::array{
    VK_FORMAT_D24_UNORM_S8_UINT,
  };

  rs::RenderPass        _render_pass;
  std::vector<Pipeline> _pipelines;
};

class DescriptorPool : public rs::DescriptorPool {
public:
  DescriptorPool(uint32_t set_count, std::span<const VkDescriptorPoolSize> type_counts);
};

class DescriptorSet {
public:
  DescriptorSet() = default;
  DescriptorSet(const DescriptorPool& pool, const Pipeline& pipeline, uint32_t set_id);
  auto operator[](uint32_t binding) -> class Descriptor;
  auto get() const -> VkDescriptorSet { return _dsets.get()[0]; }

private:
  rs::DescriptorSets _dsets;
};

class Descriptor {
public:
  auto operator=(std::initializer_list<std::reference_wrapper<Buffer const>> resources
  ) -> Descriptor&;
  auto operator=(std::initializer_list<std::reference_wrapper<SampledTexture const>> resources
  ) -> Descriptor&;
  auto operator=(auto const& resource) -> Descriptor& { return *this = { std::cref(resource) }; }
  Descriptor(DescriptorSet* dset, uint32_t binding) : _dset(dset), _binding(binding) {}

private:
  DescriptorSet* _dset;
  uint32_t       _binding;
};

auto DescriptorSet::operator[](uint32_t binding) -> Descriptor { return { this, binding }; }

class Framebuffer : public rs::Framebuffer {
public:
  Framebuffer() = default;
  Framebuffer(RenderPass& render_pass, VkExtent2D extent, std::span<const VkImageView> image_views);
  auto extent() const -> VkExtent2D { return _extent; }

private:
  VkExtent2D _extent;
};

class Pipeline::Recorder {
public:
  Recorder(
    VkCommandBuffer cmdbuf, VkPipeline pipeline, VkPipelineLayout pipeline_layout, VkExtent2D extent
  )
    : descriptor_set(cmdbuf, pipeline_layout), vertex_buffer(cmdbuf), index_buffer(cmdbuf, this),
      _cmdbuf(cmdbuf), _pipeline(pipeline), _extent(extent), _index_count(0) {}
  void init();
  void draw();
  Recorder(const Recorder&) noexcept = delete;
  Recorder(Recorder&&) noexcept = delete;
  auto operator=(const Recorder&) noexcept -> Recorder& = delete;
  auto operator=(Recorder&&) noexcept -> Recorder& = delete;
  class DescriptorSetBinding {
  public:
    DescriptorSetBinding(VkCommandBuffer cmdbuf, VkPipelineLayout pipeline_layout)
      : _cmdbuf(cmdbuf), _pipeline_layout(pipeline_layout) {}
    class DescriptorSetBindingTarget {
    public:
      auto operator=(DescriptorSet& descriptor_set) -> DescriptorSetBindingTarget&;
      DescriptorSetBindingTarget(uint32_t index, DescriptorSetBinding* parent)
        : _index(index), _parent(parent) {}

    private:
      uint32_t              _index;
      DescriptorSetBinding* _parent;
    };
    auto operator[](uint32_t index) { return DescriptorSetBindingTarget{ index, this }; }

  private:
    VkCommandBuffer  _cmdbuf;
    VkPipelineLayout _pipeline_layout;
  };
  class VertexBufferBinding {
  public:
    VertexBufferBinding(VkCommandBuffer cmdbuf) : _cmdbuf(cmdbuf) {}
    auto operator=(VertexBuffer& vertex_buffer) -> VertexBufferBinding&;

  private:
    VkCommandBuffer _cmdbuf;
  };
  class IndexBufferBinding {
  public:
    IndexBufferBinding(VkCommandBuffer cmdbuf, Recorder* recorder)
      : _cmdbuf(cmdbuf), _recorder(recorder) {}
    auto operator=(IndexBuffer& index_buffer) -> IndexBufferBinding&;

  private:
    VkCommandBuffer _cmdbuf;
    Recorder*       _recorder;
  };
  DescriptorSetBinding descriptor_set;
  VertexBufferBinding  vertex_buffer;
  IndexBufferBinding   index_buffer;

private:
  VkCommandBuffer _cmdbuf;
  VkPipeline      _pipeline;
  VkExtent2D      _extent;
  uint32_t        _index_count;
};

} // namespace rd::vk