export module render.vk.render_pass;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.sync;
import render.vk.device;
import render.vk.buffer;
import render.vertex;
import render.sampler;

import std;
import toy;

export namespace rd::vk {

class FlightContext {
public:
  static constexpr auto flight_n = 2;
};

struct PipelineResource {
  rs::ShaderModule   vertex_shader;
  rs::ShaderModule   frag_shader;
  rs::PipelineLayout pipeline_layout;
  rs::Pipeline       pipeline;
};

struct StencilOption {
  VkStencilOpState front;
  VkStencilOpState back;

  bool dynamic_reference;
};

struct DepthOption {
  VkCompareOp compare_op;
  bool        overwrite;
};

struct AttachmentInfo {
  VkFormat              format;
  VkSampleCountFlagBits sample_count;
  struct ExternalDependency {
    Scope         scope;
    VkImageLayout layout;
    bool          keep_content;
  };
  ExternalDependency enter_dep = {
    .scope = {
      .stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
      .access_mask = 0,
    },
    .layout = VK_IMAGE_LAYOUT_UNDEFINED,
  };
  ExternalDependency exit_dep = {
    .scope = {
      .stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
      .access_mask = 0,
    },
    .layout = VK_IMAGE_LAYOUT_UNDEFINED,
    .keep_content = true,
  };
};

struct DescriptorInfo {
  VkDescriptorType   type;
  VkShaderStageFlags stage;
  uint32_t           count;
};

struct DescriptorSetInfo {
  std::vector<DescriptorInfo> descriptors;
};

struct SubpassInfo {
  // if multi_sample has value, every color attachment in colors must has the same sample_count
  std::vector<uint32_t> colors;
  // if inputs is
  std::vector<uint32_t> inputs;
  struct MultiSample {
    // size must equal to colors
    std::vector<std::optional<uint32_t>> resolves;
    // must not sample_1
    VkSampleCountFlagBits sample_count;
  };
  std::optional<MultiSample> multi_sample;
  struct DepthStencil {
    uint32_t      attachment;
    DepthOption   depth_option;
    StencilOption stencil_option;
  };

  // if has value, depth_option and stencil_option has value depend on attachment format
  std::optional<uint32_t>      depst_attachment;
  std::optional<DepthOption>   depth_option;
  std::optional<StencilOption> stencil_option;

  std::string                    vertex_shader_name;
  std::string                    frag_shader_name;
  VkPrimitiveTopology            topology;
  VertexInfo                     vertex_info;
  std::vector<DescriptorSetInfo> descriptor_sets;
};

struct RenderPassInfo {
  std::vector<AttachmentInfo> attachments;
  std::vector<SubpassInfo>    subpasses;
};

class Pipeline {
public:
  class Recorder;
  std::function<void(Recorder&)> recorder;

  auto pipeline() const -> VkPipeline { return _pipeline.pipeline; }
  auto pipeline_layout() const -> VkPipelineLayout { return _pipeline.pipeline_layout; }
  auto descriptor_set_layouts() const -> std::span<const rs::DescriptorSetLayout> {
    return _dset_layouts;
  }
  Pipeline(PipelineResource pipeline_resource, std::vector<rs::DescriptorSetLayout> dset_layouts)
    : _pipeline(std::move(pipeline_resource)), _dset_layouts(std::move(dset_layouts)) {}

private:
  PipelineResource                     _pipeline;
  std::vector<rs::DescriptorSetLayout> _dset_layouts;
};

class Framebuffer;
class RenderPass {
public:
  auto render_pass() const -> VkRenderPass { return _render_pass; }

  RenderPass() = default;
  RenderPass(RenderPassInfo info) {
    _render_pass = createRenderPass(info.attachments, info.subpasses);
    _pipelines = createPipeline(_render_pass, info.subpasses);
  }

  auto operator[](uint32_t index) -> Pipeline& { return _pipelines[index]; }

  void recordDraw(
    VkCommandBuffer cmdbuf, Framebuffer& framebuffer, std::span<const VkClearValue> clear_values
  );

private:
  static auto createRenderPass(
    std::span<const AttachmentInfo> attachments, std::span<const SubpassInfo> subpasses
  ) -> rs::RenderPass;
  static auto createPipeline(VkRenderPass render_pass, std::span<const SubpassInfo> subpasses)
    -> std::vector<Pipeline>;
  static constexpr auto _color_formats = std::array{
    VK_FORMAT_R8G8B8A8_SRGB,
  };
  static constexpr auto _depth_formats = std::array{
    VK_FORMAT_D16_UNORM,
    VK_FORMAT_D32_SFLOAT,
  };
  static constexpr auto _stencil_formats = std::array{
    VK_FORMAT_S8_UINT,
  };
  static constexpr auto _depth_stencil_formats = std::array{
    VK_FORMAT_D24_UNORM_S8_UINT,
  };

  rs::RenderPass        _render_pass;
  std::vector<Pipeline> _pipelines;
};

class DescriptorPool : public rs::DescriptorPool {
public:
  DescriptorPool(uint32_t set_count, std::span<const VkDescriptorPoolSize> type_counts) {
    auto pool_create_info = VkDescriptorPoolCreateInfo{
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
      // VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: 允许freeDescriptorSets
      .flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
      // 会分配描述符集的最大数量
      .maxSets = set_count,
      .poolSizeCount = static_cast<uint32_t>(type_counts.size()),
      .pPoolSizes = type_counts.data(),
    };
    rs::DescriptorPool::operator=({ Device::getInstance(), pool_create_info });
  }
};

class DescriptorSet {
public:
  DescriptorSet() = default;
  DescriptorSet(const DescriptorPool& pool, const Pipeline& pipeline, uint32_t set_id) {
    auto dset_layout = pipeline.descriptor_set_layouts()[set_id].get();
    auto allocate_info = VkDescriptorSetAllocateInfo{
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
      .descriptorPool = pool,
      .descriptorSetCount = 1,
      .pSetLayouts = &dset_layout,
    };
    _dsets = { Device::getInstance(), allocate_info };
  }
  auto operator[](uint32_t binding) -> class Descriptor;
  auto get() const -> VkDescriptorSet { return _dsets.get()[0]; }

private:
  rs::DescriptorSets _dsets;
};

class Descriptor {
public:
  auto operator=(std::initializer_list<std::reference_wrapper<Buffer const>> resources
  ) -> Descriptor& {
    auto buffer_infos = resources | views::transform([&](Buffer const& buffer) {
                          return VkDescriptorBufferInfo{
                            .buffer = buffer,
                            .offset = 0,
                            .range = VK_WHOLE_SIZE,
                          };
                        }) |
                        ranges::to<std::vector>();
    auto write_info = VkWriteDescriptorSet{
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
      .dstSet = _dset->get(),
      .dstBinding = _binding,
      // 数组起始索引
      .dstArrayElement = 0,
      .descriptorCount = static_cast<uint32_t>(resources.size()),
      .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
      .pBufferInfo = buffer_infos.data(),
    };
    vkUpdateDescriptorSets(Device::getInstance(), 1, &write_info, 0, nullptr);
    return *this;
  }
  auto operator=(std::initializer_list<std::reference_wrapper<SampledTexture const>> resources
  ) -> Descriptor& {
    auto image_infos = resources | views::transform([&](SampledTexture const& texture) {
                         return VkDescriptorImageInfo{
                           .sampler = texture.sampler(),
                           .imageView = texture.image_view(),
                           .imageLayout = texture.getLayout(),
                         };
                       }) |
                       ranges::to<std::vector>();
    auto write_info = VkWriteDescriptorSet{
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
      .dstSet = _dset->get(),
      .dstBinding = _binding,
      // 数组起始索引
      .dstArrayElement = 0,
      .descriptorCount = static_cast<uint32_t>(resources.size()),
      .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
      .pImageInfo = image_infos.data(),
    };
    vkUpdateDescriptorSets(Device::getInstance(), 1, &write_info, 0, nullptr);
    return *this;
  }
  auto operator=(auto const& resource) -> Descriptor& { return *this = { std::cref(resource) }; }
  Descriptor(DescriptorSet* dset, uint32_t binding) : _dset(dset), _binding(binding) {}

private:
  DescriptorSet* _dset;
  uint32_t       _binding;
};

auto DescriptorSet::operator[](uint32_t binding) -> Descriptor { return { this, binding }; }

class Framebuffer : public rs::Framebuffer {
public:
  Framebuffer() = default;
  Framebuffer(
    RenderPass& render_pass, VkExtent2D extent, std::span<const VkImageView> image_views
  ) {
    _extent = extent;
    auto create_info = VkFramebufferCreateInfo{
      .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
      .renderPass = render_pass.render_pass(),
      .attachmentCount = static_cast<uint32_t>(image_views.size()),
      .pAttachments = image_views.data(),
      .width = extent.width,
      .height = extent.height,
      .layers = 1,
    };
    rs::Framebuffer::operator=({ Device::getInstance(), create_info });
  }
  auto extent() const -> VkExtent2D { return _extent; }

private:
  VkExtent2D _extent;
};

class Pipeline::Recorder {
public:
  Recorder(
    VkCommandBuffer cmdbuf, VkPipeline pipeline, VkPipelineLayout pipeline_layout, VkExtent2D extent
  )
    : descriptor_set(cmdbuf, pipeline_layout), vertex_buffer(cmdbuf), index_buffer(cmdbuf, this),
      _cmdbuf(cmdbuf), _pipeline(pipeline), _extent(extent), _index_count(0) {}
  void init() {
    vkCmdBindPipeline(_cmdbuf, VK_PIPELINE_BIND_POINT_GRAPHICS, _pipeline);
    // 定义了 viewport 到缓冲区的变换
    VkViewport viewport{
      .x = 0,
      .y = 0,
      .width = static_cast<float>(_extent.width),
      .height = static_cast<float>(_extent.height),
      .minDepth = 0.0f,
      .maxDepth = 1.0f,
    };
    vkCmdSetViewport(_cmdbuf, 0, 1, &viewport);
    // 定义了缓冲区实际存储像素的区域
    VkRect2D scissor{
      .offset = { .x = 0, .y = 0 },
      .extent = _extent,
    };
    vkCmdSetScissor(_cmdbuf, 0, 1, &scissor);
  }
  void draw() { vkCmdDrawIndexed(_cmdbuf, _index_count, 1, 0, 0, 0); }
  Recorder(const Recorder&) noexcept = delete;
  Recorder(Recorder&&) noexcept = delete;
  auto operator=(const Recorder&) noexcept -> Recorder& = delete;
  auto operator=(Recorder&&) noexcept -> Recorder& = delete;
  class DescriptorSetBinding {
  public:
    DescriptorSetBinding(VkCommandBuffer cmdbuf, VkPipelineLayout pipeline_layout)
      : _cmdbuf(cmdbuf), _pipeline_layout(pipeline_layout) {}
    class DescriptorSetBindingTarget {
    public:
      auto operator=(DescriptorSet& descriptor_set) {
        auto handle = descriptor_set.get();
        vkCmdBindDescriptorSets(
          _parent->_cmdbuf,
          VK_PIPELINE_BIND_POINT_GRAPHICS,
          _parent->_pipeline_layout,
          // firstSet: 对应着色器中的layout(set=0)
          _index,
          1,
          &handle,
          0,
          nullptr
        );
      }
      DescriptorSetBindingTarget(uint32_t index, DescriptorSetBinding* parent)
        : _index(index), _parent(parent) {}

    private:
      uint32_t              _index;
      DescriptorSetBinding* _parent;
    };
    auto operator[](uint32_t index) { return DescriptorSetBindingTarget{ index, this }; }

  private:
    VkCommandBuffer  _cmdbuf;
    VkPipelineLayout _pipeline_layout;
  };
  class VertexBufferBinding {
  public:
    VertexBufferBinding(VkCommandBuffer cmdbuf) : _cmdbuf(cmdbuf) {}
    auto operator=(VertexBuffer& vertex_buffer) {
      auto offset = VkDeviceSize{ 0 };
      vkCmdBindVertexBuffers(_cmdbuf, 0, 1, &vertex_buffer.get(), &offset);
    }

  private:
    VkCommandBuffer _cmdbuf;
  };
  class IndexBufferBinding {
  public:
    IndexBufferBinding(VkCommandBuffer cmdbuf, Recorder* recorder)
      : _cmdbuf(cmdbuf), _recorder(recorder) {}
    auto operator=(IndexBuffer& index_buffer) {
      vkCmdBindIndexBuffer(_cmdbuf, index_buffer, 0, index_buffer.getIndexType());
      _recorder->_index_count = index_buffer.getIndexNumber();
    }

  private:
    VkCommandBuffer _cmdbuf;
    Recorder*       _recorder;
  };
  DescriptorSetBinding descriptor_set;
  VertexBufferBinding  vertex_buffer;
  IndexBufferBinding   index_buffer;

private:
  VkCommandBuffer _cmdbuf;
  VkPipeline      _pipeline;
  VkExtent2D      _extent;
  uint32_t        _index_count;
};

void RenderPass::recordDraw(
  VkCommandBuffer cmdbuf, Framebuffer& framebuffer, std::span<const VkClearValue> clear_values
) {
  VkRenderPassBeginInfo render_pass_begin_info {
    .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
    .renderPass = _render_pass,
    .framebuffer = framebuffer,
    .renderArea = {
      .offset = {0, 0},
      .extent = framebuffer.extent(),
    },
    .clearValueCount = static_cast<uint32_t>(clear_values.size()),
    .pClearValues = clear_values.data(),
  };
  // VK_SUBPASS_CONTENTS_INLINE: render pass的command被嵌入主缓冲区
  // VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS: render pass 命令
  // 将会从次缓冲区执行
  vkCmdBeginRenderPass(cmdbuf, &render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);
  for (auto& pipeline : _pipelines) {
    auto recorder = Pipeline::Recorder{
      cmdbuf, pipeline.pipeline(), pipeline.pipeline_layout(), framebuffer.extent()
    };
    pipeline.recorder(recorder);
  }
  vkCmdEndRenderPass(cmdbuf);
}

} // namespace rd::vk