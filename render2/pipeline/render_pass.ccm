export module render.vk.render_pass;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.sync;
import render.vk.device;
import render.vk.buffer;
import render.vertex;

import std;
import toy;

export namespace rd::vk {

class FlightContext {
public:
  static constexpr auto flight_n = 2;
};

struct PipelineResource {
  rs::ShaderModule   vertex_shader;
  rs::ShaderModule   frag_shader;
  rs::PipelineLayout pipeline_layout;
  rs::Pipeline       pipeline;
};

struct StencilOption {
  VkStencilOpState front;
  VkStencilOpState back;

  bool dynamic_reference;
};

struct DepthOption {
  VkCompareOp compare_op;
  bool        enable_write;
};

struct AttachmentInfo {
  VkFormat              format;
  VkSampleCountFlagBits sample_count;
  struct ExternalDependency {
    Scope         scope;
    VkImageLayout layout;
    bool          keep_content = true;
  };
  ExternalDependency enter_dep = {
    .scope = {
      .stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
      .access_mask = 0,
    },
    .layout = VK_IMAGE_LAYOUT_UNDEFINED,
    .keep_content = false,
  };
  ExternalDependency exit_dep = {
    .scope = {
      .stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
      .access_mask = 0,
    },
    .layout = VK_IMAGE_LAYOUT_UNDEFINED,
    .keep_content = false,
  };
};

struct DescriptorInfo {
  VkDescriptorType   type;
  VkShaderStageFlags stage;
  uint32_t           count;
};

struct DescriptorSetInfo {
  std::vector<DescriptorInfo> descriptors;
};

struct SubpassInfo {
  // if multi_sample has value, every color attachment in colors must has the same sample_count
  std::vector<uint32_t> colors;
  // if inputs is
  std::vector<uint32_t> inputs;
  struct MultiSample {
    // size must equal to colors
    std::vector<std::optional<uint32_t>> resolves;
    // must not sample_1
    VkSampleCountFlagBits sample_count;
  };
  std::optional<MultiSample> multi_sample;
  struct DepthStencil {
    uint32_t      attachment;
    DepthOption   depth_option;
    StencilOption stencil_option;
  };

  // if has value, depth_option and stencil_option has value depend on attachment format
  std::optional<uint32_t>      depst_attachment;
  std::optional<DepthOption>   depth_option;
  std::optional<StencilOption> stencil_option;

  std::string                    vertex_shader_name;
  std::string                    frag_shader_name;
  VkPrimitiveTopology            topology;
  VertexInfo                     vertex_info;
  std::vector<DescriptorSetInfo> descriptor_sets;
};

struct RenderPassInfo {
  VkExtent2D                  extent;
  std::vector<AttachmentInfo> attachments;
  std::vector<SubpassInfo>    subpasses;
};

class Pipeline {
public:
  class Recorder {
  public:
    void setDescriptorSet(uint32_t index, std::span<class DescriptorSet* const> descriptor_set);
    void setIndexBuffer();
    void setVertexBuffer();
    void draw();
  };
  void setRecorder(std::function<void(Recorder)> recorder);
  auto pipeline() const -> VkPipeline { return _pipeline.pipeline; }
  auto descriptor_set_layouts() const -> std::span<const rs::DescriptorSetLayout> {
    return _dset_layouts;
  }
  Pipeline(PipelineResource pipeline_resource, std::vector<rs::DescriptorSetLayout> dset_layouts)
    : _pipeline(std::move(pipeline_resource)), _dset_layouts(std::move(dset_layouts)) {}

private:
  PipelineResource                     _pipeline;
  std::vector<rs::DescriptorSetLayout> _dset_layouts;
};
class RenderPass {
public:
  RenderPass() = default;
  RenderPass(RenderPassInfo info) {
    _render_pass = createRenderPass(info.attachments, info.subpasses);
    _pipelines = createPipeline(_render_pass, info.extent, info.subpasses);
  }

  auto operator[](uint32_t index) -> Pipeline;

private:
  static auto createRenderPass(
    std::span<const AttachmentInfo> attachments, std::span<const SubpassInfo> subpasses
  ) -> rs::RenderPass;
  static auto createPipeline(
    VkRenderPass render_pass, VkExtent2D extent, std::span<const SubpassInfo> subpasses
  ) -> std::vector<Pipeline>;
  static constexpr auto _color_formats = std::array{
    VK_FORMAT_R8G8B8A8_SRGB,
  };
  static constexpr auto _depth_formats = std::array{
    VK_FORMAT_D16_UNORM,
    VK_FORMAT_D32_SFLOAT,
  };
  static constexpr auto _stencil_formats = std::array{
    VK_FORMAT_S8_UINT,
  };
  static constexpr auto _depth_stencil_formats = std::array{
    VK_FORMAT_D24_UNORM_S8_UINT,
  };

  rs::RenderPass        _render_pass;
  std::vector<Pipeline> _pipelines;
};

class DescritporPool : public rs::DescriptorPool {
public:
  DescritporPool(uint32_t set_count, std::span<const VkDescriptorPoolSize> type_counts) {
    auto pool_create_info = VkDescriptorPoolCreateInfo{
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
      // VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: 允许freeDescriptorSets
      .flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
      // 会分配描述符集的最大数量
      .maxSets = set_count,
      .poolSizeCount = static_cast<uint32_t>(type_counts.size()),
      .pPoolSizes = type_counts.data(),
    };
    rs::DescriptorPool::operator=({ Device::getInstance(), pool_create_info });
  }
};

class Descriptor {
  auto operator=(std::initializer_list<std::reference_wrapper<const Buffer>> resources)
    -> Descriptor&;
  auto operator=(const Buffer& resources) -> Descriptor&;
};

class DescriptorSet {
public:
  DescriptorSet(Pipeline subpass, uint32_t set_id) {}

  auto operator[](uint32_t binding) -> Descriptor;
};

} // namespace rd::vk