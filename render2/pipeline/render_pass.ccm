export module render.vk.render_pass;

import "vulkan_config.h";
import render.vk.resource;
import render.vk.sync;
import render.vk.buffer;
import render.vk.tracker;
import render.vk.executor;
import render.vertex;
import render.sampler;

import std;
import toy;

export namespace rd::vk {

// class FlightContext {
// public:
//   static constexpr auto flight_n = 2;
// };

struct PipelineResource {
  rs::ShaderModule   vertex_shader;
  rs::ShaderModule   frag_shader;
  rs::PipelineLayout pipeline_layout;
  rs::Pipeline       pipeline;
};

struct StencilOption {
  VkStencilOpState front;
  VkStencilOpState back;

  bool dynamic_reference;
};

struct DepthOption {
  VkCompareOp compare_op;
  bool        overwrite;
};

struct AttachmentFormat {
  AttachmentFormat(VkFormat format) : _format(format) {
    toy::throwf(
      ranges::find(_color_formats, _format) != _color_formats.end() ||
        ranges::find(_depth_formats, _format) != _depth_formats.end() ||
        ranges::find(_stencil_formats, _format) != _stencil_formats.end() ||
        ranges::find(_depth_stencil_formats, _format) != _depth_stencil_formats.end(),
      "the format of attachment not support by renderpass"
    );
  }
  enum FormatType {
    COLOR = 1 << 0,
    DEPTH = 1 << 1,
    STENCIL = 1 << 2,
    DEPTH_STENCIL = DEPTH | STENCIL,
  };

  auto getType() const -> FormatType {
    if (ranges::find(_color_formats, _format) != _color_formats.end()) {
      return FormatType::COLOR;
    } else if (ranges::find(_depth_formats, _format) != _depth_formats.end()) {
      return FormatType::DEPTH;
    } else if (ranges::find(_stencil_formats, _format) != _stencil_formats.end()) {
      return FormatType::STENCIL;
    } else if (ranges::find(_depth_stencil_formats, _format) != _depth_stencil_formats.end()) {
      return FormatType::DEPTH_STENCIL;
    }
    std::unreachable();
  }
  operator VkFormat() const { return _format; }

private:
  VkFormat _format;

  static constexpr auto _color_formats = std::array{
    VK_FORMAT_R8G8B8A8_SRGB,
  };
  static constexpr auto _depth_formats = std::array{
    VK_FORMAT_D16_UNORM,
    VK_FORMAT_D32_SFLOAT,
  };
  static constexpr auto _stencil_formats = std::array{
    VK_FORMAT_S8_UINT,
  };
  static constexpr auto _depth_stencil_formats = std::array{
    VK_FORMAT_D24_UNORM_S8_UINT,
  };
};

struct AttachmentInfo {
  AttachmentFormat      format;
  VkSampleCountFlagBits sample_count;
  bool                  keep_old_content;
  bool                  keep_new_content;
};

struct DescriptorInfo {
  VkDescriptorType   type;
  VkShaderStageFlags stage;
  uint32             count;
};

struct DescriptorSetInfo {
  std::vector<DescriptorInfo> descriptors;
};

struct SubpassInfo {
  // if multi_sample has value, every color attachment in colors must has the same sample_count
  std::vector<uint32> colors;
  // if inputs is
  std::vector<uint32> inputs;
  struct MultiSample {
    // size must equal to colors
    std::vector<std::optional<uint32>> resolves;
    // must not sample_1
    VkSampleCountFlagBits sample_count;
  };
  std::optional<MultiSample> multi_sample;
  struct DepthStencil {
    uint32 attachment;
    // if has value, depth_option and stencil_option is used depend on attachment format
    DepthOption   depth_option;
    StencilOption stencil_option;
  };
  std::optional<DepthStencil> depst_info;

  std::string                    vertex_shader_name;
  std::string                    frag_shader_name;
  VkPrimitiveTopology            topology;
  VertexInfo                     vertex_info;
  std::vector<DescriptorSetInfo> descriptor_sets;
};

struct RenderPassInfo {
  std::vector<AttachmentInfo> attachments;
  std::vector<SubpassInfo>    subpasses;
};

class Pipeline {
public:
  class Recorder;
  std::function<void(Recorder&)> recorder;

  auto pipeline() const -> VkPipeline { return _pipeline.pipeline; }
  auto pipeline_layout() const -> VkPipelineLayout { return _pipeline.pipeline_layout; }
  auto descriptor_set_layouts() const -> std::span<const rs::DescriptorSetLayout> {
    return _dset_layouts;
  }
  Pipeline(PipelineResource pipeline_resource, std::vector<rs::DescriptorSetLayout> dset_layouts)
    : _pipeline(std::move(pipeline_resource)), _dset_layouts(std::move(dset_layouts)) {}

private:
  PipelineResource                     _pipeline;
  std::vector<rs::DescriptorSetLayout> _dset_layouts;
};

struct AttachmentSyncInfo {
  VkPipelineStageFlags2 initial_stage;
  VkPipelineStageFlags2 final_stage;
  VkImageLayout         initial_layout;
  VkImageLayout         final_layout;
};

class Framebuffer;
class RenderPass {
public:
  auto render_pass() const -> VkRenderPass { return _render_pass; }

  RenderPass() = default;
  RenderPass(RenderPassInfo info) {
    std::tie(_render_pass, _attachment_syncs) = createRenderPass(info.attachments, info.subpasses);
    _pipelines = createPipeline(_render_pass, info.subpasses);
  }

  auto operator[](uint32 index) -> Pipeline& { return _pipelines[index]; }

  void recordDraw(
    VkCommandBuffer cmdbuf, Framebuffer& framebuffer, std::span<const VkClearValue> clear_values
  );

  auto syncAttachments(std::span<ImageBarrierTracker* const> trackers, VkSemaphore wait_sema)
    -> void;
  void updateAttachmentsScope(std::span<ImageBarrierTracker* const> trackers, uint32 family);

private:
  static auto createRenderPass(
    std::span<const AttachmentInfo> attachments, std::span<const SubpassInfo> subpasses
  ) -> std::tuple<rs::RenderPass, std::vector<AttachmentSyncInfo>>;
  static auto createPipeline(VkRenderPass render_pass, std::span<const SubpassInfo> subpasses)
    -> std::vector<Pipeline>;

  rs::RenderPass                  _render_pass;
  std::vector<Pipeline>           _pipelines;
  std::vector<AttachmentSyncInfo> _attachment_syncs;
};

class DescriptorPool : public rs::DescriptorPool {
public:
  DescriptorPool(uint32 set_count, std::span<const VkDescriptorPoolSize> type_counts);
};

class DescriptorSet {
public:
  DescriptorSet() = default;
  DescriptorSet(const DescriptorPool& pool, const Pipeline& pipeline, uint32 set_id);
  auto operator[](uint32 binding) -> class Descriptor;
  auto get() const -> VkDescriptorSet { return _dsets.get()[0]; }

private:
  rs::DescriptorSets _dsets;
};

class Descriptor {
public:
  auto operator=(std::initializer_list<std::reference_wrapper<Buffer const>> resources
  ) -> Descriptor&;
  auto operator=(std::initializer_list<std::reference_wrapper<SampledTexture const>> resources
  ) -> Descriptor&;
  auto operator=(auto const& resource) -> Descriptor& { return *this = { std::cref(resource) }; }
  Descriptor(DescriptorSet* dset, uint32 binding) : _dset(dset), _binding(binding) {}

private:
  DescriptorSet* _dset;
  uint32         _binding;
};

auto DescriptorSet::operator[](uint32 binding) -> Descriptor { return { this, binding }; }

class Framebuffer : public rs::Framebuffer {
public:
  Framebuffer() = default;
  Framebuffer(RenderPass& render_pass, VkExtent2D extent, std::span<const VkImageView> image_views);
  auto extent() const -> VkExtent2D { return _extent; }

private:
  VkExtent2D _extent;
};

class Pipeline::Recorder {
public:
  Recorder(
    VkCommandBuffer cmdbuf, VkPipeline pipeline, VkPipelineLayout pipeline_layout, VkExtent2D extent
  )
    : descriptor_set(cmdbuf, pipeline_layout), vertex_buffer(cmdbuf), index_buffer(cmdbuf, this),
      _cmdbuf(cmdbuf), _pipeline(pipeline), _extent(extent), _index_count(0) {}
  void init();
  void draw();
  Recorder(const Recorder&) noexcept = delete;
  Recorder(Recorder&&) noexcept = delete;
  auto operator=(const Recorder&) noexcept -> Recorder& = delete;
  auto operator=(Recorder&&) noexcept -> Recorder& = delete;
  class DescriptorSetBinding {
  public:
    DescriptorSetBinding(VkCommandBuffer cmdbuf, VkPipelineLayout pipeline_layout)
      : _cmdbuf(cmdbuf), _pipeline_layout(pipeline_layout) {}
    class DescriptorSetBindingTarget {
    public:
      auto operator=(DescriptorSet& descriptor_set) -> DescriptorSetBindingTarget&;
      DescriptorSetBindingTarget(uint32 index, DescriptorSetBinding* parent)
        : _index(index), _parent(parent) {}

    private:
      uint32                _index;
      DescriptorSetBinding* _parent;
    };
    auto operator[](uint32 index) { return DescriptorSetBindingTarget{ index, this }; }

  private:
    VkCommandBuffer  _cmdbuf;
    VkPipelineLayout _pipeline_layout;
  };
  class VertexBufferBinding {
  public:
    VertexBufferBinding(VkCommandBuffer cmdbuf) : _cmdbuf(cmdbuf) {}
    auto operator=(VertexBuffer& vertex_buffer) -> VertexBufferBinding&;

  private:
    VkCommandBuffer _cmdbuf;
  };
  class IndexBufferBinding {
  public:
    IndexBufferBinding(VkCommandBuffer cmdbuf, Recorder* recorder)
      : _cmdbuf(cmdbuf), _recorder(recorder) {}
    auto operator=(IndexBuffer& index_buffer) -> IndexBufferBinding&;

  private:
    VkCommandBuffer _cmdbuf;
    Recorder*       _recorder;
  };
  DescriptorSetBinding descriptor_set;
  VertexBufferBinding  vertex_buffer;
  IndexBufferBinding   index_buffer;

private:
  VkCommandBuffer _cmdbuf;
  VkPipeline      _pipeline;
  VkExtent2D      _extent;
  uint32          _index_count;
};

void RenderPass::syncAttachments(
  std::span<ImageBarrierTracker* const> trackers, VkSemaphore wait_sema
) {
  // static auto transfer_semas = [&]() {
  //   auto semas = std::vector<Semaphore>{};
  //   auto n = (int)trackers.size();
  //   while (n--) {
  //     semas.emplace_back(true);
  //   }
  //   return semas;
  // }();

  toy::throwf(trackers.size() == _attachment_syncs.size(), "mismatched attachment count");
  auto& graphics_executor = vk::CommandExecutorManager::getInstance()[vk::FamilyType::GRAPHICS];
  for (auto [index, info, tracker] :
       views::zip(views::iota(0u, _attachment_syncs.size()), _attachment_syncs, trackers)) {
    auto sync = tracker->syncScope(
      Scope{ .stage_mask = info.initial_stage }, graphics_executor.getFamily(), info.initial_layout
    );
    if (auto* barrier = std::get_if<BarrierRecorder>(&sync)) {
      if (index == 1) {
        graphics_executor.submit(vk::RawWaitCommandBatch{
          .recorder = std::move(*barrier),
          .waits = { { wait_sema, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT } },
        });
      } else {
        graphics_executor.submit(*barrier);
      }
    } else if (auto* barrier = std::get_if<FamilyTransferRecorder>(&sync)) {
      auto& release_executor = vk::CommandExecutorManager::getInstance()[barrier->release_family];
      auto  waitable = [&]() {
        if (index == 1) {
          return release_executor.submit(vk::RawWaitCommandBatch{
             .recorder = std::move(barrier->release),
             .waits = { { wait_sema, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT } },
          });
        } else {
          return release_executor.submit(barrier->release);
        }
      }();
      graphics_executor.submit(vk::CommandBatch{
        .recorder = std::move(barrier->acquire),
        .waits = { { &waitable, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT } },
      });
    }
  }
}
void RenderPass::updateAttachmentsScope(
  std::span<ImageBarrierTracker* const> trackers, uint32 family
) {
  toy::throwf(trackers.size() == _attachment_syncs.size(), "mismatched attachment count");
  for (auto [info, tracker] : views::zip(_attachment_syncs, trackers)) {
    tracker->setNewScope(Scope{ .stage_mask = info.final_stage }, family, info.final_layout);
  }
}

} // namespace rd::vk