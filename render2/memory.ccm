export module render.vk.memory;

import std;
import toy;

import "vulkan_config.h";
import render.vk.resource;

export namespace rd::vk {

class Memory : public rs::Memory {
public:
  Memory() = default;
  /**
   * @brief Construct a new Memory object and bind buffer to memory
   */
  Memory(VkBuffer buffer, VkMemoryPropertyFlags property_flags);
  /**
   * @brief Construct a new Memory object and bind image to memory
   */
  Memory(VkImage image, VkMemoryPropertyFlags property_flags);
  Memory(VkMemoryRequirements requirements, VkMemoryPropertyFlags property_flags);

private:
  // directly inline will occur frontend crash
  static std::unique_ptr<VkPhysicalDeviceMemoryProperties> _memory_properties;
};

decltype(Memory::_memory_properties) Memory::_memory_properties = {};

class HostVisibleMemory {
public:
  HostVisibleMemory() = default;
  HostVisibleMemory(VkDeviceMemory memory) : _memory(memory) {}
  HostVisibleMemory(const HostVisibleMemory&) noexcept = delete;
  HostVisibleMemory(HostVisibleMemory&&) noexcept;
  auto operator=(const HostVisibleMemory&) noexcept -> HostVisibleMemory& = delete;
  auto operator=(HostVisibleMemory&&) noexcept -> HostVisibleMemory&;

  auto data() -> void*;
  void fill(std::span<const std::byte> buffer_data);
  ~HostVisibleMemory() { unmap(); }

  static constexpr auto propreties =
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;

private:
  void unmap();

private:
  VkDeviceMemory _memory = nullptr;

  void* _data = nullptr;
};

} // namespace rd::vk