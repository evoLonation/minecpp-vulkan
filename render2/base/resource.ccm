export module render.vk.resource;

import "vulkan_config.h";
import render.vk.tool;
import std;
import toy;

namespace rd::vk::rs {

// vkCreateXXX([phisicalDevice], createInfo, allocator, &handle);
// vkDestroyXXX(handle, allocator);

template <typename T>
concept isConstPointer = std::is_pointer_v<T> && std::is_const_v<std::remove_pointer_t<T>>;

template <
  typename VkHandle,
  auto* Creator,
  auto* Destroyer,
  typename ConstructorArgPack =
    toy::FuncArgs<decltype(Creator)>::template take<-2>::template lambdaMapTo<
      []<typename T>() -> std::conditional_t<isConstPointer<T>, std::remove_pointer_t<T>&, T> {}>>
class SingletonResource;
template <typename VkHandle, auto* Creator, auto* Destroyer, typename... ConstructorArgs>
class SingletonResource<VkHandle, Creator, Destroyer, toy::TypePack<ConstructorArgs...>>
  : public toy::ProactiveSingleton<
      SingletonResource<VkHandle, Creator, Destroyer, toy::TypePack<ConstructorArgs...>>> {
public:
  SingletonResource() = default;
  SingletonResource(ConstructorArgs... args) {
    VkHandle handle;
    Creator(
      [](ConstructorArgs arg) -> decltype(auto) {
        if constexpr (std::is_reference_v<ConstructorArgs>) {
          return &arg;
        } else {
          return arg;
        }
      }(args)...,
      nullptr,
      &handle
    );
    _handle.reset(handle);
    toy::debugf("create resource {}", getResourceName<VkHandle>());
  }
  SingletonResource(const SingletonResource&) noexcept = delete;
  SingletonResource(SingletonResource&&) noexcept = default;
  auto operator=(const SingletonResource&) noexcept -> SingletonResource& = delete;
  auto operator=(SingletonResource&&) noexcept -> SingletonResource& = default;

  auto get() const -> VkHandle { return _handle.get(); }
  operator VkHandle() const { return get(); }

private:
  static inline auto deleter = [](VkHandle handle) {
    Destroyer(handle, nullptr);
    toy::debugf("destroy resource {}", getResourceName<VkHandle>());
  };

  std::unique_ptr<std::remove_pointer_t<VkHandle>, decltype(deleter)> _handle;
};

// 每个特化版本的type成员映射到一个具体的SingletonResource
// 用于ContextualResource检索某个VkHandle的实际SingletonResource类型
template <typename VkHandle>
struct SingletonResourceRetriver;

#define DEF_SINGETON_RESOURCE(Name, VkHandle, Creator, Destroyer)                                  \
  template class SingletonResource<VkHandle, Creator, Destroyer>;                                  \
  export using Name = SingletonResource<VkHandle, Creator, Destroyer>;                             \
  template <>                                                                                      \
  struct SingletonResourceRetriver<VkHandle> {                                                     \
    using type = Name;                                                                             \
  };

DEF_SINGETON_RESOURCE(Instance, VkInstance, vkCreateInstance, vkDestroyInstance)
DEF_SINGETON_RESOURCE(Device, VkDevice, vkCreateDevice, vkDestroyDevice)

#undef DEF_SINGETON_RESOURCE

// vkCreateXXX(singleton, createInfo, allocator, &handle);
// vkDestroyXXX(singleton, handle, allocator);
template <typename VkHandle, auto* Creator, auto* Destroyer>
class ContextualResource {
private:
  using CreateInfoArg =
    std::remove_pointer_t<typename toy::FuncArgs<decltype(Creator)>::template at<1>>&;
  using ContextResource =
    SingletonResourceRetriver<typename toy::FuncArgs<decltype(Creator)>::template at<0>>::type;

public:
  ContextualResource() = default;
  ContextualResource(CreateInfoArg create_info) {
    VkHandle handle;
    Creator(ContextResource::getInstance().get(), &create_info, nullptr, &handle);
    _handle.reset(handle);
    toy::debugf("create resource {}", getResourceName<VkHandle>());
  }
  ContextualResource(const ContextualResource&) noexcept = delete;
  ContextualResource(ContextualResource&&) noexcept = default;
  auto operator=(const ContextualResource&) noexcept -> ContextualResource& = delete;
  auto operator=(ContextualResource&&) noexcept -> ContextualResource& = default;

  auto get() const -> VkHandle { return _handle.get(); }
  operator VkHandle() const { return get(); }

private:
  static inline auto deleter = [](VkHandle handle) {
    Destroyer(ContextResource::getInstance().get(), handle, nullptr);
    toy::debugf("destroy resource {}", getResourceName<VkHandle>());
  };

  std::unique_ptr<std::remove_pointer_t<VkHandle>, decltype(deleter)> _handle;
};

#define DEF_CONTEXTUAL_RESOURCE(Name, VkHandle, Creator, Destroyer)                                \
  template class ContextualResource<VkHandle, Creator, Destroyer>;                                 \
  export using Name = ContextualResource<VkHandle, Creator, Destroyer>;

DEF_CONTEXTUAL_RESOURCE(
  DebugMessenger,
  VkDebugUtilsMessengerEXT,
  vkCreateDebugUtilsMessengerEXT,
  vkDestroyDebugUtilsMessengerEXT
)
DEF_CONTEXTUAL_RESOURCE(Surface, VkSurfaceKHR, vkCreateWin32SurfaceKHR, vkDestroySurfaceKHR)
DEF_CONTEXTUAL_RESOURCE(Swapchain, VkSwapchainKHR, vkCreateSwapchainKHR, vkDestroySwapchainKHR)
DEF_CONTEXTUAL_RESOURCE(ImageView, VkImageView, vkCreateImageView, vkDestroyImageView)
DEF_CONTEXTUAL_RESOURCE(Image, VkImage, vkCreateImage, vkDestroyImage)
DEF_CONTEXTUAL_RESOURCE(Sampler, VkSampler, vkCreateSampler, vkDestroySampler)
DEF_CONTEXTUAL_RESOURCE(RenderPass, VkRenderPass, vkCreateRenderPass, vkDestroyRenderPass)
DEF_CONTEXTUAL_RESOURCE(Framebuffer, VkFramebuffer, vkCreateFramebuffer, vkDestroyFramebuffer)
DEF_CONTEXTUAL_RESOURCE(CommandPool, VkCommandPool, vkCreateCommandPool, vkDestroyCommandPool)
DEF_CONTEXTUAL_RESOURCE(ShaderModule, VkShaderModule, vkCreateShaderModule, vkDestroyShaderModule)
DEF_CONTEXTUAL_RESOURCE(
  PipelineLayout, VkPipelineLayout, vkCreatePipelineLayout, vkDestroyPipelineLayout
)
DEF_CONTEXTUAL_RESOURCE(Buffer, VkBuffer, vkCreateBuffer, vkDestroyBuffer)
DEF_CONTEXTUAL_RESOURCE(Memory, VkDeviceMemory, vkAllocateMemory, vkFreeMemory)
DEF_CONTEXTUAL_RESOURCE(
  DescriptorPool, VkDescriptorPool, vkCreateDescriptorPool, vkDestroyDescriptorPool
)
DEF_CONTEXTUAL_RESOURCE(
  DescriptorSetLayout,
  VkDescriptorSetLayout,
  vkCreateDescriptorSetLayout,
  vkDestroyDescriptorSetLayout
)
DEF_CONTEXTUAL_RESOURCE(Semaphore, VkSemaphore, vkCreateSemaphore, vkDestroySemaphore)
DEF_CONTEXTUAL_RESOURCE(Fence, VkFence, vkCreateFence, vkDestroyFence)

#undef DEF_CONTEXTUAL_RESOURCE

// vkAllocateXXXs(singleton, allocateInfo, &handles);
// vkFreeXXXs(singleton, pool, count, &handles);
template <typename VkHandle, auto* Creator, auto* Destroyer, auto pCountMember, auto pPoolMember>
class AllocatedResources {
private:
  using AllocateInfoArg =
    std::remove_pointer_t<typename toy::FuncArgs<decltype(Creator)>::template at<1>>&;
  using PoolHandle = typename toy::FuncArgs<decltype(Destroyer)>::template at<1>;
  using ContextResource =
    SingletonResourceRetriver<typename toy::FuncArgs<decltype(Creator)>::template at<0>>::type;

public:
  AllocatedResources() : _pool(nullptr) {}
  AllocatedResources(AllocateInfoArg allocate_info) {
    _handles.resize(allocate_info.*pCountMember);
    _pool = allocate_info.*pPoolMember;
    Creator(ContextResource::getInstance().get(), &allocate_info, _handles.data());
    toy::debugf("create {} resources of {}", _handles.size(), getResourceName<VkHandle>());
  }
  ~AllocatedResources() {
    if (_handles.empty()) {
      return;
    }
    Destroyer(ContextResource::getInstance().get(), _pool, _handles.size(), _handles.data());
    toy::debugf("destroy {} resources of {}", _handles.size(), getResourceName<VkHandle>());
  }
  AllocatedResources(const AllocatedResources&) noexcept = delete;
  AllocatedResources(AllocatedResources&&) noexcept = default;
  auto operator=(const AllocatedResources&) noexcept -> AllocatedResources& = delete;
  auto operator=(AllocatedResources&&) noexcept -> AllocatedResources& = default;
  // todo: merge and split

  auto get() const -> std::span<const VkHandle> { return _handles; }

  auto getPool() const -> PoolHandle { return _pool; }

private:
  std::vector<VkHandle> _handles;
  PoolHandle            _pool;
};

#define DEF_ALLOCATED_RESOURCE(Name, VkHandle, Creator, Destroyer, CountMember, PoolMember)        \
  template class AllocatedResources<VkHandle, Creator, Destroyer, CountMember, PoolMember>;        \
  export using Name = AllocatedResources<VkHandle, Creator, Destroyer, CountMember, PoolMember>;

DEF_ALLOCATED_RESOURCE(
  CommandBuffers,
  VkCommandBuffer,
  vkAllocateCommandBuffers,
  vkFreeCommandBuffers,
  &VkCommandBufferAllocateInfo::commandBufferCount,
  &VkCommandBufferAllocateInfo::commandPool
)
DEF_ALLOCATED_RESOURCE(
  DescriptorSets,
  VkDescriptorSet,
  vkAllocateDescriptorSets,
  vkFreeDescriptorSets,
  &VkDescriptorSetAllocateInfo::descriptorSetCount,
  &VkDescriptorSetAllocateInfo::descriptorPool
)

#undef DEF_ALLOCATED_RESOURCE

// vkCreateXXXPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
// pPipelines) vkDestroyPipeline(device, pipeline, pAllocator)
enum class PipelineType {
  GRAPHICS,
  COMPUTE,
};

class Pipeline {
public:
  Pipeline() = default;
  Pipeline(const Pipeline&) noexcept = delete;
  Pipeline(Pipeline&&) noexcept = default;
  auto operator=(const Pipeline&) noexcept -> Pipeline& = delete;
  auto operator=(Pipeline&&) noexcept -> Pipeline& = default;

  auto get() const -> VkPipeline { return _handle.get(); }
  operator VkPipeline() const { return get(); }

private:
  static inline auto deleter = [](VkPipeline handle) {
    vkDestroyPipeline(Device::getInstance().get(), handle, nullptr);
    toy::debugf("destroy resource {}", getResourceName<VkPipeline>());
  };

private:
  template <PipelineType>
  friend class PipelineFactory;
  Pipeline(VkPipeline handle) : _handle(handle) {}

  std::unique_ptr<std::remove_pointer_t<VkPipeline>, decltype(deleter)> _handle;
};

template <PipelineType type>
class PipelineFactory {
private:
  template <PipelineType>
  struct CreatorMapper;
  template <>
  struct CreatorMapper<PipelineType::GRAPHICS> {
    static auto constexpr creator = vkCreateGraphicsPipelines;
  };
  template <>
  struct CreatorMapper<PipelineType::COMPUTE> {
    static auto constexpr creator = vkCreateComputePipelines;
  };

  static auto constexpr creator = CreatorMapper<type>::creator;
  using CreateInfo =
    std::remove_pointer_t<typename toy::FuncArgs<decltype(creator)>::template at<3>>;

public:
  PipelineFactory() = delete;

  static auto create(VkPipelineCache cache, std::span<CreateInfo> create_infos)
    -> std::vector<Pipeline> {
    auto pipelines = std::vector<VkPipeline>{ create_infos.size() };
    creator(
      SingletonResourceRetriver<VkDevice>::type::getInstance().get(),
      cache,
      create_infos.size(),
      create_infos.data(),
      nullptr,
      pipelines.data()
    );
    toy::debugf("create {} resources of {}", pipelines.size(), getResourceName<VkPipeline>());
    return pipelines | views::transform([](auto handle) { return Pipeline{ handle }; }) |
           ranges::to<std::vector>();
  }
};

export using Pipeline = Pipeline;
template class PipelineFactory<PipelineType::GRAPHICS>;
export using GraphicsPipelineFactory = PipelineFactory<PipelineType::GRAPHICS>;
template class PipelineFactory<PipelineType::COMPUTE>;
export using ComputePipelineFactory = PipelineFactory<PipelineType::COMPUTE>;

} // namespace rd::vk::rs
