export module render.vk.tool;

import render.vk.reflections;

import "vulkan_config.h";
import std;
import toy;

export namespace rd::vk {

auto checkVkResult(
  VkResult                        result,
  std::string_view                action,
  std::initializer_list<VkResult> expected_result = { VK_SUCCESS },
  std::source_location            location = std::source_location::current()
) -> VkResult {
  if (!ranges::contains(expected_result, result)) {
    toy::throwf(
      "{}: failed to {}, VkResult: {}",
      toy::formatSourceLocation(location),
      action,
      static_cast<int32_t>(result)
    );
  }
  return result;
}

template <typename Func, typename... Args>
  requires std::is_invocable_v<
    Func,
    std::remove_reference_t<Args>...,
    uint32*,
    typename toy::FuncArgs<Func>::template at<-1>>
auto getVkResources(Func func, Args&&... args) {
  using Resource = std::remove_pointer_t<typename toy::FuncArgs<Func>::template at<-1>>;
  uint32 count;

  constexpr bool need_check = std::same_as<toy::FuncRet<Func>, VkResult>;
  if constexpr (need_check) {
    checkVkResult(
      func(std::forward<Args>(args)..., &count, nullptr),
      std::format("retain number of resource {}", refl::resource<Resource>())
    );
  } else {
    func(std::forward<Args>(args)..., &count, nullptr);
  }
  std::vector<Resource> resources(count);
  if constexpr (need_check) {
    checkVkResult(
      func(args..., &count, resources.data()),
      std::format("get {} resources", refl::resource<Resource>())
    );
  } else {
    func(args..., &count, resources.data());
  }
  return resources;
}

template <typename Func, typename... Args>
  requires std::is_invocable_r_v<
    VkResult,
    Func,
    std::remove_reference_t<Args>...,
    const VkAllocationCallbacks*,
    typename toy::FuncArgs<Func>::template at<-1>>
auto createVkResource(Func func, Args&&... args) {
  using Resource = std::remove_pointer_t<typename toy::FuncArgs<Func>::template at<-1>>;
  Resource resource;
  checkVkResult(
    func(std::forward<Args>(args)..., nullptr, &resource),
    std::format("create {}", refl::resource<Resource>())
  );
  return resource;
}

template <ranges::contiguous_range AvailableRange, typename Mapper>
  requires std::
    is_invocable_r_v<std::string_view, Mapper, ranges::range_reference_t<AvailableRange>>
  void checkAvaliableSupports(
    std::span<const char* const> requiress, AvailableRange&& availables, Mapper&& mapper
  ) {
  using Resource = ranges::range_value_t<AvailableRange>;
  auto resource_name = refl::resource<Resource>();
  toy::debugf(
    "the required {} {} resources are :\n {::}", requiress.size(), resource_name, requiress
  );
  toy::debugf(
    "the available {} {} resources are :\n {::}", availables.size(), resource_name, availables
  );
  auto unsupported_range =
    requiress | views::filter([&availables, &mapper](const auto& required) {
      return ranges::none_of(
        availables,
        [&required](auto extension) { return extension == required; },
        [&mapper](auto& extension) { return std::string_view{ mapper(extension) }; }
      );
    });
  if (!unsupported_range.empty()) {
    toy::throwf(
      "these {} resources requested but not available: \n{::}", resource_name, unsupported_range
    );
  }
}

template <typename T>
concept CustomFormatter =
  std::is_same_v<T, VkExtensionProperties> || std::is_same_v<T, VkLayerProperties>;

} // namespace rd::vk

export template <rd::vk::CustomFormatter T>
class std::formatter<T> : public std::formatter<std::string> {
public:
  template <typename FormatContext, typename... Args>
  auto format(const T& e, FormatContext& ctx) const {
    return std::formatter<std::string>::format(formatString(e), ctx);
  }

private:
  auto formatString(const T& e) const -> std::string {
    if constexpr (std::same_as<T, VkExtensionProperties>) {
      return std::format("{} (version {})", e.extensionName, e.specVersion);
    } else if constexpr (std::same_as<T, VkLayerProperties>) {
      return std::format(
        "{} (spec version {}, implementation version {}) : {} ",
        e.layerName,
        e.specVersion,
        e.implementationVersion,
        e.description
      );
    } else {
      throw 0;
    }
  }
};