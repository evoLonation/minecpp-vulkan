export module model;

import "tinyobj_loader_c.h";
import std;
import toy;
import render.vertex;
import glm;

namespace fs = std::filesystem;

export namespace model {

using Vertex = rd::Vertex<glm::vec3, glm::vec3, glm::vec2>;

struct MeshInfo {
  std::vector<Vertex> vertex_data;
  fs::path            texture_path;
};

void file_reader(
  void* ctx, const char* filename, int is_mtl, const char* obj_filename, char** buf, size_t* len
) {
  toy::debugf("!! {}, {}", filename, obj_filename);
  auto file = std::ifstream();
  file.open(filename, std::ios::binary | std::ios::in | std::ios::ate);
  if (!file.is_open()) {
    toy::throwf("failed to open file {}", filename);
  }
  auto file_size = file.tellg();
  toy::debug(uint64_t(file_size));
  *buf = new char[file_size];
  file.seekg(0);
  file.read(*buf, file_size);
  file.close();
  *len = file_size;
}

/**
 * @param path Do not use string_view because of not guarantee null terminated
 */
auto getModelInfo(const std::string& path)
  -> std::pair<std::vector<Vertex>, std::vector<uint16_t>> {
  tinyobj_attrib_t    attrib;
  tinyobj_shape_t*    p_shape;
  size_t              shape_num;
  tinyobj_material_t* p_material;
  size_t              material_num;
  tinyobj_parse_obj(
    &attrib,
    &p_shape,
    &shape_num,
    &p_material,
    &material_num,
    path.data(),
    // path.string().data(),
    file_reader,
    nullptr,
    0
  );
  auto vertices = std::vector<Vertex>{};
  vertices.reserve(attrib.num_vertices);
  auto indices = std::vector<uint16_t>{};
  indices.reserve(attrib.num_faces);

  toy::debugf("number of shape: {}, number of material: {}", shape_num, material_num);
  toy::debugs(p_shape[0].face_offset, p_shape[0].length);
  toy::debugs(
    attrib.num_faces,
    attrib.num_normals,
    attrib.num_vertices,
    attrib.face_num_verts[0],
    attrib.num_face_num_verts
  );
  toy::debug(std::span{ attrib.face_num_verts, attrib.num_face_num_verts });
  bool method = true;
  if (!method) {
    for (auto face : std::span{ attrib.faces, attrib.num_faces }) {
      indices.push_back(face.v_idx);
    }
    for (int i = 0; i < attrib.num_vertices; i++) {
      vertices.emplace_back(
        glm::vec3{ attrib.vertices[3 * i], attrib.vertices[3 * i + 1], attrib.vertices[3 * i + 2] },
        glm::vec3{ 0.5, 0.5, 0.5 },
        glm::vec2{ 0.5, 0.5 }
      );
    }
  } else {
    for (auto [index, face] : std::span{ attrib.faces, attrib.num_faces } | toy::enumerate) {
      vertices.emplace_back(
        glm::vec3{ attrib.vertices[3 * face.v_idx],
                   attrib.vertices[3 * face.v_idx + 1],
                   attrib.vertices[3 * face.v_idx + 2] },
        glm::vec3{ 0.5, 0.5, 0.5 },
        glm::vec2{ attrib.texcoords[2 * face.vt_idx], 1.0f - attrib.texcoords[2 * face.vt_idx + 1] }
      );
      indices.push_back(index);
    }
  }

  // toy::debug(vertices, indices);
  return std::pair{ std::move(vertices), std::move(indices) };
}

} // namespace model