export module glfw;

import "glfw_config.h";
import toy;
import std;

export namespace glfw {

void checkGlfwError();

class Window {
private:
  void        destroyResource();
  GLFWwindow* window_;

public:
  auto get() const -> GLFWwindow* { return window_; }
  operator GLFWwindow*() const { return get(); }

  Window(const Window&) = delete;
  Window(Window&& window) : window_(window.window_) { window.window_ = nullptr; }
  auto operator=(const Window&) -> Window& = delete;
  auto operator=(Window&& window) -> Window& {
    destroyResource();
    window_ = window.window_;
    window.window_ = nullptr;
    return *this;
  }
  Window() : window_(nullptr) {}
  Window(int width, int height, const std::string& title);
};

void Window::destroyResource() {
  if (window_ != nullptr) {
    glfwDestroyWindow(window_);
    glfwTerminate();
  }
}

Window::Window(int width, int height, const std::string& title) {
  try {
    if (glfwInit() != GLFW_TRUE) {
      throw std::runtime_error("glfw init failed");
    }
    // 不要创建openGL上下文
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    // 禁用改变窗口尺寸
    // glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    window_ = glfwCreateWindow(width, height, title.data(), nullptr, nullptr);

    checkGlfwError();
  } catch (const std::exception&) {
    glfwTerminate();
    throw;
  }
}

void checkGlfwError() {
  const char* description;

  // todo: 使用generator实现
  auto errors = views::repeat(description) | views::take_while([&description](auto _) {
                  return glfwGetError(&description) != GLFW_NO_ERROR;
                });
  if (!errors.empty()) {
    toy::throwf("{::}", errors);
  }
}

} // namespace vk