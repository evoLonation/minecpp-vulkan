export module glfw;

import "glfw_config.h";
import toy;
import std;

import render.vk.instance;

export namespace glfw {

class Context : public toy::ProactiveSingleton<Context> {
public:
  Context() {
    if (glfwInit() != GLFW_TRUE) {
      throw std::runtime_error("glfw init failed");
    }
  }
  ~Context() { glfwTerminate(); }
};

void checkGlfwError();

class Window : public toy::ProactiveSingleton<Window> {
public:
  Window(uint32 width, uint32 height, const std::string& title);
  auto get() const -> GLFWwindow* { return _window.get(); }
  operator GLFWwindow*() const { return get(); }

private:
  void               destroyResource();
  static inline auto deleter = [](GLFWwindow* window) { glfwDestroyWindow(window); };
  std::unique_ptr<GLFWwindow, decltype(deleter)> _window;
};

Window::Window(uint32 width, uint32 height, const std::string& title) {
  // 不要创建openGL上下文
  glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
  // 禁用改变窗口尺寸
  // glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
  _window.reset(glfwCreateWindow(width, height, title.data(), nullptr, nullptr));
  checkGlfwError();
}

void checkGlfwError() {
  const char* description;

  // todo: 使用generator实现
  auto errors = views::repeat(description) | views::take_while([&description](auto _) {
                  return glfwGetError(&description) != GLFW_NO_ERROR;
                });
  if (!errors.empty()) {
    toy::throwf("{::}", errors);
  }
}

} // namespace glfw