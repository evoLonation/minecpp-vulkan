export module transform;

import std;
import glm;
import toy;

export namespace trans {

auto eq(float a, float b) { return glm::abs(a - b) < 0.001f; }
auto eq(glm::vec4 a, glm::vec4 b) {
  return eq(a.x, b.x) && eq(a.y, b.y) && eq(a.z, b.z) && eq(a.w, b.w);
}
auto eq(glm::vec3 a, glm::vec3 b) { return eq(a.x, b.x) && eq(a.y, b.y) && eq(a.z, b.z); }
auto eq(const glm::mat4 a, const glm::mat4 b) {
  return eq(a[0], b[0]) && eq(a[1], b[1]) && eq(a[2], b[2]) && eq(a[3], b[3]);
}
auto equivalence(glm::vec4 a, glm::vec4 b) { return eq(a / a.w, b / b.w); }

// 按照行向量的方式构造矩阵
auto matrix(const std::array<glm::vec4, 4>& vecs) -> glm::mat4 {
  return glm::transpose(glm::mat4{ vecs[0], vecs[1], vecs[2], vecs[3] });
}

auto translate(const glm::vec3& vec) -> glm::mat4 {
  return matrix({
    glm::vec4{ 1.0f, 0.0f, 0.0f, vec.x },
    glm::vec4{ 0.0f, 1.0f, 0.0f, vec.y },
    glm::vec4{ 0.0f, 0.0f, 1.0f, vec.z },
    glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f },
  });
}

auto scale(const glm::vec3& vec) -> glm::mat4 {
  return matrix({
    glm::vec4{ vec.x, 0.0f, 0.0f, 0.0f },
    glm::vec4{ 0.0f, vec.y, 0.0f, 0.0f },
    glm::vec4{ 0.0f, 0.0f, vec.z, 0.0f },
    glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f },
  });
}

enum class Axis { X, Y, Z };

template <Axis axis>
auto rotate(float degree) -> glm::mat4 {
  auto cos = glm::cos(glm::radians(degree));
  auto sin = glm::sin(glm::radians(degree));
  if constexpr (axis == Axis::X) {
    return matrix({
      glm::vec4{ 1.0f, 0.0f, 0.0f, 0.0f },
      glm::vec4{ 0.0f, cos, -sin, 0.0f },
      glm::vec4{ 0.0f, sin, cos, 0.0f },
      glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f },
    });
  } else if constexpr (axis == Axis::Y) {
    return matrix({
      glm::vec4{ cos, 0.0f, sin, 0.0f },
      glm::vec4{ 0.0f, 1.0f, 0.0f, 0.0f },
      glm::vec4{ -sin, 0.0f, cos, 0.0f },
      glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f },
    });
  } else if constexpr (axis == Axis::Z) {
    return matrix({
      glm::vec4{ cos, -sin, 0.0f, 0.0f },
      glm::vec4{ sin, cos, 0.0f, 0.0f },
      glm::vec4{ 0.0f, 0.0f, 1.0f, 0.0f },
      glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f },
    });
  }
}

auto rotate(const glm::vec3& axis_, float degree) -> glm::mat4 {
  auto radian = glm::radians(degree);
  radian /= 2;
  auto sin = glm::sin(radian);
  auto cos = glm::cos(radian);
  auto axis = glm::normalize(axis_);
  auto quaternion = glm::vec4{ cos, axis.x * sin, axis.y * sin, axis.z * sin };
  auto [a, b, c, d] = std::tuple<float&, float&, float&, float&>{
    quaternion.x, quaternion.y, quaternion.z, quaternion.w
  };
  auto [a2, b2, c2, d2] = std::tuple{ a * a, b * b, c * c, d * d };
  auto [ab, ac, ad, bc, bd, cd] = std::tuple{ a * b, a * c, a * d, b * c, b * d, c * d };
  return matrix({
    glm::vec4{ a2 + b2 - c2 - d2, 2 * (bc - ad), 2 * (ac + bd), 0.0f },
    glm::vec4{ 2 * (ad + bc), a2 - b2 + c2 - d2, 2 * (cd - ab), 0.0f },
    glm::vec4{ 2 * (bd - ac), 2 * (ab + cd), a2 - b2 - c2 + d2, 0.0f },
    glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f },
  });
}

auto inverse(const glm::mat4& transform) -> glm::mat4 {
  // transform = translate * q
  // transform^-1 = q^-1 * translate^-1

  // translate and translate^-1
  auto t = translate(glm::vec3{ transform[3] });
  auto t_i = t;
  t_i[3][0] = -t_i[3][0];
  t_i[3][1] = -t_i[3][1];
  t_i[3][2] = -t_i[3][2];
  // q is left up part
  auto q = transform;
  q[3] = glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f };
  auto q_t = glm::transpose(q);
  // scale^2
  auto s2 = q_t * q;
  // scale^-2
  auto s2_i = s2;
  s2_i[0][0] = 1 / s2_i[0][0];
  s2_i[1][1] = 1 / s2_i[1][1];
  s2_i[2][2] = 1 / s2_i[2][2];
  // q^-1 = s^-2 * q^t
  auto q_i = s2_i * q_t;
  return q_i * t_i;
}

// equation: L(t) = direction * t + pointer
struct Line {
  glm::vec3 direction;
  glm::vec3 point;
};
// equation: normal * x = dot
struct Surface {
  glm::vec3 normal;
  float     dot;
};

/**
 * @return std::variant<glm::vec3, bool> : intersection pointer, or overlap(重合) or not
 */
auto intersection(const Line& line, const Surface& surface) -> std::variant<glm::vec3, bool> {
  auto nd = glm::dot(line.direction, surface.normal);
  if (eq(nd, 0)) {
    return eq(glm::dot(surface.normal, line.point), surface.dot);
  } else {
    return line.point - ((glm::dot(surface.normal, line.point) - surface.dot) /
                         glm::dot(surface.normal, line.direction)) *
                          line.direction;
  }
}

namespace model {

auto create(const glm::vec3& location, const glm::vec3& scale) -> glm::mat4 {
  return glm::scale(glm::translate(glm::mat4(1.0f), location), scale);
}
auto create(const glm::vec3& location = glm::vec3{ 0.0f }, float scale = 1.0f) -> glm::mat4 {
  return create(location, glm::vec3(scale, scale, scale));
}

} // namespace model

namespace view {

// Requirement: in the direction of camera, x is front, y is left, z is up
auto create(
  const glm::vec3& position,
  const glm::vec3& target = glm::vec3{ 0.0f },
  const glm::vec3& up = glm::vec3{ 0.0f, 0.0f, 2.0f }
) -> glm::mat4 {
  auto x = glm::normalize(target - position);
  auto y = glm::cross(up, x);
  auto z = glm::normalize(glm::cross(x, y));
  // 用单位基构成的矩阵的几何意义是将向量的坐标变换为这些单位基构成的空间下的坐标
  auto m_rotate = matrix({
    glm::vec4{ x, 0.0f },
    glm::vec4{ y, 0.0f },
    glm::vec4{ z, 0.0f },
    glm::vec4{ 0, 0, 0, 1.0f },
  });
  return m_rotate * translate(-position);
}

} // namespace view

namespace proj {

// transform projection coordinate to vulkan viewport coordinate
// projection coordinate: x -> front, y -> left, z -> up
// viewport coordinate: x -> right, y -> down, z -> front
// the viewport coordinate unit vectors: x -> -y, y -> -z, z -> x
const auto viewport = matrix({
  glm::vec4{ 0.0f, -1.0f, 0.0f, 0.0f },
  glm::vec4{ 0.0f, 0.0f, -1.0f, 0.0f },
  glm::vec4{ 1.0f, 0.0f, 0.0f, 0.0f },
  glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f },
});

auto orthogonal(float near, float far, float left, float right, float bottom, float top)
  -> glm::mat4 {
  auto t = translate(-glm::vec3{ (near + far) / 2, (left + right) / 2, (top + bottom) / 2 });
  auto s = scale(glm::vec3{ 2 / (far - near), 2 / (left - right), 2 / (top - bottom) });
  return viewport * s * t;
}

auto perspective(float near, float far, float left, float right, float bottom, float top)
  -> glm::mat4 {
  auto zip = matrix({
    glm::vec4{ near + far, 0.0f, 0.0f, -near * far },
    glm::vec4{ 0.0f, near, 0.0f, 0.0f },
    glm::vec4{ 0.0f, 0.0f, near, 0.0f },
    glm::vec4{ 1.0f, 0.0f, 0.0f, 0.0f },
  });
  return orthogonal(near, far, left, right, bottom, top) * zip;
}

struct ProjectionInfo {
  uint32_t width;
  uint32_t height;
  float    fovy_degree = 45.0f;
  float    near = 0.1f;
  float    far = 100.f;
};

auto perspective(const ProjectionInfo& info) -> glm::mat4 {
  const auto& [width, height, fovy_degree, near, far] = info;
  float left = near * glm::tan(glm::radians(fovy_degree) / 2);
  float right = -left;
  float top = left * height / width;
  float bottom = -top;
  return perspective(near, far, left, right, bottom, top);
}

auto perspectiveInverse(float near, float far, float left, float right, float bottom, float top)
  -> glm::mat4 {
  auto zip_i = matrix({
    glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f },
    glm::vec4{ 0.0f, 1.0f / near, 0.0f, 0.0f },
    glm::vec4{ 0.0f, 0.0f, 1.0f / near, 0.0f },
    glm::vec4{ -1.0f / (near * far), 0.0f, 0.0f, (near + far) / (near * far) },
  });
  return zip_i * inverse(orthogonal(near, far, left, right, bottom, top));
}

auto perspectiveInverse(const ProjectionInfo& info) -> glm::mat4 {
  const auto& [width, height, fovy_degree, near, far] = info;
  float left = near * glm::tan(glm::radians(fovy_degree) / 2);
  float right = -left;
  float top = left * height / width;
  float bottom = -top;
  return perspectiveInverse(near, far, left, right, bottom, top);
}

} // namespace proj

void test_trans() {
  auto assert = [](bool condition) { toy::checkThrowf(condition, "assert error!"); };
  auto view = view::create({ 1, 0, 0 }, { 1, 1, 0 }, { 0, -1, 1 });
  // assert(eq(view * glm::vec4{ 1, 0, 1, 1 }, glm::vec4{ 0, 0, 1, 1 }));
  assert(eq(view * glm::vec4{ 0, 0, 1, 1 }, glm::vec4{ 0, 1, 1, 1 }));
  assert(eq(view * glm::vec4{ 2, 0, 1, 1 }, glm::vec4{ 0, -1, 1, 1 }));
  assert(eq(view * glm::vec4{ 1, 1, 1, 1 }, glm::vec4{ 1, 0, 1, 1 }));
  assert(eq(view * glm::vec4{ 1, -1, 1, 1 }, glm::vec4{ -1, 0, 1, 1 }));
  auto transform = translate(glm::vec3{ 7, 8, 9 });
  auto I = transform * inverse(transform);
  assert(eq(glm::vec4{ I[0][0], I[1][1], I[2][2], I[3][3] }, glm::vec4{ 1.0f }));
  transform *= rotate(glm::vec3{ 1, 2, 3 }, 56);
  I = transform * inverse(transform);
  assert(eq(glm::vec4{ I[0][0], I[1][1], I[2][2], I[3][3] }, glm::vec4{ 1.0f }));
  transform *= scale(glm::vec3{ 4, 5, 6 });
  I = transform * inverse(transform);
  for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
      if (i == j) {
        assert(eq(I[i][j], 1));
      } else {
        assert(eq(I[i][j], 0));
      }
    }
  }
  // intersection test
  auto inter = intersection(
    {
      .direction = glm::vec3{ glm::sqrt(3.0f), -1.0f, 0.0f },
      .point = glm::vec3{ 0.0f, 1.0f, 1.0f },
    },
    {
      .normal = glm::vec3{ -1.0f, glm::sqrt(3.0f), 0.0f },
      .dot = -glm::sqrt(3.0f),
    }
  );
  assert(inter.index() == 0);
  assert(eq(std::get<0>(inter), glm::vec3(glm::sqrt(3.0f), 0.0f, 1.0f)));

  // proj test
  auto near = 1.0f, far = 3.0f, left = 2.0f, right = 0.0f, bottom = 0.0f, top = 2.0f;
  // auto near = 1.0f, far = 3.0f, left = 2.0f, right = -2.0f, bottom = -2.0f, top = 2.0f;
  auto orthogonal = proj::orthogonal(near, far, left, right, bottom, top);
  assert(eq(
    orthogonal * glm::vec4{ (near + far) / 2, (left + right) / 2, (bottom + top) / 2, 1.0f },
    glm::vec4{ 0.0f, 0.0f, 0.0f, 1.0f }
  ));
  assert(
    eq(orthogonal * glm::vec4{ near, left, bottom, 1.0f }, glm::vec4{ -1.0f, 1.0f, -1.0f, 1.0f })
  );
  assert(eq(orthogonal * glm::vec4{ far, right, top, 1.0f }, glm::vec4{ 1.0f, -1.0f, 1.0f, 1.0f }));
  assert(eq(orthogonal * glm::vec4{ far, right, bottom, 1.0f }, glm::vec4{ 1.0f, 1.0f, 1.0f, 1.0f })
  );
  assert(eq(orthogonal * glm::vec4{ near, left, top, 1.0f }, glm::vec4{ -1.0f, -1.0f, -1.0f, 1.0f })
  );
  auto perspective = proj::perspective(near, far, left, right, bottom, top);
  auto perspective_i = proj::perspectiveInverse(near, far, left, right, bottom, top);
  assert(eq(perspective * perspective_i, glm::mat4{ 1.0f }));
  assert(equivalence(
    perspective * glm::vec4{ near, left, bottom, 1.0f }, glm::vec4{ -1.0f, 1.0f, -1.0f, 1.0f }
  ));
  assert(equivalence(
    perspective * glm::vec4{ near, right, top, 1.0f }, glm::vec4{ 1.0f, -1.0f, -1.0f, 1.0f }
  ));
  assert(equivalence(
    perspective *
      glm::vec4{ far, (left + right) / 2 * far / near, (bottom + top) / 2 * far / near, 1.0f },
    glm::vec4{ 0.0f, 0.0f, 1.0f, 1.0f }
  ));
  assert(equivalence(
    perspective * glm::vec4{ far, left * far / near, bottom * far / near, 1.0f },
    glm::vec4{ -1.0f, 1.0f, 1.0f, 1.0f }
  ));
  assert(equivalence(
    perspective * glm::vec4{ far, right * far / near, top * far / near, 1.0f },
    glm::vec4{ 1.0f, -1.0f, 1.0f, 1.0f }
  ));
  perspective = proj::perspective({ 1920, 1080, 90.0f, 2.5f, 100.0f });
  perspective_i = proj::perspectiveInverse({ 1920, 1080, 90.0f, 2.5f, 100.0f });
  assert(eq(perspective * perspective_i, glm::mat4{ 1.0f }));
  assert(equivalence(
    perspective * glm::vec4{ 2.5f, 0.0f, 0.0f, 1.0f }, glm::vec4{ 0.0f, 0.0f, -1.0f, 1.0f }
  ));
  assert(equivalence(
    perspective * glm::vec4{ 100.0f, 0.0f, 0.0f, 1.0f }, glm::vec4{ 0.0f, 0.0f, 1.0f, 1.0f }
  ));
  assert(equivalence(
    perspective * glm::vec4{ 2.5f, 2.5f, 0.0f, 1.0f }, glm::vec4{ -1.0f, 0.0f, -1.0f, 1.0f }
  ));
}

} // namespace trans