export module action;

import std;
import toy;

import "vulkan_config.h";

import render.context;
import render.loop;
import render.input;

export namespace action {

using Mouse = rd::Mouse;
using Keyboard = rd::Keyboard;
using ButtonState = rd::ButtonState;
using CursorState = rd::CursorState;
using KeyboardEvent = rd::KeyboardEvent;
using MouseEvent = rd::MouseEvent;
struct Screen {
  uint32_t width;
  uint32_t height;
};
struct KeyboardStateChecker {
  auto operator[](Keyboard key) -> std::optional<ButtonState> {
    return rd::InputProcessor::getInstance().getState(key);
  }
};
struct MouseStateChecker {
  auto operator[](Mouse mouse) -> std::optional<ButtonState> {
    return rd::InputProcessor::getInstance().getState(mouse);
  }
};

struct ActionContext {
  uint32_t             interval_milli;
  Screen               screen;
  CursorState          cursor;
  KeyboardStateChecker keyboard;
  MouseStateChecker    mouse;
};

struct KeyboardContext : ActionContext {
  KeyboardEvent event;
};
struct MouseContext : ActionContext {
  MouseEvent event;
};

using ActionHandler = std::function<void(const ActionContext&)>;
using KeyboardHandler = std::function<void(const KeyboardContext&)>;
using MouseHandler = std::function<void(const MouseContext&)>;
using CursorHandler = std::function<void(const ActionContext&)>;

struct ActionInterface {
  virtual void run(const ActionContext& ctx) = 0;
};
struct KeyboardInterface {
  virtual void run(const KeyboardContext& ctx) = 0;
};
struct MouseInterface {
  virtual void run(const MouseContext& ctx) = 0;
};
struct CursorInterface {
  virtual void run(const ActionContext& ctx) = 0;
};

using KeyboardSet = toy::EnumSet<Keyboard>;
using MouseSet = toy::EnumSet<Mouse>;
using StateSet = toy::EnumSet<ButtonState::State>;

class ActionManager : public toy::ProactiveSingleton<ActionManager>,
                      private rd::LoopActionLoader<rd::LoopOrder::EXECUTE_ACTIONS> {
public:
  class Action : public ActionHandler, public toy::HookLoader<Action> {
  public:
    Action(ActionHandler handler) : ActionHandler(std::move(handler)) {}

  private:
    friend toy::HookLoader<Action>;
    auto getContainer() -> toy::RefContainer<Action>& {
      return ActionManager::getInstance()._handlers;
    }
  };
  class ActionLoader : public ActionInterface,
                       public toy::HookLoader<ActionLoader, ActionInterface> {
    friend toy::HookLoader<ActionLoader, ActionInterface>;
    auto getContainer() -> toy::RefContainer<ActionInterface>& {
      return ActionManager::getInstance()._interfaces;
    }
  };
  class CursorAction : public CursorHandler, public toy::HookLoader<CursorAction> {
  public:
    CursorAction(CursorHandler handler) : CursorHandler(std::move(handler)) {}

  private:
    friend toy::HookLoader<CursorAction>;
    auto getContainer() -> toy::RefContainer<CursorAction>& {
      return ActionManager::getInstance()._cursor_handlers;
    }
  };
  class CursorLoader : public CursorInterface,
                       public toy::HookLoader<CursorLoader, CursorInterface> {
    friend toy::HookLoader<CursorLoader, CursorInterface>;
    auto getContainer() -> toy::RefContainer<CursorInterface>& {
      return ActionManager::getInstance()._cursor_interfaces;
    }
  };
  struct KeyboardCondition {
    KeyboardSet _key_set;
    StateSet    _state_set;
  };
  class KeyboardAction : public KeyboardHandler,
                         private KeyboardCondition,
                         public toy::HookLoader<KeyboardAction> {
  private:
    friend toy::HookLoader<KeyboardAction>;
    auto getContainer() {
      return _key_set | views::transform([this](auto key) {
               return _state_set | views::transform([key](auto state) -> auto& {
                        return ActionManager::getInstance()._keyboard_handlers[key][state];
                      });
             }) |
             views::join;
    }

  public:
    KeyboardAction(KeyboardSet key_set, StateSet state_set, KeyboardHandler handler)
      : KeyboardHandler(std::move(handler)), KeyboardCondition(key_set, state_set) {}
    KeyboardAction(KeyboardSet key_set, KeyboardHandler handler)
      : KeyboardAction(key_set, { ButtonState::DOWN, ButtonState::HOLD }, std::move(handler)) {}
  };
  class KeyboardLoader : public KeyboardInterface,
                         private KeyboardCondition,
                         public toy::HookLoader<KeyboardLoader, KeyboardInterface> {
  private:
    friend toy::HookLoader<KeyboardLoader, KeyboardInterface>;
    auto getContainer() {
      return _key_set | views::transform([this](auto key) {
               return _state_set | views::transform([key](auto state) -> auto& {
                        return ActionManager::getInstance()._keyboard_interfaces[key][state];
                      });
             }) |
             views::join;
    }

  public:
    KeyboardLoader(
      KeyboardSet key_set, StateSet state_set = { ButtonState::DOWN, ButtonState::HOLD }
    )
      : KeyboardCondition(key_set, state_set) {}
  };

  struct MouseCondition {
    MouseSet _key_set;
    StateSet _state_set;
  };
  class MouseAction : public MouseHandler,
                      private MouseCondition,
                      public toy::HookLoader<MouseAction> {
  private:
    friend toy::HookLoader<MouseAction>;
    auto getContainer() {
      return _key_set | views::transform([this](auto key) {
               return _state_set | views::transform([key](auto state) -> auto& {
                        return ActionManager::getInstance()._mouse_handlers[key][state];
                      });
             }) |
             views::join;
    }

  public:
    MouseAction(MouseSet key_set, StateSet state_set, MouseHandler handler)
      : MouseHandler(std::move(handler)), MouseCondition(key_set, state_set) {}
    MouseAction(MouseSet key_set, MouseHandler handler)
      : MouseAction(key_set, { ButtonState::DOWN, ButtonState::HOLD }, std::move(handler)) {}
  };
  class MouseLoader : public MouseInterface,
                      private MouseCondition,
                      public toy::HookLoader<MouseLoader, MouseInterface> {
  private:
    friend toy::HookLoader<MouseLoader, MouseInterface>;
    auto getContainer() {
      return _key_set | views::transform([this](auto key) {
               return _state_set | views::transform([key](auto state) -> auto& {
                        return ActionManager::getInstance()._mouse_interfaces[key][state];
                      });
             }) |
             views::join;
    }

  public:
    MouseLoader(MouseSet key_set, StateSet state_set = { ButtonState::DOWN, ButtonState::HOLD })
      : MouseCondition(key_set, state_set) {}
  };

private:
  ActionContext _ctx;

  toy::RefContainer<Action>          _handlers;
  toy::RefContainer<ActionInterface> _interfaces;
  std::map<Keyboard, std::map<ButtonState::State, toy::RefContainer<KeyboardAction>>>
    _keyboard_handlers;
  std::map<Keyboard, std::map<ButtonState::State, toy::RefContainer<KeyboardInterface>>>
    _keyboard_interfaces;
  std::map<Mouse, std::map<ButtonState::State, toy::RefContainer<MouseAction>>> _mouse_handlers;
  std::map<Mouse, std::map<ButtonState::State, toy::RefContainer<MouseInterface>>>
                                     _mouse_interfaces;
  toy::RefContainer<CursorAction>    _cursor_handlers;
  toy::RefContainer<CursorInterface> _cursor_interfaces;

public:
  ActionManager() = default;
  void loopAction(uint32_t interval_milli) override {
    auto& extent = rd::Context::getInstance().extent;
    auto& input = rd::InputProcessor::getInstance();
    _ctx.interval_milli = interval_milli;
    _ctx.screen = { extent.width, extent.height };
    _ctx.cursor = input.getCursorState();
    for (auto* handler_ : _handlers) {
      auto& handler = *handler_;
      handler(_ctx);
    }
    for (auto* interface_ : _interfaces) {
      auto& interface = *interface_;
      interface.run(_ctx);
    }
    for (auto event : input.getKeyboardEvents()) {
      auto ctx = KeyboardContext{ _ctx, event };
      auto& [key, state] = event;
      for (auto* handler_ : _keyboard_handlers[key][state.state]) {
        auto& handler = *handler_;
        handler(ctx);
      }
      for (auto* interface_ : _keyboard_interfaces[key][state.state]) {
        auto& interface = *interface_;
        interface.run(ctx);
      }
    }
    for (auto event : input.getMouseEvents()) {
      auto ctx = MouseContext{ _ctx, event };
      auto& [key, state] = event;
      for (auto* handler_ : _mouse_handlers[key][state.state]) {
        auto& handler = *handler_;
        handler(ctx);
      }
      for (auto* interface_ : _mouse_interfaces[key][state.state]) {
        auto& interface = *interface_;
        interface.run(ctx);
      }
    }
    if (_ctx.cursor.x_move != 0 || _ctx.cursor.y_move != 0) {
      for (auto* handler_ : _cursor_handlers) {
        auto& handler = *handler_;
        handler(_ctx);
      }
      for (auto* interface_ : _cursor_interfaces) {
        auto& interface = *interface_;
        interface.run(_ctx);
      }
    }
  }
};
using Action = ActionManager::Action;
using ActionLoader = ActionManager::ActionLoader;
using KeyboardAction = ActionManager::KeyboardAction;
using KeyboardLoader = ActionManager::KeyboardLoader;
using MouseAction = ActionManager::MouseAction;
using MouseLoader = ActionManager::MouseLoader;
using CursorAction = ActionManager::CursorAction;
using CursorLoader = ActionManager::CursorLoader;

} // namespace action