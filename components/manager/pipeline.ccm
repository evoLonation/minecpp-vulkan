module;
#include "enum.h"
export module manager.pipeline;

import "vulkan_config.h";
import "imgui_config.h";

import std;
import toy;
import render;
import model;
import vulkan;
import gui;
import action;

import manager;

export namespace mng {

TOY_ENUM(PipelineType, DEFAULT, OUTLINE_1, OUTLINE_2);

class Pipeline : public rd::Pipeline {
  friend class PipelineResource;

private:
  PipelineType _pipeline_type;

public:
  Pipeline(PipelineType type) {
    _pipeline_type = type;
    auto stencil_options = vk::getOutliningStencil();
    stencil_options.first.dynamic_reference = false;
    stencil_options.second.dynamic_reference = true;
    switch (type.value()) {
    case PipelineType::DEFAULT:
      rd::Pipeline::operator=(rd::Pipeline{
        "hello.vert",
        "hello.frag",
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        model::Vertex::getVertexInfo(),
        std::array{ rd::ResourceType::UNIFORM,
                    rd::ResourceType::UNIFORM,
                    rd::ResourceType::UNIFORM,
                    rd::ResourceType::SAMPLER },
        std::nullopt,
      });
      break;
    case PipelineType::OUTLINE_1:
      rd::Pipeline::operator=(rd::Pipeline{
        "hello.vert",
        "hello.frag",
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        model::Vertex::getVertexInfo(),
        std::array{ rd::ResourceType::UNIFORM,
                    rd::ResourceType::UNIFORM,
                    rd::ResourceType::UNIFORM,
                    rd::ResourceType::SAMPLER },
        stencil_options.first,
      });
      break;
    case PipelineType::OUTLINE_2:
      rd::Pipeline::operator=(rd::Pipeline{
        "outline.vert",
        "outline.frag",
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        model::Vertex::getVertexInfo(),
        std::array{
          rd::ResourceType::UNIFORM, rd::ResourceType::UNIFORM, rd::ResourceType::UNIFORM },
        stencil_options.second,
      });
      break;
    }
  }
  Pipeline(const Pipeline&) noexcept = delete;
  Pipeline(Pipeline&&) noexcept = delete;
  auto operator=(const Pipeline&) noexcept -> Pipeline& = delete;
  auto operator=(Pipeline&&) noexcept -> Pipeline& = delete;
};

struct PipelineResource {
  static constexpr auto resource_name = "pipeline";
  using resource = Pipeline;
  using reference_infos = toy::TypePack<>;
  using create_infos = toy::TypePack<Info<"pipeline type", PipelineType>>;
  using serialize_infos = create_infos;

  // create the resourse using info
  static auto create(const action::ActionContext& _, PipelineType type) -> Pipeline {
    return Pipeline{ type };
  }
  static auto serialize(const action::ActionContext& _, const Pipeline& pipeline)
    -> std::tuple<PipelineType> {
    return pipeline._pipeline_type;
  }
  static auto deserialize(const action::ActionContext& _, PipelineType type) -> Pipeline {
    return create(_, type);
  }
};

static_assert(ResourceMetable<PipelineResource>, "");

} // namespace mng