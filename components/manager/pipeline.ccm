module;
#include "enum.h"
export module manager.pipeline;

import "vulkan_config.h";
import "imgui_config.h";

import std;
import toy;
import render;
import model;
import vulkan;
import gui;
import action;

import manager;

export namespace mng {

TOY_ENUM(PipelineType, DEFAULT, OUTLINE_1, OUTLINE_2);

class Pipeline : public rd::Pipeline {
private:
  PipelineType _pipeline_type;

public:
  auto getType() const -> PipelineType { return _pipeline_type; }

public:
  Pipeline(PipelineType pipeline_type)
    : rd::Pipeline([&]() {
        auto stencil_options = vk::getOutliningStencil();
        stencil_options.first.dynamic_reference = false;
        stencil_options.second.dynamic_reference = true;
        switch (pipeline_type.value()) {
        case PipelineType::DEFAULT:
          return rd::PipelineInfo{
            "hello.vert",
            "hello.frag",
            VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
            model::Vertex::getVertexInfo(),
            std::array{ rd::ResourceType::UNIFORM,
                        rd::ResourceType::UNIFORM,
                        rd::ResourceType::UNIFORM,
                        rd::ResourceType::SAMPLER },
            std::nullopt,
          };
        case PipelineType::OUTLINE_1:
          return rd::PipelineInfo{
            "hello.vert",
            "hello.frag",
            VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
            model::Vertex::getVertexInfo(),
            std::array{ rd::ResourceType::UNIFORM,
                        rd::ResourceType::UNIFORM,
                        rd::ResourceType::UNIFORM,
                        rd::ResourceType::SAMPLER },
            stencil_options.first,
          };
        case PipelineType::OUTLINE_2:
          return rd::PipelineInfo{
            "outline.vert",
            "outline.frag",
            VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
            model::Vertex::getVertexInfo(),
            std::array{
              rd::ResourceType::UNIFORM, rd::ResourceType::UNIFORM, rd::ResourceType::UNIFORM },
            stencil_options.second,
          };
        }
      }()),
      _pipeline_type(pipeline_type) {}

  Pipeline(const Pipeline&) noexcept = delete;
  Pipeline(Pipeline&&) noexcept = delete;
  auto operator=(const Pipeline&) noexcept -> Pipeline& = delete;
  auto operator=(Pipeline&&) noexcept -> Pipeline& = delete;
};

struct PipelineResource {
  static constexpr auto resource_name = "pipeline";
  using resource = Pipeline;
  using reference_infos = toy::TypePack<>;
  using create_infos = toy::TypePack<Info<"pipeline type", PipelineType>>;
  using serialize_infos = create_infos;

  // create the resourse using info
  static auto create(const action::ActionContext& _, PipelineType type) -> Pipeline {
    return Pipeline{ type };
  }
  static auto serialize(const action::ActionContext& _, const Pipeline& pipeline)
    -> std::tuple<PipelineType> {
    return pipeline.getType();
  }
  static auto deserialize(const action::ActionContext& _, PipelineType type) -> Pipeline {
    return create(_, type);
  }
};

static_assert(ResourceMetable<PipelineResource>, "");

} // namespace mng