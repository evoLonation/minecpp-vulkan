module;
#include "enum.h"

export module manager;

import "vulkan_config.h";
import "imgui_config.h";

import std;
import toy;
import gui;
import action;
import glm;

import manager.helper;

export namespace mng {

template <toy::StringLiteral str, typename T>
struct Info {
  static constexpr auto name = str.value;
  using type = T;
};

template <typename T>
struct IsInfo {
  static constexpr auto value = false;
};
template <toy::StringLiteral str, typename T>
struct IsInfo<Info<str, T>> {
  static constexpr auto value = true;
};
template <typename T>
struct InfoTypeMapper {
  using type = T::type;
};

template <typename T>
concept ResourceMetable_1 = requires() {
  typename T::resource;
  { T::resource_name } -> std::same_as<const char* const&>;
  // TypePack of reference type infos which resource need associated with
  typename T::reference_infos;
  requires toy::Filter<typename T::reference_infos, IsInfo>::size == T::reference_infos::size;
  // TypePack of basic type infos which resource need created by
  typename T::create_infos;
  requires toy::Filter<typename T::create_infos, IsInfo>::size == T::create_infos::size;
  // TypePack of basic type infos which resource serialized and deserialized by
  typename T::serialize_infos;
  requires toy::Filter<typename T::serialize_infos, IsInfo>::size == T::serialize_infos::size;
};

template <ResourceMetable_1 T>
struct Helper_1 {
  static constexpr auto info_type_mapper = []<typename... Args>() {
    return toy::TypePack<typename Args::type...>{};
  };
  static constexpr auto info_name_mapper = []<typename... Args>() {
    if constexpr (sizeof...(Args) == 0) {
      return std::array<const char*, 0>{};
    } else {
      return std::array{ Args::name... };
    }
  };
  static constexpr auto reference_pointer_mapper = []<ResourceMetable_1... Args>() {
    return toy::TypePack<typename Args::resource*...>{};
  };
  using resource = T::resource;

  // reference
  using reference_infos = T::reference_infos;
  using reference_metas = decltype(reference_infos::applyFunc(info_type_mapper));
  static constexpr auto reference_names = reference_infos::applyFunc(info_name_mapper);
  using reference_pointers = decltype(reference_metas::applyFunc(reference_pointer_mapper));
  using reference_pointer_tuple = reference_pointers::template apply<std::tuple>;
  using reference_name_array = std::array<std::string, reference_infos::size>;

  // create
  using create_infos = T::create_infos;
  using create_types = decltype(create_infos::applyFunc(info_type_mapper));
  static constexpr auto create_names = create_infos::applyFunc(info_name_mapper);
  // combine with reference
  using create_params = toy::Merge<create_types, reference_pointers>;
  using create_tuple = create_params::template apply<std::tuple>;

  using serialize_infos = T::serialize_infos;
  using serialize_types = decltype(serialize_infos::applyFunc(info_type_mapper));
  static constexpr auto serialize_names = serialize_infos::applyFunc(info_name_mapper);
  using serialize_ret = serialize_types::template apply<std::tuple>;
  using deserialize_params = toy::Merge<serialize_types, reference_pointers>;

  static constexpr auto resource_name = T::resource_name;
};

template <typename T>
concept ResourceMetable = requires() {
  requires ResourceMetable_1<T>;
  // resource is moveable
  // requires std::is_nothrow_move_constructible_v<typename Helper_1<T>::resource>;
  // each type of create_types can used to call modifyByGui
  requires Helper_1<T>::create_types::applyFunc([]<typename... Args>() {
    return requires(Args... e) { (modifyByGui("", e), ...); };
  });
  // T::create returns R, parameter is match with const ActionContext& + const create_params&...
  requires Helper_1<T>::create_params::applyFunc([]<typename... Params>() {
    return requires(const action::ActionContext& ctx, const Params&... param) {
      // crash on clang 17.06
      // { T::create(ctx, param...) } -> std::same_as<typename Helper_1<T>::resource>;
      T::create(ctx, param...);
    };
  });
  requires std::same_as<toy::FuncRet<decltype(T::create)>, typename Helper_1<T>::resource>;
  // each type of serialize_types can used to call serialize and deserialize
  requires Helper_1<T>::serialize_types::applyFunc([]<typename... Args>() {
    return requires(Args... e) {
      (serialize(e), ...);
      (deserialize<Args>(std::declval<json::Json>()), ...);
    };
  });
  // T::serialize receives the ctx, resource and returns serialize_tuple
  requires requires(
    const action::ActionContext& ctx, const typename Helper_1<T>::resource& resource
  ) {
    { T::serialize(ctx, resource) } -> std::same_as<typename Helper_1<T>::serialize_ret>;
  };
  // T::deserialize receives the ctx, const deserialize_params&... and returns resource
  requires Helper_1<T>::deserialize_params::applyFunc([]<typename... Params>() {
    return requires(const action::ActionContext& ctx, const Params&... param) {
      // crash on clang 17.06
      // { T::deserialize(ctx, param...) } -> std::same_as<typename Helper_1<T>::resource>;
      T::deserialize(ctx, param...);
    };
  });
  requires std::same_as<toy::FuncRet<decltype(T::deserialize)>, typename Helper_1<T>::resource>;
};

struct SubManagerInterface {
  virtual void draw() = 0;
  virtual auto save(const action::ActionContext& ctx) -> json::Json = 0;
  /**
   * @brief make sure already call load for all reference sub managers
   */
  virtual void load(const action::ActionContext& ctx, const json::Json&) = 0;
  virtual auto getRefManagers() -> std::vector<SubManagerInterface*> = 0;
  virtual ~SubManagerInterface() = default;
};

template <ResourceMetable ResourceMeta>
// using ResourceT = PipelineResource;
class SubManager : private action::ActionLoader, public SubManagerInterface {
private:
  template <ResourceMetable>
  friend class SubManager;
  using Helper = Helper_1<ResourceMeta>;

  std::string                  _create_name;
  Helper::create_tuple         _create_infos;
  Helper::reference_name_array _create_reference_names;

  std::queue<std::function<void(const action::ActionContext&)>> _create_events;

  std::map<std::string, std::array<uint8_t, sizeof(typename Helper::resource)>> _resource_contents;
  std::map<std::string, typename Helper::resource*>                             _resources;
  std::map<std::string, typename Helper::reference_name_array> _resource_references;

  using reference_manager_tuple =
    toy::MapTo<toy::ApplyTo<typename Helper::reference_metas, SubManager>, std::add_pointer>::
      template apply<std::tuple>;
  reference_manager_tuple _ref_managers;

  std::array<gui::SelectableList<std::string>, Helper::reference_metas::size> _ref_select_lists;

  gui::SelectableList<std::string> _resource_name_list;

public:
  SubManager() = default;
  ~SubManager() { destroyResources(); }

  template <typename RefResourceMeta>
  void registerRefManager(SubManager<RefResourceMeta>* sub_manager) {
    constexpr auto index = Helper::reference_metas::template search<RefResourceMeta>();
    std::get<index>(_ref_managers) = sub_manager;
  }

  // second: the index of _ref_select
  template <size_t index, typename RefResourceMeta = Helper::reference_metas::template at<index>>
  auto getRefManager() -> SubManager<RefResourceMeta>& {
    return *std::get<index>(_ref_managers);
  }
  auto getRefManagers() -> std::vector<SubManagerInterface*> override {
    return toy::applyIndexSequence<Helper::reference_infos::size>([&]<size_t... index>() {
      return std::vector<SubManagerInterface*>{ &getRefManager<index>()... };
    });
  }

  void createResource(
    std::string resource_name, Helper::reference_name_array reference_names, auto creator
  ) {
    _resources.emplace(
      resource_name, new (_resource_contents[resource_name].data()) Helper::resource{ creator() }
    );
    _resource_references.emplace(resource_name, std::move(reference_names));
  }

  void destroyResources() {
    for (auto* resource : _resources | views::values) {
      using ResourceT = typename Helper::resource;
      resource->~ResourceT();
    }
  }

  void drawCreate() {
    gui::inputText(std::format("{} name", Helper::resource_name), _create_name);
    toy::templateForEach<Helper::create_types::size>([&]<size_t index>() {
      constexpr auto name = Helper::create_names[index];
      using Type = Helper::create_params::template at<index>;
      modifyByGui<Type>(name, std::get<index>(_create_infos));
    });
    toy::templateForEach<Helper::create_params::size - Helper::create_types::size>(
      [&]<size_t index>() {
        constexpr auto name = Helper::reference_names[index];

        auto& sub_manager = getRefManager<index>();
        auto& ref_list = _ref_select_lists[index];
        auto* selected = ref_list.getSelected();
        ImGui::Text(
          "%s",
          std::format(
            "selected {}: {}", name, selected == nullptr ? std::string("None") : *selected
          )
            .data()
        );
        if (selected != nullptr) {
          _create_reference_names[index] = *selected;
          std::get<index + Helper::create_types::size>(_create_infos) =
            sub_manager._resources.at(*selected);
        }
        ref_list.draw(sub_manager._resources | views::keys);
      }
    );
    if (ImGui::Button(std::format("create {}", Helper::resource_name).data())) {
      _create_events.emplace([&](const action::ActionContext& ctx) {
        createResource(
          std::move(_create_name),
          std::move(_create_reference_names),
          [&]() -> decltype(auto) {
            return std::apply(
              &ResourceMeta::create, std::tuple_cat(std::forward_as_tuple(ctx), _create_infos)
            );
          }
        );
      });
    }
  }

  void draw() override {
    ImGui::SeparatorText(std::format("{} create", Helper::resource_name).data());
    drawCreate();
    ImGui::SeparatorText(std::format("{} list", Helper::resource_name).data());
    _resource_name_list.draw(_resources | views::keys);
  }

  auto save(const action::ActionContext& ctx) -> json::Json override {
    using namespace json;
    auto json_list = std::vector<Json>{};
    for (auto& [name, resource] : _resources) {
      auto json = Json{};
      auto ret = ResourceMeta::serialize(ctx, *resource);
      auto reference_array = _resource_references.at(name);
      toy::templateForEach<Helper::serialize_infos::size>([&]<size_t index>() {
        json[Helper::serialize_names[index]] = serialize(std::get<index>(ret));
      });
      toy::templateForEach<Helper::reference_infos::size>([&]<size_t index>() {
        json[Helper::reference_names[index]] = reference_array[index];
      });
      json_list.push_back(Json{ { "resource_name", name }, { "info", std::move(json) } });
    }
    return json_list;
  }

  void load(const action::ActionContext& ctx, const json::Json& json_list) override {
    using namespace json;
    for (auto& json_ : json_list.to<List>()) {
      auto name = json_["resource_name"].to<String>();
      auto json_info = json_["info"];
      auto reference_names =
        toy::applyIndexSequence<Helper::reference_infos::size>([&]<size_t... index>() {
          return typename Helper::reference_name_array{
            json_info[Helper::reference_names[index]].template to<String>()...
          };
        });
      createResource(name, reference_names, [&]() {
        return toy::applyIndexSequence<Helper::deserialize_params::size>(
          [&]<size_t... index>() -> auto {
            return ResourceMeta::deserialize(ctx, [&]() -> auto {
              if constexpr (index < Helper::serialize_infos::size) {
                return deserialize<typename Helper::serialize_types::template at<index>>(
                  json_info[Helper::serialize_names[index]]
                );
              } else {
                constexpr auto index_ref = index - Helper::serialize_infos::size;

                auto& ref_manager = getRefManager<index_ref>();
                auto* ref_resource = ref_manager._resources.at(reference_names[index_ref]);
                return ref_resource;
              }
            }()...);
          }
        );
      });
    }
  }

  void run(const action::ActionContext& ctx) override {
    while (!_create_events.empty()) {
      _create_events.back()(ctx);
      _create_events.pop();
    }
  }
  SubManager(const SubManager&) noexcept = delete;
  SubManager(SubManager&&) noexcept = default;
  auto operator=(const SubManager&) noexcept -> SubManager& = delete;
  auto operator=(SubManager&&) noexcept -> SubManager& = default;
};
namespace fs = std::filesystem;
class Manager : private gui::DrawerLoader, private action::ActionLoader {
private:
  std::vector<std::unique_ptr<SubManagerInterface>> _sub_managers;
  std::map<SubManagerInterface*, const char*>       _manager_names;

  bool        _click_save;
  bool        _open_save_input;
  std::string _save_name;

  bool                     _open_load_input;
  bool                     _fresh_save_files;
  std::vector<std::string> _save_files;
  int32_t                  _selected_load;
  bool                     _click_load;

  static inline auto _save_dir = std::filesystem::path{ "save" };

public:
  Manager()
    : _click_save(), _open_save_input(), _selected_load(-1), _fresh_save_files(), _click_load() {
    registerSubManagers();
    if (!fs::exists(_save_dir)) {
      toy::throwf(
        fs::create_directories(_save_dir), "create save dir {} failed", _save_dir.string()
      );
    } else {
      toy::debugf("save dir {} already exists", _save_dir.string());
    }
  }

  void registerSubManagers();

  template <ResourceMetable ResourceT>
  void registerSubManager(SubManager<ResourceT>* sub_manager) {
    using Helper = Helper_1<ResourceT>;
    _sub_managers.emplace_back(sub_manager);
    _manager_names.emplace(sub_manager, Helper::resource_name);
  }

  ~Manager() {
    // destroy sub_managers by order
    while (!_sub_managers.empty()) {
      _sub_managers.pop_back();
    }
  }

  void draw() override {
    // ImGuiWindowFlags_MenuBar: enable menu bar
    ImGui::Begin("Resource manager", nullptr, ImGuiWindowFlags_MenuBar);
    if (ImGui::BeginMenuBar()) {
      if (ImGui::BeginMenu("File")) {
        if (ImGui::MenuItem("Save")) {
          _open_save_input = true;
        }
        if (ImGui::MenuItem("Load")) {
          _open_load_input = true;
          _fresh_save_files = false;
          _selected_load = -1;
        }
        ImGui::EndMenu();
      }
      ImGui::EndMenuBar();
    }
    for (auto& sub_manager : _sub_managers) {
      sub_manager->draw();
    }
    if (ImGui::Button("save scene")) {
    }
    ImGui::End();
    if (_open_save_input) {
      ImGui::Begin("save scene");
      gui::inputText("filename", _save_name);
      _click_save = ImGui::Button("save");
      if (_click_save) {
        _open_save_input = false;
      }
      ImGui::End();
    }
    if (_open_load_input) {
      if (!_fresh_save_files) {
        _save_files =
          fs::directory_iterator{ _save_dir } |
          views::filter([](auto& entry) { return entry.is_regular_file(); }) |
          views::transform([](auto& entry) { return entry.path().filename().string(); }) |
          ranges::to<std::vector>();
        _fresh_save_files = true;
      }
      ImGui::Begin("load scene");
      gui::selectable(_save_files, _selected_load);
      if (_selected_load != -1) {
        _open_load_input = false;
        _click_load = true;
      }
      ImGui::End();
    }
  }

  void run(const action::ActionContext& ctx) override {
    if (_click_save) {
      _click_save = false;
      toy::debug("click save!");
      auto json = json::Json{};
      for (auto& [sub_manager, name] : _manager_names) {
        json[name] = sub_manager->save(ctx);
      }
      auto path = _save_dir / (_save_name + ".json");
      auto fs = std::ofstream{ path };
      toy::throwf(fs.is_open(), "failed to open {}", path.string());
      fs << json.dump();
    }
    if (_click_load) {
      _click_load = false;
      auto load_file = _save_dir / _save_files[_selected_load];
      auto fs = std::ifstream{ load_file };
      toy::throwf(fs.is_open(), "failed to open file {}", load_file.string());
      auto json = json::Json::parse(std::move(fs));
      auto loaded_managers = std::set<SubManagerInterface*>{};
      std::function<void(SubManagerInterface * sub_manager)> load =
        [&](SubManagerInterface* sub_manager) {
          if (loaded_managers.contains(sub_manager)) {
            return;
          }
          for (auto* ref_manager : sub_manager->getRefManagers()) {
            load(ref_manager);
          }
          sub_manager->load(ctx, json[_manager_names[sub_manager]]);
          loaded_managers.insert(sub_manager);
        };
      for (auto& sub_manager : _sub_managers) {
        load(sub_manager.get());
      }
    }
  }
};

} // namespace mng