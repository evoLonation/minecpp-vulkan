export module input;

import glfw;

import "glfw_config.h";

import std;
import toy;

export namespace input {

enum class Mouse {
  LEFT,
  RIGHT,
  MAX_ENUM_VALUE,
};

auto mouseMapper(int mouse) -> Mouse {
  switch (mouse) {
  case GLFW_MOUSE_BUTTON_LEFT:
    return Mouse::LEFT;
  case GLFW_MOUSE_BUTTON_RIGHT:
    return Mouse::RIGHT;
  default:
    toy::throwf("mouse wrapper pass wrong parameter");
  }
}

enum class Keyboard {
  SPACE,
  APOSTROPHE,
  COMMA,
  MINUS,
  PERIOD,
  SLASH,
  NUM_0,
  NUM_1,
  NUM_2,
  NUM_3,
  NUM_4,
  NUM_5,
  NUM_6,
  NUM_7,
  NUM_8,
  NUM_9,
  SEMICOLON,
  EQUAL,
  KEY_A,
  KEY_B,
  KEY_C,
  KEY_D,
  KEY_E,
  KEY_F,
  KEY_G,
  KEY_H,
  KEY_I,
  KEY_J,
  KEY_K,
  KEY_L,
  KEY_M,
  KEY_N,
  KEY_O,
  KEY_P,
  KEY_Q,
  KEY_R,
  KEY_S,
  KEY_T,
  KEY_U,
  KEY_V,
  KEY_W,
  KEY_X,
  KEY_Y,
  KEY_Z,
  LEFT_BRACKET,
  BACKSLASH,
  RIGHT_BRACKET,
  GRAVE_ACCENT,
  WORLD_1,
  WORLD_2,
  ESCAPE,
  ENTER,
  TAB,
  BACKSPACE,
  INSERT,
  DELETE,
  RIGHT,
  LEFT,
  DOWN,
  UP,
  PAGE_UP,
  PAGE_DOWN,
  HOME,
  END,
  CAPS_LOCK,
  SCROLL_LOCK,
  NUM_LOCK,
  PRINT_SCREEN,
  PAUSE,
  F1,
  F2,
  F3,
  F4,
  F5,
  F6,
  F7,
  F8,
  F9,
  F10,
  F11,
  F12,
  F13,
  F14,
  F15,
  F16,
  F17,
  F18,
  F19,
  F20,
  F21,
  F22,
  F23,
  F24,
  F25,
  KP_0,
  KP_1,
  KP_2,
  KP_3,
  KP_4,
  KP_5,
  KP_6,
  KP_7,
  KP_8,
  KP_9,
  KP_DECIMAL,
  KP_DIVIDE,
  KP_MULTIPLY,
  KP_SUBTRACT,
  KP_ADD,
  KP_ENTER,
  KP_EQUAL,
  LEFT_SHIFT,
  LEFT_CONTROL,
  LEFT_ALT,
  LEFT_SUPER,
  RIGHT_SHIFT,
  RIGHT_CONTROL,
  RIGHT_ALT,
  RIGHT_SUPER,
  MENU,
  MAX_ENUM_VALUE,
};
auto keyboardMapper(int key) -> Keyboard {
  switch (key) {
  case GLFW_KEY_SPACE:
    return Keyboard::SPACE;
  case GLFW_KEY_APOSTROPHE:
    return Keyboard::APOSTROPHE;
  case GLFW_KEY_COMMA:
    return Keyboard::COMMA;
  case GLFW_KEY_MINUS:
    return Keyboard::MINUS;
  case GLFW_KEY_PERIOD:
    return Keyboard::PERIOD;
  case GLFW_KEY_SLASH:
    return Keyboard::SLASH;
  case GLFW_KEY_0:
    return Keyboard::NUM_0;
  case GLFW_KEY_1:
    return Keyboard::NUM_1;
  case GLFW_KEY_2:
    return Keyboard::NUM_2;
  case GLFW_KEY_3:
    return Keyboard::NUM_3;
  case GLFW_KEY_4:
    return Keyboard::NUM_4;
  case GLFW_KEY_5:
    return Keyboard::NUM_5;
  case GLFW_KEY_6:
    return Keyboard::NUM_6;
  case GLFW_KEY_7:
    return Keyboard::NUM_7;
  case GLFW_KEY_8:
    return Keyboard::NUM_8;
  case GLFW_KEY_9:
    return Keyboard::NUM_9;
  case GLFW_KEY_SEMICOLON:
    return Keyboard::SEMICOLON;
  case GLFW_KEY_EQUAL:
    return Keyboard::EQUAL;
  case GLFW_KEY_A:
    return Keyboard::KEY_A;
  case GLFW_KEY_B:
    return Keyboard::KEY_B;
  case GLFW_KEY_C:
    return Keyboard::KEY_C;
  case GLFW_KEY_D:
    return Keyboard::KEY_D;
  case GLFW_KEY_E:
    return Keyboard::KEY_E;
  case GLFW_KEY_F:
    return Keyboard::KEY_F;
  case GLFW_KEY_G:
    return Keyboard::KEY_G;
  case GLFW_KEY_H:
    return Keyboard::KEY_H;
  case GLFW_KEY_I:
    return Keyboard::KEY_I;
  case GLFW_KEY_J:
    return Keyboard::KEY_J;
  case GLFW_KEY_K:
    return Keyboard::KEY_K;
  case GLFW_KEY_L:
    return Keyboard::KEY_L;
  case GLFW_KEY_M:
    return Keyboard::KEY_M;
  case GLFW_KEY_N:
    return Keyboard::KEY_N;
  case GLFW_KEY_O:
    return Keyboard::KEY_O;
  case GLFW_KEY_P:
    return Keyboard::KEY_P;
  case GLFW_KEY_Q:
    return Keyboard::KEY_Q;
  case GLFW_KEY_R:
    return Keyboard::KEY_R;
  case GLFW_KEY_S:
    return Keyboard::KEY_S;
  case GLFW_KEY_T:
    return Keyboard::KEY_T;
  case GLFW_KEY_U:
    return Keyboard::KEY_U;
  case GLFW_KEY_V:
    return Keyboard::KEY_V;
  case GLFW_KEY_W:
    return Keyboard::KEY_W;
  case GLFW_KEY_X:
    return Keyboard::KEY_X;
  case GLFW_KEY_Y:
    return Keyboard::KEY_Y;
  case GLFW_KEY_Z:
    return Keyboard::KEY_Z;
  case GLFW_KEY_LEFT_BRACKET:
    return Keyboard::LEFT_BRACKET;
  case GLFW_KEY_BACKSLASH:
    return Keyboard::BACKSLASH;
  case GLFW_KEY_RIGHT_BRACKET:
    return Keyboard::RIGHT_BRACKET;
  case GLFW_KEY_GRAVE_ACCENT:
    return Keyboard::GRAVE_ACCENT;
  case GLFW_KEY_WORLD_1:
    return Keyboard::WORLD_1;
  case GLFW_KEY_WORLD_2:
    return Keyboard::WORLD_2;
  case GLFW_KEY_ESCAPE:
    return Keyboard::ESCAPE;
  case GLFW_KEY_ENTER:
    return Keyboard::ENTER;
  case GLFW_KEY_TAB:
    return Keyboard::TAB;
  case GLFW_KEY_BACKSPACE:
    return Keyboard::BACKSPACE;
  case GLFW_KEY_INSERT:
    return Keyboard::INSERT;
  case GLFW_KEY_DELETE:
    return Keyboard::DELETE;
  case GLFW_KEY_RIGHT:
    return Keyboard::RIGHT;
  case GLFW_KEY_LEFT:
    return Keyboard::LEFT;
  case GLFW_KEY_DOWN:
    return Keyboard::DOWN;
  case GLFW_KEY_UP:
    return Keyboard::UP;
  case GLFW_KEY_PAGE_UP:
    return Keyboard::PAGE_UP;
  case GLFW_KEY_PAGE_DOWN:
    return Keyboard::PAGE_DOWN;
  case GLFW_KEY_HOME:
    return Keyboard::HOME;
  case GLFW_KEY_END:
    return Keyboard::END;
  case GLFW_KEY_CAPS_LOCK:
    return Keyboard::CAPS_LOCK;
  case GLFW_KEY_SCROLL_LOCK:
    return Keyboard::SCROLL_LOCK;
  case GLFW_KEY_NUM_LOCK:
    return Keyboard::NUM_LOCK;
  case GLFW_KEY_PRINT_SCREEN:
    return Keyboard::PRINT_SCREEN;
  case GLFW_KEY_PAUSE:
    return Keyboard::PAUSE;
  case GLFW_KEY_F1:
    return Keyboard::F1;
  case GLFW_KEY_F2:
    return Keyboard::F2;
  case GLFW_KEY_F3:
    return Keyboard::F3;
  case GLFW_KEY_F4:
    return Keyboard::F4;
  case GLFW_KEY_F5:
    return Keyboard::F5;
  case GLFW_KEY_F6:
    return Keyboard::F6;
  case GLFW_KEY_F7:
    return Keyboard::F7;
  case GLFW_KEY_F8:
    return Keyboard::F8;
  case GLFW_KEY_F9:
    return Keyboard::F9;
  case GLFW_KEY_F10:
    return Keyboard::F10;
  case GLFW_KEY_F11:
    return Keyboard::F11;
  case GLFW_KEY_F12:
    return Keyboard::F12;
  case GLFW_KEY_F13:
    return Keyboard::F13;
  case GLFW_KEY_F14:
    return Keyboard::F14;
  case GLFW_KEY_F15:
    return Keyboard::F15;
  case GLFW_KEY_F16:
    return Keyboard::F16;
  case GLFW_KEY_F17:
    return Keyboard::F17;
  case GLFW_KEY_F18:
    return Keyboard::F18;
  case GLFW_KEY_F19:
    return Keyboard::F19;
  case GLFW_KEY_F20:
    return Keyboard::F20;
  case GLFW_KEY_F21:
    return Keyboard::F21;
  case GLFW_KEY_F22:
    return Keyboard::F22;
  case GLFW_KEY_F23:
    return Keyboard::F23;
  case GLFW_KEY_F24:
    return Keyboard::F24;
  case GLFW_KEY_F25:
    return Keyboard::F25;
  case GLFW_KEY_KP_0:
    return Keyboard::KP_0;
  case GLFW_KEY_KP_1:
    return Keyboard::KP_1;
  case GLFW_KEY_KP_2:
    return Keyboard::KP_2;
  case GLFW_KEY_KP_3:
    return Keyboard::KP_3;
  case GLFW_KEY_KP_4:
    return Keyboard::KP_4;
  case GLFW_KEY_KP_5:
    return Keyboard::KP_5;
  case GLFW_KEY_KP_6:
    return Keyboard::KP_6;
  case GLFW_KEY_KP_7:
    return Keyboard::KP_7;
  case GLFW_KEY_KP_8:
    return Keyboard::KP_8;
  case GLFW_KEY_KP_9:
    return Keyboard::KP_9;
  case GLFW_KEY_KP_DECIMAL:
    return Keyboard::KP_DECIMAL;
  case GLFW_KEY_KP_DIVIDE:
    return Keyboard::KP_DIVIDE;
  case GLFW_KEY_KP_MULTIPLY:
    return Keyboard::KP_MULTIPLY;
  case GLFW_KEY_KP_SUBTRACT:
    return Keyboard::KP_SUBTRACT;
  case GLFW_KEY_KP_ADD:
    return Keyboard::KP_ADD;
  case GLFW_KEY_KP_ENTER:
    return Keyboard::KP_ENTER;
  case GLFW_KEY_KP_EQUAL:
    return Keyboard::KP_EQUAL;
  case GLFW_KEY_LEFT_SHIFT:
    return Keyboard::LEFT_SHIFT;
  case GLFW_KEY_LEFT_CONTROL:
    return Keyboard::LEFT_CONTROL;
  case GLFW_KEY_LEFT_ALT:
    return Keyboard::LEFT_ALT;
  case GLFW_KEY_LEFT_SUPER:
    return Keyboard::LEFT_SUPER;
  case GLFW_KEY_RIGHT_SHIFT:
    return Keyboard::RIGHT_SHIFT;
  case GLFW_KEY_RIGHT_CONTROL:
    return Keyboard::RIGHT_CONTROL;
  case GLFW_KEY_RIGHT_ALT:
    return Keyboard::RIGHT_ALT;
  case GLFW_KEY_RIGHT_SUPER:
    return Keyboard::RIGHT_SUPER;
  case GLFW_KEY_MENU:
    return Keyboard::MENU;
  default:
    toy::throwf("illegal keyboard");
  }
}
struct ButtonState {
  enum State {
    DOWN, // FREE to HOLD
    HOLD,
    RELEASE, // HOLD to FREE
    MAX_ENUM_VALUE,
  } state;
  // in DOWN, is always at 0
  float hold_time;
};
struct CursorState {
  uint32 x;
  uint32 y;
  int32_t  x_move;
  int32_t  y_move;
  bool     visible;
};
struct KeyboardEvent {
  Keyboard    key;
  ButtonState state;
};
struct MouseEvent {
  Mouse       mouse;
  ButtonState state;
};
struct KeyboardListener {
  virtual void listen(KeyboardEvent e) = 0;
};
struct MouseListener {
  virtual void listen(MouseEvent e) = 0;
};
struct CursorListener {
  virtual void listen(CursorState e) = 0;
};

class InputProcessor : public toy::ProactiveSingleton<InputProcessor> {
public:
  class KeyboardListenerLoader : public KeyboardListener,
                                 public toy::HookLoader<KeyboardListenerLoader, KeyboardListener> {
    friend toy::HookLoader<KeyboardListenerLoader, KeyboardListener>;
    auto getContainer() -> toy::RefContainer<KeyboardListener>& {
      return InputProcessor::getInstance()._keyboard_listeners;
    }
  };
  class MouseListenerLoader : public MouseListener,
                              public toy::HookLoader<MouseListenerLoader, MouseListener> {
    friend toy::HookLoader<MouseListenerLoader, MouseListener>;
    auto getContainer() -> toy::RefContainer<MouseListener>& {
      return InputProcessor::getInstance()._mouse_listeners;
    }
  };
  class CursorListenerLoader : public CursorListener,
                               public toy::HookLoader<CursorListenerLoader, CursorListener> {
    friend toy::HookLoader<CursorListenerLoader, CursorListener>;
    auto getContainer() -> toy::RefContainer<CursorListener>& {
      return InputProcessor::getInstance()._cursor_listeners;
    }
  };

private:
  toy::RefContainer<KeyboardListener> _keyboard_listeners;
  toy::RefContainer<MouseListener>    _mouse_listeners;
  toy::RefContainer<CursorListener>   _cursor_listeners;

  std::map<Keyboard, ButtonState> _key_states;
  std::map<Mouse, ButtonState>    _mouse_states;

  CursorState _cursor_state;

  InputProcessor(const InputProcessor&) = delete;
  InputProcessor(InputProcessor&&) = delete;
  auto operator=(const InputProcessor&) -> InputProcessor& = delete;
  auto operator=(InputProcessor&&) -> InputProcessor& = delete;

public:
  InputProcessor(toy::ImplicitDep<glfw::Context> ctx) {
    auto window = glfw::Window::getInstance().get();
    // 须在创建窗口后、开始渲染前注册回调函数
    glfwSetKeyCallback(
      window,
      [](GLFWwindow* window, int key_, int scancode, int action, int mods) {
        updateState(getInstance()._key_states, keyboardMapper(key_), action);
      }
    );
    glfwSetMouseButtonCallback(window, [](GLFWwindow* window, int mouse_, int action, int mods) {
      updateState(getInstance()._mouse_states, mouseMapper(mouse_), action);
    });
    double last_x, last_y;
    glfwGetCursorPos(window, &last_x, &last_y);
    _cursor_state = {
      .x = static_cast<uint32>(last_x),
      .y = static_cast<uint32>(last_y),
      .x_move = 0,
      .y_move = 0,
      .visible = false,
    };
    glfwSetCursorPosCallback(window, [](GLFWwindow* window, double x, double y) {
      auto& instance = getInstance();
      toy::checkf(x - (int32_t)x == 0.0f, "the x from cursor callback is not integer");
      toy::checkf(y - (int32_t)y == 0.0f, "the y from cursor callback is not integer");
      instance._cursor_state.x_move = (int32_t)x - (int32_t)instance._cursor_state.x;
      instance._cursor_state.y_move = (int32_t)y - (int32_t)instance._cursor_state.y;
      instance._cursor_state.x = x;
      instance._cursor_state.y = y;
      for (auto* listener : instance._cursor_listeners) {
        listener->listen(instance._cursor_state);
      }
    });
    setCursorVisible(true);
  }
  template <typename Button>
  static void updateState(std::map<Button, ButtonState>& states, Button key, int action) {
    if (action == GLFW_REPEAT) {
      return;
    }
    toy::throwf(action == GLFW_PRESS || action == GLFW_RELEASE, "action equal to another value");
    auto press = action == GLFW_PRESS;
    toy::throwf(
      press == (!states.contains(key) || states.at(key).state == ButtonState::RELEASE),
      "The state of InputProcessor is not match to glfw callback"
    );
    if (press) {
      auto state = ButtonState{
        .state = ButtonState::DOWN,
        .hold_time = 0,
      };
      states.emplace(key, state);
    } else {
      states.at(key).state = ButtonState::RELEASE;
    }
  }

  auto getCursorState() -> const CursorState& { return _cursor_state; }
  auto getState(Keyboard key) -> std::optional<ButtonState> {
    if (_key_states.contains(key)) {
      return _key_states.at(key);
    } else {
      return {};
    }
  }
  auto getState(Mouse mouse) -> std::optional<ButtonState> {
    if (_mouse_states.contains(mouse)) {
      return _mouse_states.at(mouse);
    } else {
      return {};
    }
  }
  auto getKeyboardEvents() -> std::vector<KeyboardEvent> {
    return _key_states |
           views::transform([](auto& pair) { return KeyboardEvent{ pair.first, pair.second }; }) |
           ranges::to<std::vector>();
  }
  auto getMouseEvents() -> std::vector<MouseEvent> {
    return _mouse_states |
           views::transform([](auto& pair) { return MouseEvent{ pair.first, pair.second }; }) |
           ranges::to<std::vector>();
  }

  void setCursorVisible(bool visible) {
    if (_cursor_state.visible == visible) {
      return;
    }
    _cursor_state.visible = visible;
    if (visible) {
      glfwSetInputMode(glfw::Window::getInstance().get(), GLFW_CURSOR, GLFW_CURSOR_NORMAL);
    } else {
      glfwSetInputMode(glfw::Window::getInstance().get(), GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    }
  }

  void processInput(float interval) {
    auto states_hanlder = [&](auto& states) {
      for (auto iter = states.begin(); iter != states.end();) {
        auto& state = iter->second;
        state.hold_time += interval;
        if (state.state == ButtonState::DOWN) {
          state.state = ButtonState::HOLD;
        }
        if (state.state == ButtonState::RELEASE) {
          iter = states.erase(iter);
        } else {
          iter++;
        }
      }
    };
    states_hanlder(_key_states);
    states_hanlder(_mouse_states);
    _cursor_state.x_move = 0;
    _cursor_state.y_move = 0;
    glfwPollEvents();
    for (auto* listener : _keyboard_listeners) {
      for (auto& [key, state] : _key_states) {
        listener->listen({
          .key = key,
          .state = state,
        });
      }
    }
    for (auto* listener : _mouse_listeners) {
      for (auto& [mouse, state] : _mouse_states) {
        listener->listen({
          .mouse = mouse,
          .state = state,
        });
      }
    }
  }
};

using KeyboardListenerLoader = InputProcessor::KeyboardListenerLoader;
using MouseListenerLoader = InputProcessor::MouseListenerLoader;
using CursorListenerLoader = InputProcessor::CursorListenerLoader;

} // namespace input
